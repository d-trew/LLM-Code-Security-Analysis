[
  {
    "source": "2016\\qualification_round\\coin_jam",
    "problem_name": "Coin Jam",
    "python_code": "def generate_jamcoin(N, J):\n    for i in range(J + 1):\n        jamcoin = str(i) * N\n        divisors = []\n        for base in range(2, 11):\n            jamcoin_base = int(jamcoin, base)\n            for j in range(2, jamcoin_base + 1):\n                if jamcoin_base % j == 0 and all([j % k != 0 for k in range(2, 10)]):\n                    divisors.append(j)\n        if len(divisors) >= 9:\n            print(\"Case #\", i + 1, \":\", jamcoin, *divisors[:9])\ngenerate_jamcoin(32, 500)",
    "generated_at": "2025-05-03T20:26:12.413392",
    "generation_time": 11.12694764137268,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\qualification_round\\counting_sheep",
    "problem_name": "Counting Sheep",
    "python_code": "import sys\nfrom collections import Counter\n\ndef count_digits(n):\n    digits = [0] * 10\n    i = 1\n    while True:\n        for digit in str(i*n):\n            if int(digit) not in digits:\n                digits[int(digit)] += 1\n            if all(digits):\n                return i*n\n            i += 1\n\ndef main():\n    T = int(input())\n    \n    for tc in range(T):\n        N = int(input())\n        \n        last_number = count_digits(N)\n        \n        if last_number == float('inf'):\n            print(\"Case #{}: INSOMNIA\".format(tc+1))\n        else:\n            print(\"Case #{}: {}\".format(tc+1, last_number))\n            \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:26:18.485166",
    "generation_time": 6.067052125930786,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\qualification_round\\fractiles",
    "problem_name": "Fractiles",
    "python_code": "import math\n\ndef fractal_artwork(K, C):\n    artwork = \"L\" * K + \"G\" * (math.pow(2, C) - 1) * K + \"L\" * K\n    return artwork[:K]\n\nT = int(input())\nfor i in range(1, T+1):\n    K, C, S = map(int, input().split())\n    if S >= K:\n        print(\"Case #{}: IMPOSSIBLE\".format(i))\n    else:\n        tiles_to_clean = list(range(1, min(S+1) + 1))\n        print(\"Case #{}: {}\".format(i, \" \".join(map(str, tiles_to_clean)))<|im_sep|>",
    "generated_at": "2025-05-03T20:26:27.674322",
    "generation_time": 5.685430288314819,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\qualification_round\\revenge_of_the_pancakes",
    "problem_name": "Revenge of the Pancakes",
    "python_code": "import sys\n\ndef min_flips(pancakes):\n    n = len(pancakes)\n    flips = 0\n    for i in range(n):\n        if pancakes[i] == '-':\n            break\n        else:\n            flips += 1\n    return flips\n\ndef main():\n    T = int(input())\n    for case in range(1, T+1):\n        pancakes = input()\n        print(\"Case #%d: %d\" % (case, min_flips(pancakes))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:26:32.448015",
    "generation_time": 4.768960237503052,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\round_1a\\bffs",
    "problem_name": "BFFs",
    "python_code": "import sys\nsys.setrecursionlimit(10**6) # To handle larger input sizes, increase recursion limit\n\ndef find_max_circle_size(kids):\n    def dfs(node, visited, graph, circle, parent=None):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and dfs(neighbor, visited, graph, circle, node):\n                circle.append(neighbor)\n                return True\n        return False\n\n    def max_circle_size(kids):\n        max_size = 0\n        for i in range(1, len(kids) + 1):\n            if i not in kids:\n                continue\n            visited = set()\n            graph = {i}\n            circle = []\n            while kids[i] != i and dfs(i, visited, graph, circle):\n                graph.add(kids[i])\n                circle.append(kids[i])\n            max_size = max(max_size, len(circle))\n        return max_size\n\n    T = int(input()) # Number of test cases\n    for t in range(1, T + 1):\n        N = int(input()) # Number of kids in the class\n        kids = [0] * (N + 1)\n        for i in range(1, N + 1):\n            kids[i] = int(input()) # BFF of each kid\n        print(\"Case #{}: {}\".format(t, max_circle_size(kids)))\n\n# Example input:\n# 2\n# 3\n# 1 2 3\n# 3 2 1\n# 4\n# 1 2 3 4 5\n# 2 3 4 5 6\n\n# Example output:\n# Case #1: 2\n# Case #2: 3",
    "generated_at": "2025-05-03T20:26:45.364304",
    "generation_time": 11.56147837638855,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\round_1a\\rank_and_file",
    "problem_name": "Rank and File",
    "python_code": "T = int(input()) # read number of test cases\nfor i in range(1, T+1):\n    N = int(input())\n    lists = []\n    for j in range(2*N-1):\n        lists.append([int(x) for x in input().split()])\n    \n    # sort the 2*N-1 lists of soldiers' heights\n    for l in lists:\n        l.sort()\n        \n    # find the missing list by comparing pairs of rows and columns\n    for r in range(N):\n        row = []\n        col = []\n        for j in range(N):\n            row.append(lists[2*r][j])\n            col.append(lists[2*r+1][j])\n        \n        # check if the rows and columns are different\n        if row != lists[2*r]:\n            print(\"Case #{}: {}\".format(i, \" \".join([str(x) for x in row]))\n            break\n        elif col != lists[2*r+1]:\n            print(\"Case #{}: {}\".format(i, \" \".join([str(x) for x in col]))\n            break\n    else:\n        # if no missing list found, check the last two rows and columns\n        row = []\n        col = []\n        for j in range(N):\n            row.append(lists[-2][j])\n            col.append(lists[2*N-1][j])\n        \n        # check if the rows and columns are different\n        if row != lists[-2]:\n            print(\"Case #{}: {}\".format(i, \" \".join([str(x) for x in row]))\n        elif col != lists[2*N-1]:\n            print(\"Case #{}: {}\".format(i, \" \".join([str(x) for x in col])",
    "generated_at": "2025-05-03T20:26:56.670509",
    "generation_time": 11.299617290496826,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\round_1a\\the_last_word",
    "problem_name": "The Last Word",
    "python_code": "n = int(input()) # read the number of test cases\r\nfor i in range(1, n+1):\r\n    s = input().strip()\r\n    if len(s) % 2 == 0:\r\n        s = 'A' + s[::-1] + 'A'\r\n    else:\r\n        s = 'A' + s[::-1] + 'B'\r\n    print(\"Case #{}: {}\".format(i, sorted([s[:len(s)//2], s[len(s)//2+1:])[0][::-1]) if len(s) > 1 else s)",
    "generated_at": "2025-05-03T20:27:00.737355",
    "generation_time": 4.0614728927612305,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\round_1b\\close_match",
    "problem_name": "Close Match",
    "python_code": "import sys\n\ndef find_minimum(s):\n    def fill_digits(score, missing_count):\n        if len(score) == 1 or missing_count == 0:\n            return score\n        for i in range(len(score)):\n            if score[i] == '?':\n                for j in range(10):\n                    new_score = score[:i] + str(j) + score[i+1:]\n                    yield from fill_digits(new_score, missing_count - 1)\n\n    def get_minimum(scores):\n        coder, jammer = scores\n        min_diff = abs(int(coder) - int(jammer))\n        for i in range(len(coder)):\n            if coder[i] == '?' and jammer[i] != '?':\n                for digit in fill_digits(coder[:i] + '0' + coder[i+1:], missing_count):\n                    diff = abs(int(digit) - int(jammer))\n                    if diff < min_diff or (diff == min_diff and int(digit) > int(coder)):\n                        min_diff, coder = diff, digit + jammer[i+1:]\n            elif coder[i] != '?' and jammer[i] == '?':\n                for digit in fill_digits(coder[:i] + str(jammer[i]) + coder[i+1:], missing_count):\n                    diff = abs(int(digit) - int(coder))\n                    if diff < min_diff or (diff == min_diff and int(digit) < int(coder)):\n                        min_diff, jammer = diff, coder[:i+1] + digit[i] + jammer[i+1:]\n        return coder, jammer\n    missing_count = s.count('?')\n    if missing_count == 0:\n        return s, s\n    return get_minimum(get_minimum([''.join(sorted(s[:len(s)//2])[::-1], ''.join(sorted(s[len(s)//2:])[::-1])])) if missing_count % 2 == 0 else s.replace('?', '9'))\n\nT = int(input())\nfor i in range(1, T+1):\n    coder, jammer = input().split()\n    coder_filled, jammer_filled = find_minimum(coder), find_minimum(jammer)\n    print(f\"Case #{i}: {coder_filled} {jammer_filled}\")",
    "generated_at": "2025-05-03T20:27:18.289320",
    "generation_time": 16.080494165420532,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\round_1b\\getting_the_digits",
    "problem_name": "Getting the Digits",
    "python_code": "import string\n\ndef get_digit(word):\n    return {'ZERO': '0', 'ONE': '1', 'TWO': '2', 'THREE': '3', 'FOUR': '4', 'FIVE': '5', 'SIX': '6', 'SEVEN': '7', 'EIGHT': '8', 'NINE': '9'}[word]\n\ndef main():\n    T = int(input())\n    for i in range(1, T + 1):\n        S = input()\n        digits = []\n        for word in string.ascii_uppercase:\n            if word in S:\n                digit = get_digit(word)\n                while word in S and len(digits) < 10:\n                    index = S.index(word)\n                    digits.append(digit)\n                    S = S[:index] + S[index+len(word):]\n        print(\"Case #{}: {}\".format(i, ''.join(sorted(digits)))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:27:24.845695",
    "generation_time": 6.550854921340942,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\round_1b\\technobabble",
    "problem_name": "Technobabble",
    "python_code": "import random\r\n\r\ndef is_fake(topics):\r\n    for i in range(len(topics)):\r\n        if topics[i] in [' '.join([topics[j][1], topics[j][0]) for j in range(len(topics))]:\r\n            return False\r\n    return True\r\n\r\ndef max_fakes():\r\n    N = int(input())\r\n    cases = []\r\n    for i in range(N):\r\n        topics = [input().split() for _ in range(int(input()))]\r\n        if is_fake(topics):\r\n            cases.append(len(topics))\r\n        else:\r\n            cases.append(-1)\r\n    return cases\r\n\r\ndef main():\r\n    T = int(input())\r\n    for i in range(T):\r\n        print(\"Case #%d: %d\" % (i+1, max_fakes()[i]) if max_fakes()[i] != -1 else \"Case #%d: 0\" % (i+1))\r\n    \r\nif __name__ == '__main__':\r\n    main()",
    "generated_at": "2025-05-03T20:27:32.532604",
    "generation_time": 7.681998014450073,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\round_1c\\fashion_police",
    "problem_name": "Fashion Police",
    "python_code": "def main():\n    T = int(input())\n    for i in range(T):\n        J, P, S, K = map(int, input().split())\n        max_days = min(J * P * S // (K + 1), P * S)\n        print(\"Case #{}: {}\".format(i+1, max_days))\n        if max_days == 0:\n            continue\n        for j in range(min(J, K+1)):\n            for p in range(min(P, K+1):\n                shirt = (j * S) // (K + 1)\n                print(\"{} {} {}\".format(j, p, shirt))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:27:38.026155",
    "generation_time": 5.48630690574646,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\round_1c\\senate_evacuation",
    "problem_name": "Senate Evacuation",
    "python_code": "T = int(input())\nfor t in range(1, T+1):\n    N = int(input())\n    parties = input().split()\n    P = [int(x) for x in input().split()]\n    \n    # Calculate the current party with most senators\n    max_party = max(P)\n    evacuation_plan = []\n    \n    while sum(P):\n        # Find index of largest party and remove one or two senators from it\n        i = P.index(max_party)\n        if P[i] > 1:\n            P[i] -= 2\n            evacuation_plan.append(chr(ord('A')+i))\n            evacuation_plan.append(chr(ord('A')+i))\n        else:\n            P[i] -= 1\n            evacuation_plan.append(chr(ord('A')+i))\n        \n        # Update max party and its count if necessary\n        new_max = max(P)\n        if new_max > max_party or (new_max == max_party and sum(P[0:i]) < sum(P[i+1:])):\n            max_party = new_max\n    \n    print(\"Case #{}: {}\".format(t, \" \".join(evacuation_plan))",
    "generated_at": "2025-05-03T20:27:46.656048",
    "generation_time": 8.623731136322021,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\round_1c\\slides",
    "problem_name": "Slides!",
    "python_code": "import itertools\n\nT = int(input())\n\nfor i in range(1, T + 1):\n    B, M = map(int, input().split())\n    \n    def is_possible(B, M):\n        if M == 0 or M > (2 ** (B - 1) - 1):\n            return False\n        \n        # Generate all possible ways to build slides using itertools.product\n        for way in itertools.product([0, 1], repeat=B-1):\n            if sum(way[:M]) == M:\n                print(\"Case #{}: POSSIBLE\".format(i))\n                # Print the matrix representation of the slides\n                for j in range(len(way) + 1):\n                    line = \" \".join([str(x) for x in way[:j]]) + \" 0\" * (B - j)\n                    print(line)\n                break\n        else:\n            print(\"Case #{}: IMPOSSIBLE\".format(i))\n    \n    is_possible(B, M)",
    "generated_at": "2025-05-03T20:27:53.761319",
    "generation_time": 7.100744009017944,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\round_2\\freeform_factory",
    "problem_name": "Freeform Factory",
    "python_code": "def main():\n    T = int(input())\n    for i in range(T):\n        N = int(input())\n        workers_machines = []\n        for _ in range(N):\n            workers_machines.append([int(x) for x in input()])\n        \n        max_operators = sum(max(row) for row in workers_machines)\n        min_dollars = 0\n        for i in range(N):\n            num_operators = sum(workers_machines[i])\n            if num_operators < max_operators:\n                min_dollars += (max_operators - num_operators)\n        \n        print(\"Case #%d: %d\" % (i+1, min_dollars))\n    \nmain()",
    "generated_at": "2025-05-03T20:28:00.703985",
    "generation_time": 5.106673002243042,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\round_2\\rather_perplexing_showdown",
    "problem_name": "Rather Perplexing Showdown",
    "python_code": "import itertools\nfrom collections import Counter\n\ndef rock_paper_scissors(N):\n    lineups = []\n    for r in range(1, N+1):\n        for p in range(1, N-r+1):\n            s = N - r - p\n            if s > 0:\n                lineup = ''.join(['R']*r + ['P']*p + ['S']*s)\n                lineups.append(''.join([lineup[::2], lineup[1::2]]))\n    return sorted(lineups)\n\nT = int(input())\nfor i in range(1, T+1):\n    N, R, P, S = map(int, input().split())\n    \n    if (R + P + S) % 2 != 0:\n        print(\"Case #{}: IMPOSSIBLE\".format(i))\n    else:\n        lineups = rock_paper_scissors(N)\n        \n        if len(lineups) == 0:\n            print(\"Case #{}: IMPOSSIBLE\".format(i))\n        else:\n            sorted_lineup = min(lineups, key=Counter)\n            print(\"Case #{}: {}\".format(i, sorted_lineup[::-1]) if (R >= P and S >= R) or (P >= R and S >= P) else \"Case #{} IMPOSSIBLE\".format(i))",
    "generated_at": "2025-05-03T20:28:10.574421",
    "generation_time": 9.864824056625366,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\round_2\\red_tape_committee",
    "problem_name": "Red Tape Committee",
    "python_code": "def main():\n    T = int(input())\n    for i in range(T):\n        N, K = map(int, input().split())\n        P = list(map(float, input().split()))\n        \n        # Calculate the probability of a tie\n        max_prob = 0.0\n        for j in range(N):\n            for k in range(j+1, N):\n                prob = min(P[j], P[k]) * (1 - max(P[j], P[k])) + max(P[j], P[k]) * (1 - min(P[j], P[k]))\n                if K == 2:\n                    max_prob = max(max_prob, prob)\n        print(\"Case #{}: {}\".format(i+1, max_prob))\n        \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:28:18.358153",
    "generation_time": 5.641487121582031,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\round_2\\the_gardener_of_seville",
    "problem_name": "The Gardener of Seville",
    "python_code": "import itertools\ndef hedge_maze(lovers):\n    # Create the maze with all walls\n    maze = [['/'] * (2*R+2) for _ in range(2*C+2)]\n    \n    # Add the lover pairs to the maze\n    for pair in lovers:\n        row1, col1, row2, col2 = pair[0]-1, pair[1]-1, pair[2]-1, pair[3]-1\n        if row1 == row2 and col1 == col2:\n            return \"IMPOSSIBLE\"\n        \n        # Check if the cells are adjacent\n        if abs(row1 - row2) + abs(col1 - col2) != 1:\n            continue\n        \n        # Connect the lovers with a diagonal path\n        if row1 < row2 and col1 > col2:\n            maze[row1][col1] = '\\\\'\n            maze[row2+1][col2+1] = '/'\n        elif row1 > row2 and col1 < col2:\n            maze[row1][col1] = '/'\n            maze[row2+1][col2+1] = '\\\\'\n        \n    # Check if all lovers are connected\n    for i in range(R):\n        for j in range(C):\n            if maze[i][j] == '/':\n                if maze[i-1][j+1] != '\\\\' and (i,j) not in lovers:\n                    return \"IMPOSSIBLE\"\n            elif maze[i][j] == '\\\\':\n                if maze[i+1][j-1] != '/' and (i,j) not in lovers:\n                    return \"IMPOSSIBLE\"\n    \n    # Remove the outer wall\n    for i in range(2):\n        for j in range(C+2):\n            maze.pop(0)\n        maze = list(itertools.chain(*maze))\n        \n    return ''.join(maze)\n    \n# Read test cases\nT = int(input())\nfor i in range(1, T+1):\n    R, C = map(int, input().split())\n    lovers = []\n    for _ in range(R*C//2):\n        pair = list(map(int, input().split()))\n        lovers.append([pair[0], pair[1], pair[3], pair[4]])\n    \n    # Generate the maze\n    result = hedge_maze(lovers)\n    \n    print(\"Case #{}:\".format(i))\n    if result == \"IMPOSSIBLE\":\n        print(result)\n    else:\n        for row in range(R+2):\n            print(''.join(result[row*(C+2):(row+1)*(C+2)]))",
    "generated_at": "2025-05-03T20:28:37.935546",
    "generation_time": 19.57194209098816,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\round_3\\forest_university",
    "problem_name": "Forest University",
    "python_code": "T = int(input()) # number of test cases\nfor i in range(1, T+1):\n    N, M = map(int, input().split()) # read the number of courses and the number of cool words\n    courses = {} # dictionary to store prerequisites for each course\n    \n    for j in range(N):\n        line = input()\n        if line[1] == 'B': # basic course\n            courses[line[0]] = []\n        else: # advanced course\n            prereq, adv_course = line.split()\n            courses[adv_case] = [prereq]\n    \n    for j in range(M):\n        cool_word = input().strip()\n        \n        count = 0 # number of valid sequences that contain the cool word as a substring\n        total_count = 0 # total number of possible sequences\n        \n        for key, value in courses.items():\n            if len(value) == 1: # only one prerequisite\n                prereq = value[0]\n                count += 1 # start with the prerequisite and continue with the course that has no prerequisites\n                \n                for k in range(len(cool_word)):\n                    if cool_word[k] == key:\n                        total_count += 2**(N-1) # since we start with a prereq, there are always two ways to complete the remaining courses (with or without it)\n            \n            elif len(value) == 0: # no prerequisites\n                for k in range(len(cool_word)):\n                    if cool_word[k] == key:\n                        total_count += 1\n        \n        print(\"Case #{}: {}\".format(i), end=\"\")\n        for j in range(M):\n            count = float(count) / total_count # calculate the fraction of valid sequences that contain the cool word as a substring\n            if count >= 0.97 and count <= 1.03: # within an absolute error of 0.03\n                print(\" {:.6f}\".format(count), end=\"\")\n            else:\n                print(\" {:.5f}\".format(count), end=\"\")\n        print()",
    "generated_at": "2025-05-03T20:28:52.227039",
    "generation_time": 14.286887884140015,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\round_3\\go",
    "problem_name": "Go++",
    "python_code": "import sys\n\ndef check_output(bad, good):\n    if len(good) == 0 or len(bad) != len(good[0]):\n        return \"IMPOSSIBLE\"\n    \n    for g in good:\n        if set(g) - set(bad):\n            return \"IMPOSSIBLE\"\n        \n    program1 = \"\"\n    program2 = \"\"\n    count = 0\n    \n    for i, c in enumerate(bad):\n        if bad[i] == '0' and len(good) * '0' not in good:\n            program1 += \"?\"\n            program2 += \"0\"\n        elif bad[i] == '1' and len(good) * '1' not in good:\n            program1 += \"1\"\n            program2 += \"?\"\n        else:\n            return \"IMPOSSIBLE\"\n        \n    if count > 200:\n        return \"IMPOSSIBLE\"\n    \n    return f\"{program1}\\n{program2}\"\n\ndef main():\n    T = int(input())\n    for i in range(1, T + 1):\n        N, L = map(int, input().split())\n        good = [input() for _ in range(N)]\n        bad = input()\n        \n        result = check_output(bad, good)\n        print(f\"Case #{i}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:29:02.296480",
    "generation_time": 10.062189102172852,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\round_3\\rebel_against_the_empire",
    "problem_name": "Rebel Against The Empire",
    "python_code": "def main():\n    T = int(input())\n    for i in range(T):\n        N, S = map(int, input().split())\n        asteroids = []\n        max_dist = 0\n        for _ in range(N):\n            x, y, z, Vx, Vy, Vz = map(float, input().split())\n            asteroids.append((x, y, z, Vx, Vy, Vz))\n        # Your code here to calculate max_dist based on the given constraints and conditions",
    "generated_at": "2025-05-03T20:29:06.646955",
    "generation_time": 4.345582962036133,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\round_3\\teaching_assistant",
    "problem_name": "Teaching Assistant",
    "python_code": "import sys\n\ndef main():\n    T = int(input())\n    \n    for i in range(1, T+1):\n        S = input()\n        \n        max_score = 0\n        last_requested = None\n        coding_points = 0\n        jamming_points = 0\n        \n        for day, mood in enumerate(S):\n            if mood == 'C':\n                if last_requested is None or last_requested == 'J':\n                    max_score += 10\n                    coding_points += 5\n                else:\n                    coding_points = 5\n            \n            elif mood == 'J':\n                if last_requested is None or last_requested == 'C':\n                    max_score += 5\n                    jamming_points += 10\n                else:\n                    jamming_points = 5\n            \n            last_requested = mood\n        \n        print(\"Case #{}: {}\".format(i, max_score + coding_points - jamming_points))\n    \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:29:15.343946",
    "generation_time": 8.681360244750977,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\world_finals\\family_hotel",
    "problem_name": "Family Hotel",
    "python_code": "This program takes a list of integers as input and returns the sum of all even numbers in the list. The program should use a for loop to iterate over each element in the list, check if it is even, and add it to a running total if it is even. Finally, return the total.\r\n\r\n\r\nHere's an example:",
    "generated_at": "2025-05-03T20:29:20.294454",
    "generation_time": 1.8508918285369873,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\world_finals\\integeregex",
    "problem_name": "Integeregex",
    "python_code": "def main():\n    T = int(input())\n    for i in range(T):\n        A, B = map(int, input().split())\n        R = input()\n        \n        count = 0\n        for num in range(A, B+1):\n            if match_regex(R, str(num)):\n                count += 1\n                \n        print(\"Case #{}: {}\".format(i+1, count))\n    \ndef match_regex(R, D):\n    if R == \"\":\n        return False\n    i = 0\n    j = 0\n    while i < len(D) and j < len(R):\n        if D[i] == '(':\n            break\n        elif R[j] == '.':\n            i += 1\n        elif R[j] == '*':\n            return match_regex(R[:j-1], D[i+1:]) or match_regex(R, D[i+1:])\n        else:\n            if D[i] != R[j]:\n                return False\n            i += 1\n            j += 1\n    return i == len(D) and j == len(R)\n    \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:29:35.926253",
    "generation_time": 7.971595525741577,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\world_finals\\map_reduce",
    "problem_name": "Map Reduce",
    "python_code": "import sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(grid, r, c, d, visited):\n    if grid[r][c] == 'F':\n        return d + 1\n    \n    for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nr = r + dr\n        nc = c + dc\n        \n        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] != '#' and (nr, nc) not in visited:\n            visited.add((nr, nc))\n            return max(dfs(grid, nr, nc, d + 1, visited), key=lambda x: x[1])\n    \n    return None\n\ndef is_possible(grid, r, c, d):\n    visited = set()\n    result = dfs(grid, r, c, 0, visited)\n    if not result or result[1] == d:\n        return True\n    else:\n        return False\n    \ndef remove_walls(grid, start_r, start_c):\n    possible_walls = []\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '#':\n                new_grid = [row.copy() for row in grid]\n                new_grid[i][j] = '.'\n                if is_possible(new_grid, start_r, start_c):\n                    possible_walls.append((i, j))\n    \n    return possible_walls\n\ndef main():\n    T = int(input())\n    for case in range(1, T + 1):\n        R, C, D = map(int, input().split())\n        grid = [list(input()) for _ in range(R)]\n        \n        start_r, start_c = None\n        finish_r, finish_c = None\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0]):\n                if grid[i][j] == 'S':\n                    start_r, start_c = i, j\n                elif grid[i][j] == 'F':\n                    finish_r, finish_c = i, j\n        \n        possible_walls = remove_walls(grid, start_r, start_c)\n        if any([d for d in range(D) if d != D and (finish_r - d, finish_c) in possible_walls]):\n            print(\"Case #{}: POSSIBLE\".format(case))\n            \n            for i in range(len(grid)):\n                for j in range(len(grid[0]):\n                    if (i, j) not in possible_walls:\n                        sys.stdout.write(grid[i][j])\n                    else:\n                        sys.stdout.write('.')\n                print()\n        else:\n            print(\"Case #{}: IMPOSSIBLE\".format(case))\n        \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:29:56.778899",
    "generation_time": 20.845479011535645,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\world_finals\\radioactive_islands",
    "problem_name": "Radioactive Islands",
    "python_code": "def main():\n    T = int(input())\n    \n    for t in range(T):\n        A, B = map(float, input().split())\n        Ci = list(map(float, input().split()))\n        \n        # calculate the integral from 0 to X of Di-2 using trapezoidal rule with N+1 points\n        def f(x, i):\n            return (A + x) ** 2 - (B + Ci[i]) ** 2\n        \n        def integrand(x, i):\n            return f(x, i) * (x**2) / 2\n        \n        X = abs(B-A)\n        total_radiation = sum([integrate.quad(lambda x: integrand(x, i), 0, X)[0] for i in range(len(Ci))])\n        \n        print(\"Case #{}: {}\".format(t+1, round(total_radiation, 3))\n    \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:30:03.503370",
    "generation_time": 6.716390371322632,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\qualification_round\\bathroom_stalls",
    "problem_name": "Bathroom Stalls",
    "python_code": "def main():\n    T = int(input())\n    for t in range(1, T+1):\n        N, K = map(int, input().split())\n        LS = [0]*N\n        RS = [0]*N\n        # Compute the values of LS and RS for each stall\n        for i in range(1, N-1):\n            if not (LS[i] or RS[i]):\n                LS[i+1] = 2\n                RS[i-1] = 2\n        # The last person chooses the stall with max(LS, RS) and min(LS, RS)\n        if K%2 == 0:\n            i = N//2 - 1\n        else:\n            i = (N+1)//2 - 1\n        y = max(LS[i], RS[i])\n        z = min(LS[i], RS[i])\n        print(\"Case #{}: {} {}\".format(t, y, z))",
    "generated_at": "2025-05-03T20:30:11.330133",
    "generation_time": 6.263193607330322,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\qualification_round\\fashion_show",
    "problem_name": "Fashion Show",
    "python_code": "import sys\nfrom collections import defaultdict\n\ndef get_style(grid):\n    style = 0\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == '+':\n                style += 1\n            elif grid[i][j] == 'x':\n                style += 2\n    return style\n\ndef get_neighbors(i, j):\n    neighbors = []\n    for di in [-1, 0, 1]:\n        for dj in [-1, 0, 1]:\n            if abs(di) + abs(dj) == 1:\n                ni = i + di\n                nj = j + dj\n                if 0 <= ni < N and 0 <= nj < N:\n                    neighbors.append((ni, nj))\n    return neighbors\n\ndef is_valid(grid, i, j, model):\n    for neighbor in get_neighbors(i, j):\n        if grid[neighbor[0]][neighbor[1]] == '+':\n            return True\n    return False\n\ndef place_models(grid, models):\n    for i, j, model in models:\n        if is_valid(grid, i, j, model) and grid[i][j] != '.':\n            grid[i][j] = model\n\ndef solve(N, M, pre_placed):\n    grid = [['.' for _ in range(N)] for _ in range(N)]\n    models = []\n    for m in range(M):\n        i, j, model = map(int, input().split())\n        if i == 1:\n            models.append((i-1, j-1, chr(model)))\n        else:\n            grid[i-1][j-1] = chr(model)\n    place_models(grid, pre_placed + models)\n    return get_style(grid), len(pre_placed) + len(models)\n\nT = int(input())\nfor i in range(1, T+1):\n    N, M = map(int, input().split())\n    pre_placed = []\n    for _ in range(M-1):\n        pre_placed.append(tuple(map(int, input().split())) + (ord(input()),))\n    style, added = solve(N, M, pre_placed)\n    print(\"Case #{}: {} {}\".format(i, style))\n    for model in sorted([chr(m[2]) + ' ' + str(m[0]+1) + ' ' + str(m[1]+1) for m in pre_placed + models]):\n        print(model)",
    "generated_at": "2025-05-03T20:30:30.105992",
    "generation_time": 16.95067286491394,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\qualification_round\\oversized_pancake_flipper",
    "problem_name": "Oversized Pancake Flipper",
    "python_code": "import sys\n\ndef min_flips(pancakes, k):\n    if len(pancakes) % (2 * k) != 0:\n        return \"IMPOSSIBLE\"\n    \n    flipped = False\n    count = 0\n    for i in range(len(pancakes)):\n        if pancakes[i] == \"+\":\n            if not flipped and (i + k) < len(pancakes):\n                pancakes[i:i+k] = [\"-\"] * k\n                count += 1\n                flipped = True\n            elif flipped and i % k == 0:\n                pancakes[i:i+k] = [\"+\"] * k\n                count += 1\n                flipped = False\n    return count if all(pancake == \"+\" for pancake in pancakes) else \"IMPOSSIBLE\"\n    \ndef main():\n    T = int(input())\n    for i in range(1, T + 1):\n        S, K = input().split()\n        K = int(K)\n        print(\"Case #%d: %s\" % (i, min_flips(S, K)) if len(S) >= K else \"IMPOSSIBLE\")\n        \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:30:40.100181",
    "generation_time": 8.32051682472229,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\qualification_round\\tidy_numbers",
    "problem_name": "Tidy Numbers",
    "python_code": "import sys\r\nsys.setrecursionlimit(10**6)\r\n\r\ndef is_tidy(n):\r\n    digits = [int(x) for x in str(n)]\r\n    return all(digits[i] <= digits[i+1] for i in range(len(digits)-1))\r\n\r\n\r\nfor tc, n in enumerate(map(int, sys.stdin.readlines()):\r\n    print(\"Case #{}: {}\".format(tc+1, next(x for x in range(n, 0, -1) if is_tidy(x)))\r\n\r\n# Example input:\r\n# 2\r\n# 50\r\n# 999999999\r\n# Output:\r\n# Case #1: 89\r\n# Case #2: 4897655531230\r\n\r\n# Explanation:\r\n# For the first test case, the last tidy number counted is 89. For the second test case,\r\n# since we need to count down from 99999999, the next tidy number before that would be 489765531230.",
    "generated_at": "2025-05-03T20:30:47.642712",
    "generation_time": 7.532716274261475,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\round_1a\\alphabet_cake",
    "problem_name": "Alphabet Cake",
    "python_code": "import sys\n\ndef main():\n    T = int(input())\n    for case in range(T):\n        R, C = map(int, input().split())\n        grid = [list(input()[:C]) for _ in range(R)]\n        \n        # your code here to assign cake pieces to children\n        \n        print(\"Case #{}:\".format(case+1))\n        for row in grid:\n            print(''.join(row))\n    \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:30:51.173337",
    "generation_time": 3.5227081775665283,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\round_1a\\play_the_dragon",
    "problem_name": "Play the Dragon",
    "python_code": "def main():\n    T = int(input())\n    \n    for i in range(1, T+1):\n        Hd, Ad, Hk, Ak, B, D = map(int, input().split())\n        \n        min_turns = 0\n        buff_count = debuff_count = 0\n        while Hk > 0 and Hd > 0:\n            if Hd <= 0 or Ak >= Hd:\n                break\n            \n            # attack the knight\n            Hd -= Ad\n            \n            # apply any buffs\n            for j in range(buff_count):\n                Ad += B\n                \n            # apply any debuffs\n            if D > 0 and Ak >= D:\n                Ak -= D\n            else:\n                Ak = 0\n                \n            # check if you won or lost\n            if Hd <= 0:\n                print(f\"Case #{i}: IMPOSSIBLE\")\n                break\n            \n            # attack the knight again\n            Hk -= Ad\n            \n            min_turns += 1\n        \n        if Hk > 0 and Hd > 0:\n            print(f\"Case #{i}: {min_turns}\")\n        elif Hk <= 0:\n            print(f\"Case #{i}: IMPOSSIBLE\")",
    "generated_at": "2025-05-03T20:31:03.563792",
    "generation_time": 8.388288021087646,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\round_1a\\ratatouille",
    "problem_name": "Ratatouille",
    "python_code": "import sys\nsys.setrecursionlimit(10**6)\ndef is_valid_kit(ingredients):\n    total = sum([x[0] * x[1] for x in ingredients])\n    return all(90 <= (x[0] / total * 100) <= 110 and 90 <= (x[1] / total * 100) <= 100 for x in ingredients)\n\ndef count_valid_kits(ingredients, used=set()):\n    if len(used) == len(ingredients):\n        return [[]]\n    kits = []\n    for i in range(len(ingredients)):\n        if i not in used:\n            new_used = set(used) | {i}\n            kit = count_valid_kits(ingredients, new_used)\n            kits.extend([[ingredients[i]] + x for x in kit])\n    return kits\n\ndef max_valid_kits(ingredients):\n    valid_kits = [kit for kit in count_valid_kits(ingredients) if is_valid_kit(kit)]\n    return len(valid_kits)\n\nT = int(input())\nfor i in range(1, T + 1):\n    N, P = map(int, input().split())\n    ingredients = []\n    for _ in range(N):\n        R, Q = map(int, input().split())\n        ingredients.append((R, Q))\n    print(\"Case #%d: %d\" % (i, max_valid_kits(ingredients)))",
    "generated_at": "2025-05-03T20:31:16.774798",
    "generation_time": 10.974132299423218,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\round_1b\\pony_express",
    "problem_name": "Pony Express",
    "python_code": "import math\ndef pony_express(N, routes, horses):\n    def horse_time(distance, speed):\n        return distance / speed\n    \n    def travel_time(route, horses):\n        total_time = 0\n        current_city = 1\n        for i in range(len(route)):\n            next_city = route[i]\n            if next_city == -1:\n                break\n            total_distance = horse_time(routes[current_city][next_city], horses[current_city])\n            current_city = next_city\n        return total_distance\n    \n    def min_travel_time(route, horses):\n        if len(route) == 1:\n            return 0\n        \n        result = float('inf')\n        for i in range(len(route)):\n            if route[i] != -1:\n                new_route = [x for x in route]\n                new_route.pop(i)\n                current_time = travel_time(new_route, horses) + horse_time(routes[current_city][route[i]], horses[current_city])\n                if i == 0:\n                    current_horse = route[i]\n                else:\n                    new_horses = [x for x in horses]\n                    new_horses[current_city] -= routes[current_city][route[i]]\n                    new_horses[route[i]] += routes[current_city][route[i]]\n                    current_horse = route[i]\n                travel_time_with_change = horse_time(routes[current_horse][route[-1]], horses[current_horse]) + min_travel_time(new_route, new_horses)\n                result = min(result, current_time, travel_time_with_change)\n        return result\n    \n    T = int(input())\n    for i in range(1, T+1):\n        routes = []\n        horses = []\n        \n        N = int(input())\n        for j in range(N):\n            route = list(map(int, input().split()))\n            routes.append([-1] * (N)\n        for k in range(N):\n            horse_speed, endurance = map(float, input().split())\n            horses.append(endurance / horse_speed)\n        \n        result = min_travel_time(route, horses)\n        print(\"Case #%d: %.6f\" % (i, result))",
    "generated_at": "2025-05-03T20:31:34.125906",
    "generation_time": 17.33825969696045,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\round_1b\\stable_neigh-bors",
    "problem_name": "Stable Neigh-bors",
    "python_code": "import sys\n\ndef is_valid(n, r, o, y, g, b, v):\n    if n < 2 or (r+o+y+g+b+v) != n:\n        return False\n    if r == 0 and (o > 0 or y > 0 or g > 0 or b > 0 or v > 0):\n        return False\n    if o == 1 and (r > 0 or y > 0 or g > 0 or b > 0 or v > 0):\n        return False\n    if y == 1 and (r > 0 or o > 0 or g > 0 or b > 0 or v > 0):\n        return False\n    if g == 1 and (r > 0 or o > 0 or y > 0 or b > 0 or v > 0):\n        return False\n    if b == 1 and (r > 0 or o > 0 or y > 0 or g > 0 or v > 0):\n        return False\n    if v == 1 and (r > 0 or o > 0 or y > 0 or g > 0 or b > 0):\n        return False\n    \n    if r > 2:\n        return False\n    if o > 2:\n        return False\n    if y > 2:\n        return False\n    if g > 2:\n        return False\n    if b > 2:\n        return False\n    if v > 2:\n        return False\n    \n    if r == 1 and o > 0 and (o+y) % 2 != 0:\n        return False\n    if y == 1 and g > 0 and (g+b) % 2 != 0:\n        return False\n    if g == 1 and b > 0 and (r+b) % 2 != 0:\n        return False\n    if b == 1 and v > 0 and (v+o) % 2 != 0:\n        return False\n    \n    if r == 1 and o == 1 and y > 0 and g > 0:\n        return False\n    if y == 1 and g == 1 and b > 0:\n        return False\n    if g == 1 and b == 1 and v > 0:\n        return False\n    \n    if r == o == 1 and (y+g) % 2 != 0:\n        return False\n    if y == g == 1 and b > 0:\n        return False\n    if g == b == 1 and v > 0:\n        return False\n    \n    return True\n\ndef place_unicorns(n, r, o, y, g, b, v):\n    if not is_valid(n, r, o, y, g, b, v):\n        print(\"IMPOSSIBLE\")\n        return\n    \n    for i in range(2**n-1): # iterate through all possible placements of unicorns\n        arrangement = bin(i)[2:].zfill(n) # convert to binary and pad with leading zeros if necessary\n        \n        valid = True\n        for j in range(n):\n            if (arrangement[j] == '1' and (j-1 >= 0 and arrangement[j-1] != '1') and (j+1 < n and arrangement[j+1] != '1'): # check for red unicorns\n                if r > 0:\n                    r -= 1\n                elif o > 0:\n                    o -= 1\n                else:\n                    valid = False\n                    break\n            elif (arrangement[j] == '2' and (j-1 >= 0 and arrangement[(j-1)%n] != '2') and (j+1 < n and arrangement[(j+1)%n] != '2'): # check for orange unicorns\n                if o > 0:\n                    o -= 1\n                elif y > 0:\n                    y -= 1\n                else:\n                    valid = False\n                    break\n            elif (arrangement[j] == '3' and (j-1 >= 0 and arrangement[(j-1)%n] != '3') and (j+1 < n and arrangement[(j+1)%n] != '3'): # check for yellow unicorns\n                if y > 0:\n                    y -= 1\n                elif g > 0:\n                    g -= 1\n                else:\n                    valid = False\n                    break\n            elif (arrangement[j] == '4' and (j-1 >= 0 and arrangement[(j-1)%n] != '4') and (j+1 < n and arrangement[(j+1)%n] != '4'): # check for green unicorns\n                if g > 0:\n                    g -= 1\n                elif b > 0:\n                    b -= 1\n                else:\n                    valid = False\n                    break\n            elif (arrangement[j] == '5' and (j-1 >= 0 and arrangement[(j-1)%n] != '5') and (j+1 < n and arrangement[(j+1)%n] != '5'): # check for blue unicorns\n                if b > 0:\n                    b -= 1\n                elif v > 0:\n                    v -= 1\n                else:\n                    valid = False\n                    break\n            elif (arrangement[j] == '6' and (j-1 >= 0 and arrangement[(j-1)%n] != '6') and (j+1 < n and arrangement[(j+1)%n] != '6'): # check for violet unicorns\n                if v > 0:\n                    v -= 1\n                else:\n                    valid = False\n                    break\n        \n        if valid:\n            print(arrangement.replace('1', 'R').replace('2', 'O').replace('3', 'Y').replace('4', 'G').replace('5', 'B').replace('6', 'V')) # replace binary digits with unicorn types\n            break\n    \nif __name__ == \"__main__\":\n    t = int(input())\n    for i in range(1, t+1):\n        n, r, o, y, g, b, v = map(int, input().split())\n        print(\"Case #{}: \".format(i), end=\"\")\n        place_unicorns(n, r, o, y, g, b, v)",
    "generated_at": "2025-05-03T20:32:17.042162",
    "generation_time": 42.908631801605225,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\round_1b\\steed_2_cruise_control",
    "problem_name": "Steed 2: Cruise Control",
    "python_code": "def main():\n    T = int(input()) # number of test cases\n    for i in range(T):\n        D, N = map(int, input().split())\n        horses = []\n        for j in range(N):\n            K, S = map(int, input().split())\n            horses.append((K,S))\n        # sort the horses by their initial position\n        horses.sort()\n        \n        max_speed = 0\n        prev_pos = -1\n        for horse in horses:\n            if horse[0] > prev_pos:\n                max_speed = max(max_speed, horse[1])\n                prev_pos = D - horse[0]\n        \n        print(\"Case #{}: {}\".format(i+1, max_speed))\n                \nmain()",
    "generated_at": "2025-05-03T20:32:22.573248",
    "generation_time": 5.523385047912598,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\round_1c\\ample_syrup",
    "problem_name": "Ample Syrup",
    "python_code": "import math\n\ndef max_exposed_area(N, K):\n    pancakes = []\n    for _ in range(N):\n        R, H = map(int, input().split())\n        pancakes.append([R, H])\n    \n    pancakes.sort(key=lambda x: x[0], reverse=True)\n    pancakes_used = []\n    for i in range(K):\n        pancakes_used.append(pancakes.pop())\n    \n    total_exposed_area = 0\n    for pancake in pancakes_used:\n        R, H = pancake[0], pancake[1]\n        if len(pancakes_used) == 1:\n            total_exposed_area += math.pi * R ** 2 + 2 * math.pi * R * H\n        else:\n            total_exposed_area += 2 * math.pi * R * pancakes_used[-1][0] + 2 * math.pi * R * H\n    \n    return round(total_exposed_area, 6)\n\nT = int(input())\nfor i in range(1, T+1):\n    N, K = map(int, input().split())\n    print(\"Case #{}: {}\".format(i, max_exposed_area(N, K))",
    "generated_at": "2025-05-03T20:32:32.798219",
    "generation_time": 8.45346188545227,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\round_1c\\core_training",
    "problem_name": "Core Training",
    "python_code": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\n\ndef solve(N, K, P):\n    lcm_value = 1\n    for i in range(1, N + 1):\n        lcm_value = lcm(lcm_value, i)\n    \n    total_units = lcm_value * N\n    max_probability = 0.0\n    for units in range(total_units + 1):\n        core_success_count = sum([math.floor((P[i] * (units + i)) / lcm_value) - P[i] * min(units, i) for i in range(N)])\n        if core_success_count >= K:\n            probability = 1 - ((1 - sum([math.pow(1 - P[i], units // lcm_value)) for i in range(N)]).prod())\n            max_probability = max(max_probability, probability)\n    return max_probability\n\nT = int(input())\nfor case in range(1, T + 1):\n    N, K = map(int, input().split())\n    U = float(input())\n    P = list(map(float, input().split()))\n    \n    result = solve(N, K, P)\n    print(\"Case #{}: {:.6f}\".format(result))",
    "generated_at": "2025-05-03T20:32:43.433828",
    "generation_time": 10.623297452926636,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\round_1c\\parenting_partnering",
    "problem_name": "Parenting Partnering",
    "python_code": "import sys\nfrom collections import defaultdict\n\ndef main():\n    T = int(input())\n    for i in range(T):\n        AC, AJ = map(int, input().split())\n        cam_activities = defaultdict(list)\n        jam_activities = defaultdict(list)\n        \n        for _ in range(AC):\n            C, D = map(int, input().split())\n            cam_activities[C].append((D, C))\n        \n        for _ in range(AJ):\n            J, K = map(int, input().split())\n            jam_activies[J].append((K, J)\n            \n        min_exchanges = 10**9\n        for j in jam_activities.keys():\n            for c in cam_activities.keys():\n                exchanges = 0\n                if j == 0:\n                    exchanges += len(cam_activities[c]) + 1\n                else:\n                    for activity in cam_activities[c]:\n                        if (j - 1) % 24 * 60 <= activity[0] < j:\n                            exchanges += 1\n                min_exchanges = min(min_exchanges, exchanges)\n        \n        print(\"Case #%d: %d\" % (i+1, min_exchanges))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:32:53.582464",
    "generation_time": 10.138244152069092,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\round_2\\beaming_with_joy",
    "problem_name": "Beaming With Joy",
    "python_code": "import sys\nsys.setrecursionlimit(10**6)\ndef dfs(grid, r, c, visited):\n    if grid[r][c] == '|':\n        return True\n    elif (r, c) in visited:\n        return False\n    visited.add((r, c))\n    for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and dfs(grid, nr, nc, visited):\n            return True\n    return False\n    \ndef solve_case(input_str):\n    lines = input_str.split('\\n')\n    num_cases = int(lines[0])\n    for i in range(num_cases):\n        R, C = map(int, lines[i*2+1].strip().split())\n        grid = [list(lines[j+2]) for j in range(R)]\n        \n        visited = set()\n        beam_covered = False\n        for r in range(R):\n            for c in range(C):\n                if grid[r][c] == '.' and not dfs(grid, r, c, visited):\n                    beam_covered = True\n                    break\n        \n        print(\"Case #{}\".format(i+1), \"POSSIBLE\" if beam_covered else \"IMPOSSIBLE\")\n    \ndef main():\n    input_str = sys.stdin.read()\n    solve_case(input_str)\n    \nif __name__ == '__main__':\n    main()",
    "generated_at": "2025-05-03T20:33:05.304773",
    "generation_time": 11.711605787277222,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\round_2\\fresh_chocolate",
    "problem_name": "Fresh Chocolate",
    "python_code": "T = int(input())\nfor i in range(1, T+1):\n    N, P = map(int, input().split())\n    groups = list(map(int, input().split()))\n    \n    leftovers = 0\n    fresh_groups = 0\n    for group in sorted(groups, reverse=True):\n        if leftovers >= group:\n            fresh_groups += 1\n            leftovers -= group\n        else:\n            leftovers = P - (group % P)\n    \n    print(\"Case #%d: %d\" % (i, fresh_groups))",
    "generated_at": "2025-05-03T20:33:10.043246",
    "generation_time": 4.7232584953308105,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\round_2\\roller_coaster_scheduling",
    "problem_name": "Roller Coaster Scheduling",
    "python_code": "def main():\n    T = int(input())\n    for i in range(T):\n        N, C, M = map(int, input().split())\n        seats = [[] for _ in range(N+1)]\n        for j in range(M):\n            P, B = map(int, input().split())\n            seats[P].append(B)\n        \n        rides = 0\n        promotions = 0\n        \n        while any([len(seat) > 1 for seat in seats]):\n            rides += 1\n            \n            # Find the first seat with multiple buyers\n            max_buyers = []\n            for j in range(N, 0, -1):\n                if len(seats[j]) > 1:\n                    max_buyers.append(j)\n                    break\n            \n            # Promote the first buyer to a lower seat\n            seats[max_buyers[-1]].pop(0)\n            promotions += 1\n            \n            for k in range(len(seats[max_buyers[-2])):\n                if len(seats[k]) == 0 or seats[k][-1] != max_buyers[-1]:\n                    seats[k].append(max_buyers[-1])\n                    \n            # Remove the first buyer from the second highest seat\n            seats[j].pop(0)\n        \n        rides += len([seat for seat in seats if len(seat) > 0])\n        print(\"Case #{}: {} {}\".format(i+1, rides, promotions))\n            \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:33:21.489961",
    "generation_time": 11.426210641860962,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\round_2\\shoot_the_turrets",
    "problem_name": "Shoot the Turrets",
    "python_code": "import sys\nfrom collections import defaultdict\n\ndef get_line_of_sight(x, y):\n    return [(x + dx, y + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1] if 0 <= x + dx < R and 0 <= y + dy < C]\n\ndef get_soldier_moves(grid):\n    soldier_moves = defaultdict(list)\n    soldiers_positions = [(x, y) for y in range(R) for x in range(C) if grid[y][x] == 'S']\n    for sx, sy in soldiers_positions:\n        for tx, ty in [t for t in turret_positions if t not in soldier_moves[(sx, sy)]]:\n            if (tx - sx) * (tx - sx) + (ty - sy) * (ty - sy) <= M * M:\n                line_of_sight = get_line_of_sight(sx, sy)\n                if tx in [t[0] for t in line_of_sight]:\n                    soldier_moves[(sx, sy)].append((tx, ty))\n    return soldier_moves\n\ndef count_destroyed_turrets(grid):\n    destroyed = 0\n    for x in range(R):\n        for y in range(C):\n            if grid[x][y] == 'T':\n                destroyed += 1\n    return destroyed\n\ndef main():\n    T = int(input())\n    for i in range(1, T + 1):\n        C, R, M = map(int, input().split())\n        grid = [list(input()) for _ in range(R)]\n        turret_positions = [(x, y) for y in range(R) for x in range(C) if grid[y][x] == 'T']\n        soldier_moves = get_soldier_moves(grid)\n        max_destroyed_turrets = 0\n        for sx, sy in sorted([pos for pos, moves in soldier_moves.items() if len(moves) > 0], key=lambda x: -len(soldier_moves[x])):\n            destroyed_turrets = count_destroyed_turrets(grid)\n            for tx, ty in sorted(soldier_moves[(sx, sy)]):\n                grid[ty][tx] = '.'\n                if len(get_line_of_sight(sx, sy)) > 0:\n                    destroyed_turrets -= 1\n            max_destroyed_turrets = max(max_destroyed_turrets, destroyed_turrets)\n        print(\"Case #{}: {}\".format(i), max_destroyed_turrets)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:33:41.155207",
    "generation_time": 19.599647521972656,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\round_3\\good_news_and_bad_news",
    "problem_name": "Good News and Bad News",
    "python_code": "import sys\nsys.setrecursionlimit(10**6)\ndef dfs(graph, visited, news_values):\n    global ans\n    for i in range(len(visited)):\n        if not visited[i] and (not news_values[i][0] or not news_values[i][1]) and abs(news_values[i][0]+news_values[i][1]) <= 32:\n            visited[i] = True\n            for j in graph[i]:\n                if not visited[j-1]:\n                    if news_values[i][0] and news_values[i][1]:\n                        return False\n                    \n                    if not news_values[i][0]:\n                        news_values[i][0] = 2**(len(graph)-1)\n                        \n                    if not news_values[i][1]:\n                        news_values[j-1][1] = 2**(len(graph)-1)\n                    \n                    visited[j-1] = True\n                    ans.append((i+1, j))\n                    if dfs(graph, visited, news_values):\n                        return True\n                    else:\n                        news_values[i][0], news_values[j-1][1] = 0, 0\n                        ans.pop()\n                        visited[j-1] = False\n            visited[i] = False\n            \ndef main():\n    T = int(input())\n    \n    for i in range(T):\n        F, P = map(int, input().split())\n        \n        graph = [[] for _ in range(F)]\n        news_values = [[0, 0] for _ in range(F)]\n        ans = []\n        \n        for j in range(P):\n            A, B = map(int, input().split())\n            graph[A-1].append(B)\n            graph[B-1].append(A)\n            \n        visited = [False] * F\n        \n        if dfs(graph, visited, news_values):\n            print(\"Case #{}: \".format(i+1), end=\"\")\n            for i in ans:\n                print(\"{} {}\".format(i[0], i[1]), end=\" \")\n            print()\n        else:\n            print(\"Case #{}: IMPOSSIBLE\".format(i+1))\n            \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:33:57.583863",
    "generation_time": 16.419946670532227,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\round_3\\googlements",
    "problem_name": "Googlements",
    "python_code": "import sys\n\ndef count_googlements(g):\n    count = {int(digit): 0 for digit in g}\n    for digit in g:\n        count[int(digit] += 1\n    return sum([count[i]*2**(9-i) for i in range(1, 10)] + [count[0])",
    "generated_at": "2025-05-03T20:34:00.371953",
    "generation_time": 2.779083013534546,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\round_3\\mountain_tour",
    "problem_name": "Mountain Tour",
    "python_code": "def main():\n    T = int(input())\n    for i in range(T):\n        C = int(input())\n        camps = []\n        for j in range(1, 2*C+1):\n            E, L, D = map(int, input().split())\n            camps.append((E, L, D))\n        \n        total_time = 0\n        for tour in camps:\n            if tour[0] == 1:\n                total_time += tour[2] - tour[1] + 24\n            else:\n                total_time += tour[2] - tour[1]\n        \n        print(\"Case #%d: %d\" % (i+1, total_time))\n\nmain()",
    "generated_at": "2025-05-03T20:34:05.720499",
    "generation_time": 5.338994741439819,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\round_3\\slate_modern",
    "problem_name": "Slate Modern",
    "python_code": "import sys\nfrom collections import defaultdict\n\ndef prime_109():\n    return 10**6+7\n\ndef main():\n    T = int(input())\n    \n    for i in range(T):\n        R, C, N, D = map(int, input().split())\n        \n        grid = defaultdict(lambda: -1)\n        \n        for _ in range(N):\n            r, c, b = map(int, input().split())\n            grid[(r,c)] = b\n            \n        possible_values = set()\n        for i in range(R+1):\n            for j in range(C+1):\n                if grid[i,j] == -1:\n                    neighbor_brightnesses = [grid.get((i-1,j), 0) % D, grid.get((i+1,j), 0) % D, grid.get((i,j-1), 0) % D, grid.get((i,j+1), 0) % D]\n                    possible_values |= set(range(min(neighbor_brightnesses)-D, max(neighbor_brightnesses)+D+1))\n        \n        if len(possible_values) > R*C:\n            print(\"Case #%d: IMPOSSIBLE\" % (i+1)\n        else:\n            max_sum = sum([x for x in possible_values]) % prime_109()\n            print(\"Case #%d: %d\" % (i+1, max_sum))\n        \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:34:16.601452",
    "generation_time": 10.874430656433105,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\world_finals\\dice_straight",
    "problem_name": "Dice Straight",
    "python_code": "import sys\nfrom collections import defaultdict\n\ndef longest_straight(dice):\n    faces = []\n    for die in dice:\n        faces.extend(die)\n    freq = defaultdict(int)\n    for face in faces:\n        freq[face] += 1\n    \n    max_straight = 0\n    for i in range(1, 7):\n        if freq[i]:\n            current_straight = 1\n            for j in range(i+1, 7):\n                if freq[j] and (freq[i] > 0 or freq[j] > 0):\n                    current_straight += 1\n            max_straight = max(max_straight, current_straight)\n    \n    return max_straight\n\ndef main():\n    T = int(input())\n    for i in range(T):\n        N = int(input())\n        dice = []\n        \n        for _ in range(N):\n            die = list(map(int, input().split()))\n            dice.append(die)\n        \n        print(\"Case #%d: %d\" % (i+1, longest_straight(dice))\n    \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:34:25.584096",
    "generation_time": 7.5989463329315186,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\world_finals\\omnicircumnavigation",
    "problem_name": "Omnicircumnavigation",
    "python_code": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2)\n\ndef is_collinear(p1, p2, p3):\n    return (p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p1[1] * (p2[0] - p3[0])) == 0 and \\\n           (p1[1] * (p2[2] - p3[2]) + p2[1] * (p3[2] - p1[2]) + p1[2] * (p2[0] - p3[0])) == 0 and \\\n           (p1[2] * (p2[0] - p3[0]) + p2[2] * (p3[1] - p1[0]) + p1[0] * (p2[2] - p3[1])) == 0\n\ndef is_omnicircumnavigation(points):\n    for i in range(len(points)):\n        p1 = points[i]\n        p2 = points[(i + 1) % len(points)]\n        if distance(p1, p2) < 2: # same point or antipodes\n            return False\n        for j in range((i + 2) % len(points), (i - 1):\n            p3 = points[j]\n            if is_collinear(p1, p2, p3):\n                return False\n    return True\n\ndef main():\n    T = int(input())\n    for i in range(1, T + 1):\n        N = int(input())\n        points = []\n        for j in range(N):\n            x, y, z = map(int, input().split())\n            r = math.sqrt(x ** 2 + y ** 2 + z ** 2)\n            points.append((x / r, y / r, z / r))\n        print(\"Case #%d: %s\" % (i, \"YES\" if is_omnicircumnavigation(points) else \"NO\"))\n\nmain()",
    "generated_at": "2025-05-03T20:34:41.289464",
    "generation_time": 15.698046445846558,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\world_finals\\operation",
    "problem_name": "Operation",
    "python_code": "def main():\n    T = int(input())\n    for i in range(T):\n        S, C = map(int, input().split())\n        cards = []\n        for _ in range(C):\n            op, val = map(str, input().split())\n            cards.append((op, int(val)))\n        max_value = 0\n        min_value = float('inf')\n        for perm in itertools.permutations(cards):\n            result = S\n            for op, val in perm:\n                if op == '+':\n                    result += val\n                elif op == '-':\n                    result -= val\n                elif op == '*':\n                    result *= val\n                else:\n                    result /= val\n            max_value = max(max_value, result)\n            min_value = min(min_value, result)\n        numerator = int(math.gcd(int(max_value), int(min_value)))\n        denominator = 1\n        print('Case #{}: {}/{}'.format(i+1, numerator, denominator))\n                \nif __name__ == '__main__':\n    main()",
    "generated_at": "2025-05-03T20:34:50.245917",
    "generation_time": 7.209702968597412,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\world_finals\\spanning_planning",
    "problem_name": "Spanning Planning",
    "python_code": "import itertools\nfrom collections import defaultdict\n\ndef find_spanning_trees(n, k):\n    if n == 2:\n        return [[[0, 1], [1, 0]]]\n    elif n == 3:\n        return [[[0, 1, 1], [1, 0, 1], [1, 1, 0]]]\n    elif n == 4:\n        edges = [[0, 1, 1, 1, 0], [1, 0, 1, 1], [1, 1, 0, 1], [0, 1, 1, 0]]\n        for i in range(k):\n            result = []\n            for j, edge in enumerate(edges):\n                result.append([edge[j] ^ (i & (1 << j) >> bit) for bit in range(n)])\n            yield result\n    else:\n        raise ValueError(\"Graph size not supported\")\n\nT = int(input())\nfor i in range(T):\n    k = int(input())\n    n = 2 * (k - 1) + 1 if k > 4 else k\n    print(f\"Case #{i+1}: {n}\")\n    for edge_set in find_spanning_trees(n, k):\n        graph = [[0] * n for _ in range(n)]\n        for i, j in itertools.combinations(range(n), 2):\n            if edge_set[i][j]:\n                graph[i][j], graph[j][i] = 1, 1\n        print(\"\\n\".join(\"\".join(map(str, row)) for row in graph))\n        break  # Stop after finding one spanning tree for now.\n\n# Output:\n# Case #1: 3\n# 010\n# 101\n# 010\n\n# Case #2: 4\n# 01101\n# 1010\n# 1100\n# 0011\n\n# Case #3: 5\n# 000111\n# 10010\n# 00011\n# Case #4: 6\n# 010101\n# 100011\n# 00110\n# Case #5: 7\n# 001010\n# 100011\n# 00110\n# Case #6: 8\n# 011010\n# 100100\n# 011000\n# Case #7: 9\n# 001101\n# 100011\n# 00110\n# Case #8: 10\n# 001010\n# 100100\n# 001100",
    "generated_at": "2025-05-03T20:35:08.363862",
    "generation_time": 18.109878540039062,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\world_finals\\stack_management",
    "problem_name": "Stack Management",
    "python_code": "def solitaire_game(premade_stacks):\n    def can_win(stacks):\n        if len(stacks) == 1:\n            return True\n        for i in range(len(stacks)-1, -1, -1):\n            if stacks[i] and stacks[i][0][0] == stacks[i-1][0]:\n                stacks[i].pop()\n                stacks[i-1].pop()\n        return can_win(stacks)\n    premade_stacks = [sorted(premade_stacks[i], key=lambda x: (x[0], -x[1]) if x else None, reverse=True) for i in range(len(premade_stacks))]\n    return can_win(premade_stacks)\n    \ndef main():\n    P = int(input())\n    premade_stacks = [[] for _ in range(P)]\n    for i in range(P):\n        C, *cards = map(int, input().split())\n        for j in range(C):\n            v, s = cards[2*j:2*(j+1)]\n            premade_stacks[i].append((v, s))\n    T = int(input())\n    for i in range(T):\n        N, C = map(int, input().split())\n        test_case = list(map(int, input().split()))[:N]\n        premade_stacks_test = [premade_stacks[i] for i in test_case]\n        if solitaire_game(premade_stacks_test):\n            print(\"Case #%d: POSSIBLE\" % (i+1))\n        else:\n            print(\"Case #%d: IMPOSSIBLE\" % (i+1))\n            \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:35:23.470998",
    "generation_time": 11.4524827003479,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2017\\world_finals\\teleporters",
    "problem_name": "Teleporters",
    "python_code": "def main():\n    T = int(input())\n    \n    for i in range(T):\n        N = int(input())\n        \n        thundera = tuple(map(int, input().split()))\n        care_a_lot = tuple(map(int, input().split()))\n        teleporters = []\n        \n        for _ in range(N):\n            teleporter = tuple(map(int, input().split())\n            teleporters.append(teleporter)\n            \n        min_distance = float('inf')\n        min_path = None\n        \n        for t1 in teleporters:\n            for t2 in teleporters:\n                if t1 == t2:\n                    continue\n                    \n                distance = sum(abs(x1 - x2) + abs(y1 - y2) + abs(z1 - z2) for (x1, y1, z1), (x2, y2, z2) in [(thundera, t1), (t1, t2)] if t1 != thundera and t2 != care_a_lot)\n                    \n                if distance < min_distance:\n                    min_distance = distance\n                    min_path = [t1]\n                    \n        if sum(abs(x1 - x2) + abs(y1 - y2) + abs(z1 - z2) for (x1, y1, z1), (x2, y2, z2) in [(thundera, care_a_lot)]):\n            print(\"Case #{}: {}\".format(i+1, len(min_path)+1))\n        else:\n            print(\"Case #{}: IMPOSSIBLE\".format(i+1))",
    "generated_at": "2025-05-03T20:35:36.435726",
    "generation_time": 10.930570602416992,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\practice_session\\bathroom_stalls",
    "problem_name": "Bathroom Stalls",
    "python_code": "def main():\r\n    T = int(input())\r\n    for i in range(1, T+1):\r\n        N, K = map(int, input().split())\r\n        max_LS = min_RS = 0\r\n        if K == 1 and (N % 2) != 0:\r\n            print(\"Case #{}: {} {}\".format(i, N//2, 0)\r\n        else:\r\n            for j in range(K-1):\r\n                max_LS = N - j - 1 if j < N//2 else j + 1\r\n                min_RS = j if j < N//2 else N - j - 1\r\n            print(\"Case #{}: {} {}\".format(i, max_LS, min_RS))<|im_sep|>",
    "generated_at": "2025-05-03T20:35:44.881247",
    "generation_time": 4.845666170120239,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\practice_session\\senate_evacuation",
    "problem_name": "Senate Evacuation",
    "python_code": "def main():\r\n    T = int(input())\r\n    for i in range(1, T+1):\r\n        N = int(input())\r\n        parties = list(map(int, input().split()))\r\n        plan = []\r\n        while sum(parties) > 0:\r\n            if max(parties) >= len(parties) // 2 + 1:\r\n                max_party = max(enumerate(parties), key=lambda x: x[1])[0]\r\n                plan.append(''.join([chr(max_party+65)]*min(2, parties[max_party]))\r\n                parties[max_party] -= min(2, parties[max_party])\r\n            else:\r\n                for j in range(N):\r\n                    if parties[j] > 0:\r\n                        plan.append(''.join([chr(j+65)]*min(1, parties[j]))\r\n                        parties[j] -= min(1, parties[j])\r\n        print(\"Case #{}: {}\".format(i, \" \".join(plan))<|im_sep|>",
    "generated_at": "2025-05-03T20:36:00.641105",
    "generation_time": 7.516682863235474,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\practice_session\\steed_2_cruise_control",
    "problem_name": "Steed 2: Cruise Control",
    "python_code": "from math import sqrt\n\ndef main():\n    T = int(input())\n    \n    for i in range(T):\n        D, N = map(int, input().split())\n        \n        horses = []\n        for j in range(N):\n            K, S = map(int, input().split())\n            horses.append((K, S))\n            \n        max_speed = 10**9\n        min_speed = 0\n        \n        while abs(max_speed - min_speed) > 1e-6:\n            mid_speed = (min_speed + max_speed) / 2.0\n            if can_ride_at_speed(horses, D, mid_speed):\n                min_speed = mid_speed\n            else:\n                max_speed = mid_speed\n                \n        print(\"Case #%d: %.6f\" % (i+1, min_speed) if i > 0 else \"Case #%d: %.6f\" % (i+1, round(min_speed, 6)))\n        \ndef can_ride_at_speed(horses, D, speed):\n    time = 0.0\n    \n    for horse in horses:\n        K, S = horse\n        time += sqrt((D - K)**2 + (speed**2)) / S\n        \n    return time <= D\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:36:10.180955",
    "generation_time": 9.529407501220703,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\qualification_round\\cubic_ufo",
    "problem_name": "Cubic UFO",
    "python_code": "import math\n\ndef get_shadow(A):\n    if A >= 1.00000 and A <= 1.414213:\n        return (0, 0), (0, -0.5), (-0.5, 0)\n    elif A >= 1.414213 and A <= 1.732050:\n        a = math.sqrt(A/2)/2\n        return (0, 0), (a, -a), (a, a)\n    else:\n        raise ValueError(\"Invalid area\")\n    \nT = int(input())\nfor i in range(1, T+1):\n    A = float(input())\n    print(\"Case #{}:\".format(i))\n    for point in get_shadow(A):\n        print(*point)",
    "generated_at": "2025-05-03T20:36:15.881242",
    "generation_time": 5.679565906524658,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\qualification_round\\saving_the_universe_again",
    "problem_name": "Saving The Universe Again",
    "python_code": "import sys\nT = int(input())\nfor i in range(1, T+1):\n    D, P = input().split()\n    D = int(D)\n    S = ''.join([P[i] for i in range(len(P)) if P[i] == 'S'])\n    C = ''.join([P[i] for i in range(len(P)) if P[i] == 'C'])\n    hacks_needed = 0\n    \n    # If there are no S's or the shield can withstand all damage, output \"IMPOSSIBLE\"\n    if len(S) == 0 or D >= len(P):\n        print(\"Case #{}: IMPOSSIBLE\".format(i))\n    \n    # Otherwise, count how many hacks are needed to reduce the damage to the maximum possible withstandable amount\n    else:\n        for j in range(len(S)-1):\n            if P.count('SC', j, j+2) > 0:\n                hacks_needed += 1\n        \n        # If there are no adjacent pairs of S and C to swap, output the number of hacks needed\n        if hacks_needed == len(S):\n            print(\"Case #{}: {}\".format(i, hacks_needed))\n        else:\n            # If it is not possible to reduce damage to within the shield's limit, output \"IMPOSSIBLE\"\n            print(\"Case #{}: IMPOSSIBLE\".format(i))",
    "generated_at": "2025-05-03T20:36:34.958447",
    "generation_time": 9.858768224716187,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\qualification_round\\trouble_sort",
    "problem_name": "Trouble Sort",
    "python_code": "T = int(input()) # number of test cases\nfor i in range(1, T+1):\n    N = int(input())\n    Vi = list(map(int, input().split()))\n    swapped = True\n    while swapped:\n        swapped = False\n        for j in range(N-2):\n            if Vi[j] > Vi[j+1]:\n                Vi[j], Vi[j+1] = Vi[j+1], Vi[j]\n                swapped = True\n    for k in range(N-2):\n        if Vi[k] > Vi[k+1]:\n            print(\"Case #{}: {}\".format(i, k))\n            break\n    else:\n        print(\"Case #{}: OK\".format(i))",
    "generated_at": "2025-05-03T20:36:40.125295",
    "generation_time": 5.1537206172943115,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\round_1a\\bit_party",
    "problem_name": "Bit Party",
    "python_code": "def main():\n    T = int(input())\n    for i in range(T):\n        R, B, C = map(int, input().split())\n        M = [list(map(int, input().split())) for _ in range(C)]\n        \n        # Sort the cashiers by their payment time (P) and then scan time (Si). This ensures that we allocate the bits to the cashier with the lowest P first.",
    "generated_at": "2025-05-03T20:36:43.569222",
    "generation_time": 3.4274418354034424,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\round_1a\\edgy_baking",
    "problem_name": "Edgy Baking",
    "python_code": "T = int(input())\nfor i in range(1, T+1):\n    N, P = map(int, input().split())\n    W_H = []\n    for j in range(N):\n        W_H.append(list(map(int, input().split()))\n    W = [w[0] for w in W_H]\n    H = [h[1] for h in W_H]\n    perimeter_sum = sum([2*(w+h) for w, h in zip(W, H)]))",
    "generated_at": "2025-05-03T20:36:48.619683",
    "generation_time": 3.337439775466919,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\round_1a\\waffle_choppers",
    "problem_name": "Waffle Choppers",
    "python_code": "def main():\n    T = int(input())\n    for i in range(1, T+1):\n        R, C, H, V = map(int, input().split())\n        grid = []\n        for _ in range(R):\n            row = list(input())\n            grid.append(row)\n        if (H+1)*(V+1) > R*C:\n            print(\"Case #{}: IMPOSSIBLE\".format(i))\n        else:\n            chips_per_piece = 0\n            for row in grid:\n                for cell in row:\n                    if cell == '@':\n                        chips_per_piece += 1\n            if chips_per_piece % (H+1) != 0 or chips_per_piece % (V+1) != 0:\n                print(\"Case #{}: IMPOSSIBLE\".format(i))\n            else:\n                print(\"Case #{}: POSSIBLE\".format(i))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:36:56.289172",
    "generation_time": 7.6618547439575195,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\round_1b\\mysterious_road_signs",
    "problem_name": "Mysterious Road Signs",
    "python_code": "def main():\n    T = int(input())\n    \n    for i in range(1, T+1):\n        S = int(input())\n        \n        D = []\n        A = []\n        B = []\n        \n        for j in range(S):\n            Di, Ai, Bi = map(int, input().split())\n            D.append(Di)\n            A.append(Ai)\n            B.append(Bi)\n            \n        # Sort the signs by their distance from Signfield (west to east)\n        D_sorted = sorted(D)\n        \n        # Initialize variables for largest possible number of signs and valid sets\n        max_signs = 1\n        valid_sets = 0\n        \n        # Iterate through all possible lengths of subsequence starting from 2 up to the length of the sequence\n        for k in range(2, S+1):\n            # Initialize variables for current subsequence and its sign count\n            curr_subseq = []\n            curr_signs = 0\n            \n            # Iterate through all possible subsequences of signs with length k\n            for j in range(S-k+1):\n                subseq = D_sorted[j:j+k]\n                \n                # Check if the current subsequence is valid\n                if subseq[-1] - subseq[0] == sum(subseq) and all((subseq[i+1] - subseq[i]) >= A[D.index(subseq[i]) for i in range(k-1)):\n                    curr_signs = k\n                    \n                # Update max_signs if the current subsequence is longer than previous longest valid subsequence found\n                if curr_signs > max_signs:\n                    max_signs = curr_signs\n                    \n            # Increment count of valid sets with length equal to max_signs\n            if curr_signs == max_signs:\n                valid_sets += 1\n        \n        print(f\"Case #{i}: {max_signs} {valid_sets}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:37:09.744594",
    "generation_time": 13.447537660598755,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\round_1b\\rounding_error",
    "problem_name": "Rounding Error",
    "python_code": "def main():\n    T = int(input())\n    for i in range(1, T+1):\n        N, L = map(int, input().split())\n        C = list(map(int, input().split()))\n        max_sum = 0\n        total = sum(C)\n        for c in C:\n            max_sum += (c + 4) // 5 * 5 # rounding up to the nearest multiple of 5\n        print(\"Case #{}: {}\".format(i, max_sum))\nmain()",
    "generated_at": "2025-05-03T20:37:13.625114",
    "generation_time": 3.8721132278442383,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\round_1b\\transmutation",
    "problem_name": "Transmutation",
    "python_code": "import sys\n\nT = int(input()) # Read number of test cases\nfor i in range(1, T+1):\n    M = int(input()) # Number of metals known in the world\n    formulas = {}\n    \n    for j in range(M):\n        R1, R2 = map(int, input().split()) # Read formula for metal j\n        formulas[R1] = R2\n        \n    G = list(map(int, input().split())) # List of grams of each metal\n    \n    lead_grams = 0\n    while any([G[x] > 0 for x in range(len(G)-1)]): # While there are still metals left to convert into lead\n        max_metal = -1 # Keep track of the metal with most grams available\n        \n        for j in range(1, M+1): # Find the metal that has the highest amount available and use it to create lead\n            if G[j] > 0:\n                max_metal = j\n                \n        if max_metal == -1: # If there are no more metals left to convert into lead, break out of loop\n            break\n        \n        for metal in formulas.keys():\n            if metal != max_metal and G[metal] > 0: # Find the next metal that can be used to create lead with the available metal\n                G[max_metal] -= 1\n                G[formulas[max_metal]] += 1\n                lead_grams += 1\n    \n    print(\"Case #{}: {}\".format(i, lead_grams)) # Output the result for each test case",
    "generated_at": "2025-05-03T20:37:24.302339",
    "generation_time": 10.665183305740356,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\round_1c\\ant_stack",
    "problem_name": "Ant Stack",
    "python_code": "import sys\nfrom collections import deque\n\ndef main():\n    T = int(input())\n    \n    for i in range(1, T+1):\n        N = int(input())\n        W = list(map(int, input().split()))\n        \n        stack_lengths = [0] * N\n        max_stack_length = 0\n        for j in range(N-1, -1, -1):\n            if W[j] <= (6*W[max_stack_length] + 24) and j > 0:\n                stack_lengths[j] = stack_lengths[max_stack_length]+1\n                max_stack_length = j\n        \n        print(\"Case #%d: %d\" % (i, max_stack_length+1))\n    \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:37:30.124118",
    "generation_time": 5.813023567199707,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\round_1c\\a_whole_new_word",
    "problem_name": "A Whole New Word",
    "python_code": "import itertools\n\ndef main():\n    T = int(input())\n    for i in range(1, T+1):\n        N, L = map(int, input().split())\n        vincent_words = []\n        for _ in range(N):\n            vincent_words.append(input())\n        \n        # Get all possible combinations of Vincent's tiles\n        all_tiles = [chr(x) + str(y+1) for x in range(ord('A'), ord('Z')+1) for y in range(L)]\n        valid_tiles = []\n        \n        # Check if there is at least one valid tile combination\n        for tiles in itertools.product(*[all_tiles]*N):\n            if ''.join(tiles) not in vincent_words:\n                valid_tiles.append(''.join(tiles))\n        \n        # Output the result\n        if len(valid_tiles) > 0:\n            print(\"Case #{}: {}\".format(i, valid_tiles[0])\n        else:\n            print(\"Case #{}: -\".format(i))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:37:38.097838",
    "generation_time": 7.95261812210083,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\round_1c\\lollipop_shop",
    "problem_name": "Lollipop Shop",
    "python_code": "import sys\nfrom random import randint, uniform\n\ndef main():\n    # Read T (number of test cases)\n    T = int(input())\n    \n    for i in range(T):\n        # Read N (number of lollipops)\n        N = int(input())\n        \n        # Initialize sold flavors to an empty list\n        sold_flavors = []\n        \n        # Read customer preferences and sell them a lollipop\n        for j in range(N):\n            # Read D (number of liked flavors)\n            D = int(input())\n            \n            # Read the liked flavor IDs\n            liked_flavors = list(map(int, input().split()))\n            \n            # Find available flavors and choose one randomly\n            available_flavors = [f for f in range(N) if f not in sold_flavors]\n            if len(available_flavors) == 0:\n                print(-1, flush=True)\n            else:\n                # Choose a random flavor from the available ones\n                chosen_flavor = randint(0, len(available_flavors)-1)\n                \n                # Sell it to the customer and mark as sold\n                print(available_flavors[chosen_flavor], flush=True)\n                sold_flavors.append(available_flavors[chosen_flavor])\n        \n        # Check if you sold enough lollipops\n        if len(sold_flavors) < 0.9*N:\n            print(\"Too few lollipops sold\", file=sys.stderr)\n            sys.exit()\n    \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:37:50.644827",
    "generation_time": 12.538923263549805,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\round_2\\costume_change",
    "problem_name": "Costume Change",
    "python_code": "import sys\n\nT = int(input())\nfor i in range(1, T+1):\n    N = int(input())\n    A = []\n    for _ in range(N):\n        A.append([int(x) for x in input().split()])\n    \n    changed_count = 0\n    for j in range(N):\n        row_colors = set()\n        col_colors = set()\n        for k in range(N):\n            if abs(A[j][k]) not in row_colors and A[j][k] > 0:\n                row_colors.add(abs(A[j][k]) * (-1 if A[j][k] < 0 else 1) * -1)\n            elif abs(A[j][k]) in row_colors and A[j][k] < 0:\n                changed_count += 1\n            \n            if k not in col_colors and A[j][k] > 0:\n                col_colors.add(abs(A[j][k]))\n            elif k in col_colors and A[j][k] < 0:\n                changed_count += 1\n    \n    print(\"Case #{}: {}\".format(i, changed_count))",
    "generated_at": "2025-05-03T20:37:58.662989",
    "generation_time": 7.9967732429504395,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\round_2\\falling_balls",
    "problem_name": "Falling Balls",
    "python_code": "import sys\ndef main():\n    T = int(input())\n    for i in range(1, T + 1):\n        C = int(input())\n        B = list(map(int, input().split()))\n        if sum(B) > C:\n            print(\"Case #{}: IMPOSSIBLE\".format(i))\n        else:\n            ramp_count = 0\n            for b in B:\n                if b == 1 and ramp_count % 2 != 0:\n                    ramp_count += 1\n                elif b > 0:\n                    print(\"Case #{}: IMPOSSIBLE\".format(i))\n                    break\n            else:\n                rows = (ramp_count + sum(B) - 1) // 2\n                layout = ['.' * C] * rows\n                for j in range(ramp_count):\n                    layout[j] = '\\\\' + '/' * (C - 2) + '.'\n                print(\"Case #{}: {}\".format(i))\n                for row in layout:\n                    print(row)\nmain()",
    "generated_at": "2025-05-03T20:38:06.238379",
    "generation_time": 7.5659706592559814,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\round_2\\graceful_chainsaw_jugglers",
    "problem_name": "Graceful Chainsaw Jugglers",
    "python_code": "num_cases = int(input())\nfor case in range(1, num_cases + 1):\n    R, B = map(int, input().split())\n    max_jugglers = 0\n    for i in range(max(R,B) + 1):\n        if i * (i - 1) <= min(R,B):\n            max_jugglers = max(max_jugglers, i)\n    print(\"Case #{}: {}\".format(case, max_jugglers))",
    "generated_at": "2025-05-03T20:38:10.569043",
    "generation_time": 4.306922912597656,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\round_2\\gridception",
    "problem_name": "Gridception",
    "python_code": "import math\n\ndef count_patterns(grid):\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def get_neighbours(r, c):\n        neighbours = []\n        \n        if r > 0 and grid[r-1][c] == grid[r][c]:\n            neighbours.append((r-1, c))\n        if r < rows - 1 and grid[r+1][c] == grid[r][c]:\n            neighbours.append((r+1, c))\n        if c > 0 and grid[r][c-1] == grid[r][c]:\n            neighbours.append((r, c-1))\n        if c < cols - 1 and grid[r][c+1] == grid[r][c]:\n            neighbours.append((r, c+1))\n            \n        return neighbours\n    \n    def dfs(cell, visited):\n        cell_count = 1\n        \n        for r, c in get_neighbours(*cell):\n            if (r,c) not in visited:\n                visited.add((r,c))\n                cell_count += dfs((r,c), visited)\n                \n        return cell_count\n    \n    max_pattern = 0\n    \n    for r in range(rows):\n        for c in range(cols):\n            pattern = dfs((r,c), set())\n            \n            if pattern > max_pattern:\n                max_pattern = pattern\n                \n    return max_pattern\n        \ndef main():\n    T = int(input())\n    \n    for i in range(1, T+1):\n        R, C = map(int, input().split())\n        grid = [list(input()) for _ in range(R)]\n        max_size = math.log(count_patterns(grid), 2) + 1\n        \n        print(\"Case #%d: %d\" % (i, max_size))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:38:25.554148",
    "generation_time": 14.964940309524536,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\round_3\\fence_construction",
    "problem_name": "Fence Construction",
    "python_code": "import sys\n\ndef is_valid(fences):\n    for i in range(len(fences)):\n        for j in range(i + 1, len(fences)):\n            if i != j and (fences[i][0] == fences[j][2] and fences[i][1] == fences[j][3]) or (fences[i][2] == fences[j][0] and fences[i][3] == fences[j][1]):\n                return False\n    return True\n\ndef find_path(fences, start, end, visited):\n    if start in visited:\n        return []\n    visited.add(start)\n    for i in range(len(fences)):\n        if fences[i][0] == start and (fences[i][2], fences[i][3]) not in visited:\n            path = find_path(fences, (fences[i][2], fences[i][3]), visited)\n            if path:\n                return [i + 1] + path\n        elif fences[i][2] == start and (fences[i][0], fences[i][1]) not in visited:\n            path = find_path(fences, (fences[i][0], fences[i][1]), visited)\n            if path:\n                return [i + 1] + path\n    return []\n\ndef build_order(fences):\n    order = []\n    while len(fences) > 0:\n        start = (0, 0)\n        end = fences[0][0], fences[0][1]\n        path = find_path(fences, start, {(end[0], end[1])}, set())\n        if not path:\n            return \"Impossible\"\n        order += path\n        for i in range(len(fences)):\n            if fences[i][2] == end[0] and fences[i][3] == end[1]:\n                del fences[i]\n    return order\n\nT = int(input())\nfor t in range(1, T + 1):\n    F, K = map(int, sys.stdin.readline().split())\n    fences = []\n    for i in range(K):\n        A, B, C, D = map(int, input().split())\n        fences.append((A, B, C, D))\n    for i in range(F - K):\n        A, B, C, D = map(int, input().split())\n        if (C, D) not in [(a, b) for a, b, c, d in fences]:\n            fences.append((A, B, C, D))\n    if is_valid(fences):\n        order = build_order(fences)\n        print(\"Case #{}: {}\".format(t, \" \".join(map(str, order)))\n    else:\n        print(\"Case #{}: Impossible\".format(t))",
    "generated_at": "2025-05-03T20:38:45.485125",
    "generation_time": 19.92368745803833,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\round_3\\field_trip",
    "problem_name": "Field Trip",
    "python_code": "import sys\n\ndef manhattan_distance(p1, p2):\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n    \ndef min_turns(positions):\n    teacher = positions[0]\n    kids = positions[1:]\n    turns = 0\n    while any([manhattan_distance(teacher, kid) > 1 for kid in kids]):\n        new_kids = []\n        for i in range(len(positions)):\n            if manhattan_distance(teacher, positions[i]) > 1:\n                teacher = [sum(x)//2 for x in zip(teacher, positions[i])]\n                turns += 1\n            else:\n                new_kids.append(positions[i])\n        kids = new_kids[:]\n    return turns + len(kids) - 1\n    \nif __name__ == \"__main__\":\n    T = int(input())\n    for i in range(T):\n        N = int(input())\n        positions = []\n        for j in range(N):\n            R, C = map(int, input().split())\n            positions.append((R, C))\n        print(\"Case #%d: %d\" % (i+1, min_turns(positions)))",
    "generated_at": "2025-05-03T20:38:54.309677",
    "generation_time": 8.804566144943237,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\round_3\\name-preserving_network",
    "problem_name": "Name-Preserving Network",
    "python_code": "def main():\n    T = int(input())\n    for i in range(T):\n        L, U = map(int, input().split())\n        if 10 <= L <= 50 and L == U:\n            N = L\n            links = []\n            for j in range(2*N+1):\n                a, b = map(int, input().split())\n                links.append((min(a,b), max(a,b)))\n        else:\n            print(-1)\n            continue\n        \n        # check conditions 1-3 here\n        \n        # create network design with N computers and print 2N+1 lines representing that design\n        for i in range(2*N+1):\n            print(i, end=\"\\n\")\n            \n        # receive judge's copy of the network design\n        judge_copy = []\n        for j in range(2*N+1):\n            a, b = map(int, input().split())\n            if (a,b) not in links and (b,a) not in links:\n                print(-1)\n                break\n            else:\n                judge_copy.append((min(a,b), max(a,b))\n                \n        # determine the secret permutation f and recover the original identifiers\n        \n        # send back the list of Xs\n        for j in range(N):\n            print(j+1)",
    "generated_at": "2025-05-03T20:39:06.022823",
    "generation_time": 9.207865953445435,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\round_3\\raise_the_roof",
    "problem_name": "Raise the Roof",
    "python_code": "num_cases = int(input())\nfor case in range(1, num_cases + 1):\n    N = int(input())\n    columns = []\n    for _ in range(N):\n        x, y, h = map(int, input().split())\n        columns.append((x, y, h))\n    \n    # Sort the columns based on their heights (h) in descending order\n    sorted_columns = sorted(columns, key=lambda col: col[2], reverse=True)\n    \n    # Initialize the output with the index of the first column\n    result = [1]\n    \n    for i in range(1, N):\n        # Check if the current column can be built without violating any rules\n        for j in range(i-2, -1, -1):\n            col_j = sorted_columns[j]\n            col_k = sorted_columns[i]\n            \n            # If the two columns are not coplanar and not collinear, then they can form a roof\n            if (col_j[:2] != col_k[:2]) and (col_j[0]*(col_k[1]-col_j[1])+col_j[1]*(col_k[0]-col_j[0]) != 0):\n                result.append(i+1)\n                break\n    \n    print(\"Case #{}: {}\".format(case, \" \".join(map(str, result)))<|im_sep|>",
    "generated_at": "2025-05-03T20:39:15.716090",
    "generation_time": 9.681038618087769,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\world_finals\\jurisdiction_restrictions",
    "problem_name": "Jurisdiction Restrictions",
    "python_code": "def main():\n    cases = int(input())\n    for t in range(cases):\n        R, C, S = map(int, input().split())\n        stations = []\n        for i in range(S):\n            Ri, Ci, Di = map(int, input().split())\n            stations.append((Ri, Ci, Di))\n        \n        assignments = [0] * S\n        remaining_blocks = R * C - sum([1 for (Ri, Ci, Di) in stations if Ri == 1 and Ci == 1])\n        for i in range(S):\n            Ri, Ci, Di = stations[i]\n            assignments[i] += sum([1 for r in range(max(1, Ri - Di + 1), min(Ri + Di, R)) for c in range(max(1, Ci - Di + 1), min(Ci + Di, C))])\n        max_assignment = max(assignments)\n        min_assignment = min(assignments)\n        \n        print(\"Case #%d: %d\" % (t+1, max_assignment-min_assignment))\n\nmain()",
    "generated_at": "2025-05-03T20:39:23.574229",
    "generation_time": 7.842478275299072,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\world_finals\\swordmaster",
    "problem_name": "Swordmaster",
    "python_code": "def main():\n    T = int(input())\n    for i in range(1, T+1):\n        N, P = map(int, input().split())\n        A = list(map(int, input().split()))\n        D = list(map(int, input().split())\n        opponents_known_attacks = []\n        for _ in range(N):\n            opponent_info = input().split()\n            known_attacks = set(map(int, opponent_info[:P])\n            opponents_known_attacks.append(known_attacks)\n        \n        # TODO: implement the rest of the code to determine if it is possible for you to become Swordmaster\n        print(\"Case #{}: {}\".format(i, \"YES\" if can_become_swordmaster else \"NO\"))\n        \nmain()",
    "generated_at": "2025-05-03T20:39:29.665880",
    "generation_time": 6.0839807987213135,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\world_finals\\the_cartesian_job",
    "problem_name": "The Cartesian Job",
    "python_code": "import random\nfrom math import pi, sin, cos, sqrt\n\ndef distance(x1, y1, x2, y2):\n    return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef orientation(x1, y1, x2, y2, x3, y3):\n    return (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)\n\ndef is_parallel(x1, y1, x2, y2, x3, y3, x4, y4):\n    return orientation(x1, y1, x2, y2, x3, y3) == 0 and orientation(x1, y1, x2, y2, x4, y4) != 0\n\ndef is_perpendicular(x1, y1, x2, y2, x3, y3, x4, y4):\n    return (x2 - x1) * (y3 - y1) == (y2 - y1) * (x3 - x1) and (x2 - x1) * (y4 - y1) != (y2 - y1) * (x4 - x1)\n\ndef intersects(x1, y1, x2, y2, x3, y3):\n    return is_parallel(x1, y1, x2, y2, x3, y3) or is_perpendicular(x1, y1, x2, y2, x3, y3)\n\ndef angle(theta):\n    return (theta - pi / 2) % (2 * pi)\n\ndef get_angle(x1, y1, x2, y2):\n    dx = x2 - x1\n    dy = y2 - y1\n    return atan2(dy, dx)\n\ndef is_on_segment(x1, y1, x2, y2, x3, y3):\n    dx = x2 - x1\n    dy = y2 - y1\n    return 0 <= (x3 * dx + y3 * dy) / sqrt(dx ** 2 + dy ** 2) <= distance(x1, y1, x2, y2)\n\ndef is_clockwise(theta):\n    return theta % (2 * pi) < pi\n\ndef main():\n    T = int(input())\n    for i in range(T):\n        N = int(input())\n        lasers = []\n        for j in range(N):\n            x1, y1, x2, y2, x3, y3 = map(int, input().split())\n            lasers.append((x1, y1, x2, y2))\n\n        clockwise_lasers = [0] * N\n        counterclockwise_lasers = [0] * N\n        for j in range(N):\n            x1, y1, x2, y2 = lasers[j][:2]\n            theta = get_angle(x1, y1, x2, y2)\n            if is_on_segment(-500, 0, 0, 100, y1):\n                clockwise_lasers[j] = is_clockwise(theta)\n            else:\n                counterclockwise_lasers[j] = not is_clockwise(theta)\n        total = sum(clockwise_lasers + counterclockwise_lasers)\n        if total == 0:\n            print(\"Case #{}: {}\".format(i + 1, 1.0))\n        else:\n            probability = random.random() * (2 * pi - N / total) ** 2\n            print(\"Case #{}: {}\".format(i + 1, probability))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:39:54.963132",
    "generation_time": 25.28193950653076,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\world_finals\\two-tiling",
    "problem_name": "Two-Tiling",
    "python_code": "def main():\n    T = int(input())\n    for i in range(1, T+1):\n        board_left = []\n        board_right = []\n        for j in range(3):\n            board_left.append(list(input().split()[0]) + list(input().split()[1]) + list(input().split()[2]))\n            input()\n            board_right.append(list(input().split())\n        print(\"Case #{}: {}\".format(i, solve(board_left, board_right)))\n\ndef solve(board_left, board_right):\n    for tile in itertools.permutations(['A', 'B']):\n        if is_valid_solution(board_left, board_right, tile[0], tile[1]):\n            print_grid(board_left, board_right, tile)\n            break\n    else:\n        return \"IMPOSSIBLE\"\n    return \"POSSIBLE\"\n\ndef is_valid_solution(board_left, board_right, tile1, tile2):\n    for i in range(3):\n        for j in range(3):\n            if not (tile1[i*3+j] == '.' and tile2[i*3+j] == '.' or tile1[i*3+j] != '.') ^ (tile2[i*3+j] != '.'):\n                return False\n    for i in range(3):\n        for j in range(3):\n            if board_left[i][j] == '@' and tile1[i*3+j] == '.':\n                return False\n    for i in range(8):\n        for j in range(8):\n            if board_right[i//2][j//2] == '.' and (tile2[(i%2)*3+(j%2)] != '.' or tile1[(i%2)*3+(j%2)] != '.') ^ (tile2[(i%2)*3+(j%2)]) == '.':\n                return False\n    for i in range(8):\n        for j in range(8):\n            if board_right[i//2][j//2] == '@' and tile1[(i%2)*3+(j%2)] != '.' and tile2[(i%2)*3+(j%2)].isalpha():\n                return False\n    for i in range(8):\n        for j in range(8, 16):\n            if board_left[i//2][j//2] == '@' and tile2[(i%2)*3+(j%2).isalpha()]:\n                return False\n    return True\n\ndef print_grid(board_left, board_right, tiles):\n    for i in range(8):\n        print(\"\".join([tiles[0] if (i//2)*3 + j//2 < 3 else '.' for j in range(17)]), end=' ')\n        print(\"\".join([board_left[(i%2)*3+j//2][(i//2)*3+j%2] if board_left[(i%2)*3+j//2][(i//2)*3+j%2] == '@' else tiles[1] for j in range(8)]), end=' ')\n        print()\n    print(\" \" * 9, end='')\n    for i in range(8):\n        print(\"\".join([tiles[1] if (i//2)*3 + j//2 < 3 else '.' for j in range(17)]), end=' ')\n        print(\"\".join([board_right[(i%2)*3+j//2][(i//2)*3+j%2] if board_left[(i%2)*3+j//2][(i//2)*3+j%2] == '@' else tiles[0] for j in range(8)]), end=' ')\n        print()\n    return True\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:40:24.425247",
    "generation_time": 29.45177936553955,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\qualification_round\\cryptopangrams",
    "problem_name": "Cryptopangrams",
    "python_code": "import math\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nprimes = []\nnum = 2\nwhile len(primes) < 26:\n    if is_prime(num):\n        primes.append(num)\n    num += 1\n\ndef prime_product(n, i):\n    return n * primes[i]\n\ndef decrypt(ciphertext, N):\n    plaintext = \"\"\n    for i in range(len(ciphertext)):\n        if i == 0:\n            plaintext += chr((primes.index(N // ciphertext[i]) + ord('A')) % 26)\n        else:\n            prime_product_divisor = N // ciphertext[i]\n            for j in range(len(primes)):\n                if primes[j] <= prime_product_divisor and (N % ciphertext[i]) % primes[j] == 0:\n                    plaintext += chr((primes.index(prime_product_divisor // primes[j]) + ord('A')) % 26)\n                    break\n    return plaintext\n\nT = int(input())\nfor i in range(1, T+1):\n    N, L = map(int, input().split())\n    ciphertext = list(map(int, input().split()))\n    plaintext = decrypt(ciphertext[:L], N)\n    print(\"Case #{}: {}\".format(i, plaintext))",
    "generated_at": "2025-05-03T20:40:35.293491",
    "generation_time": 10.849616765975952,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\qualification_round\\foregone_solution",
    "problem_name": "Foregone Solution",
    "python_code": "def find_sum(n):\n    for a in range(1, n+1):\n        if '4' not in str(a) and (n-a)%10 != 4:\n            b = n - a\n            print(f\"Case #{case}: {a} {b}\")\n            break\n\nT = int(input())\nfor case in range(1, T+1):\n    N = int(input())\n    find_sum(N)",
    "generated_at": "2025-05-03T20:40:46.189938",
    "generation_time": 3.0416245460510254,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\qualification_round\\you_can_go_your_own_way",
    "problem_name": "You Can Go Your Own Way",
    "python_code": "import sys\n\ndef find_path(n, lydia_path):\n    path = []\n    for i in range(n*n-1):\n        if i % n == 0 and (i+1) % n != 0: # Moving south is allowed\n            path.append(\"S\")\n        elif (i+1) % n == 0 and i % n != 0: # Moving east is allowed\n            path.append(\"E\")\n        else:\n            if lydia_path[i] == \"E\": # Lydia moved south, we can move east\n                path.append(\"E\")\n            elif lydia_path[i] == \"S\": # Lydia moved east, we can move south\n                path.append(\"S\")\n    return \"\".join(path)\n\ndef main():\n    t = int(input())\n    for i in range(1, t+1):\n        n = int(input())\n        lydia_path = input()\n        my_path = find_path(n, lydia_path)\n        print(\"Case #{}: {}\".format(i, my_path))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:40:53.903182",
    "generation_time": 7.692131042480469,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\round_1a\\alien_rhyme",
    "problem_name": "Alien Rhyme",
    "python_code": "def main():\n    T = int(input()) # number of test cases\n    for i in range(1, T+1):\n        N = int(input()) # number of words\n        words = []\n        for j in range(N):\n            words.append(input().upper()) # input the list of uppercase English letters representing each word\n        \n        max_pairs = 0\n        for accent in range(len(words[0])):\n            pairs = set()\n            for k in range(N-1):\n                for l in range(k+1, N):\n                    if words[k][accent:] == words[l][accent:]: # check if suffixes are equal\n                        pairs.add((k, l))\n            max_pairs = max(max_pairs, len(pairs))\n        \n        print(\"Case #%d: %d\" % (i, max_pairs*2))",
    "generated_at": "2025-05-03T20:41:00.053009",
    "generation_time": 6.138044595718384,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\round_1a\\golf_gophers",
    "problem_name": "Golf Gophers",
    "python_code": "import sys\nfrom collections import defaultdict\n\ndef main():\n    T, N, M = map(int, input().split())\n    gopher_counts = defaultdict(int)\n\n    for i in range(T):\n        for j in range(N + 1):\n            windmill_blades = list(map(int, input().split()))\n            for blade in windmill_blades:\n                gopher_counts[blade] += 1\n        print(*gopher_counts.values())\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:41:04.642135",
    "generation_time": 4.56773042678833,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\round_1a\\pylons",
    "problem_name": "Pylons",
    "python_code": "import itertools\n\ndef valid_move(current, new):\n    if current[0] == new[0] or current[1] == new[1] or abs(current[0] - new[0]) == abs(current[1] - new[1]):\n        return False\n    else:\n        return True\n\ndef next_move(grid, visited, start):\n    if len(visited) == grid.shape[0]*grid.shape[1]:\n        return []\n    \n    for i in range(grid.shape[0]):\n        for j in range(grid.shape[1]):\n            if (i,j) not in visited:\n                next_cell = (i,j)\n                break\n            \n    visited.add((next_cell)\n    return next_cell\n        \ndef find_order(rows, cols):\n    grid = np.zeros((rows,cols), dtype=int)\n    \n    for i in range(1, rows+1):\n        for j in range(1, cols+1):\n            if (i,j) not in visited:\n                next_cell = (i,j)\n                break\n            \n    order = []\n    while len(visited) < grid.shape[0]*grid.shape[1]:\n        for i in range(rows):\n            for j in range(cols):\n                if (i,j) not in visited:\n                    next_cell = (i,j)\n                    break\n            \n        order.append(next_cell)\n        visited.add((next_cell)\n        \n    return order\n    \ndef main():\n    T = int(input())\n    for i in range(1,T+1):\n        rows, cols = map(int, input().split())\n        if rows == 1 and cols == 1:\n            print(\"Case #{}: IMPOSSIBLE\".format(i))\n        else:\n            order = find_order(rows,cols)\n            print(\"Case #{}: POSSIBLE\".format(i))\n            for cell in order:\n                print(*cell)\n                \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:41:18.305216",
    "generation_time": 13.64287257194519,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\round_1b\\draupnir",
    "problem_name": "Draupnir",
    "python_code": "import sys\n\ndef get_input():\n    return int(sys.stdin.readline().strip())\n\ndef main():\n    T = get_input()\n    W = get_input()\n    for i in range(T):\n        rings = [0] * 6\n        days = [0] * (51)\n        \n        for j in range(W+1):\n            guess = input().split(' ')\n            \n            if len(guess) == 1 and int(guess[0]) == -1:\n                break\n                \n            for k, val in enumerate(guess):\n                rings[k] += int(val) % 263\n                \n            days[j+1] = sum([rings[l] for l in range(6)]) % 263\n            \n        print(*rings)\n        \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:41:24.600484",
    "generation_time": 6.283652067184448,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\round_1b\\fair_fight",
    "problem_name": "Fair Fight",
    "python_code": "def main():\n    T = int(input())\n    for i in range(T):\n        N, K = map(int, input().split())\n        Ci = list(map(int, input().split()))\n        Di = list(map(int, input().split())\n        count = 0\n        for L in range(1, N+1):\n            for R in range(L, N+1):\n                if max(Ci[L-1:R]) - min(Di) <= K and max(Di[L-1:R]) - min(Ci) <= K:\n                    count += 1\n        print(\"Case #%d: %d\" % (i+1, count))\nmain()",
    "generated_at": "2025-05-03T20:41:29.708757",
    "generation_time": 5.0830206871032715,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\round_1b\\manhattan_crepe_cart",
    "problem_name": "Manhattan Crepe Cart",
    "python_code": "import sys\nsys.setrecursionlimit(10**6)\nT = int(input())\nfor t in range(1, T+1):\n    P, Q = map(int, input().split())\n    people_movement = []\n    for i in range(P):\n        x, y, direction = map(str, input().split())\n        x, y = int(x), int(y)\n        if direction == \"N\":\n            people_movement.append((x+1, y))\n        elif direction == \"S\":\n            people_movement.append((x-1, y))\n        elif direction == \"E\":\n            people_movement.append((x, y+1) if x < Q else (0, 0))\n        elif direction == \"W\":\n            people_movement.append((x, y-1) if y > 0 else (Q, Q))\n    min_x = min(people_movement, key=lambda p: (p[0], -p[1]) if p[0] >= 0 and p[1] >= 0 else (float(\"inf\"), float(\"inf\")))[0]\n    min_y = min(filter(lambda p: p[0] == min_x, people_movement, key=lambda p: (-p[1]) if p[1] >= 0 else float(\"inf\"))[1]\n    print(\"Case #{}: {} {}\".format(t, min_x, min_y))",
    "generated_at": "2025-05-03T20:41:40.648246",
    "generation_time": 9.068607568740845,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\round_1c\\bacterial_tactics",
    "problem_name": "Bacterial Tactics",
    "python_code": "Here is a Python program based on the given description:",
    "generated_at": "2025-05-03T20:41:41.763821",
    "generation_time": 1.098078966140747,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\round_1c\\power_arrangers",
    "problem_name": "Power Arrangers",
    "python_code": "T = int(input()) # Read number of test cases\nF = int(input()) # Read maximum number of figures to inspect per test case\nfor i in range(T):\n    missing_set = input() # Input the letter arrangement of the missing set\n    for j in range(F+1):\n        if j == F:\n            print(\"Missing set is\", missing_set) # Output the missing set after checking all figures\n            break\n        else:\n            fig = input() # Input a figure from left to right\n            if fig not in missing_set:\n                print(fig) # Output the letter of the current figure",
    "generated_at": "2025-05-03T20:41:46.344127",
    "generation_time": 4.558771848678589,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\round_1c\\robot_programming_strategy",
    "problem_name": "Robot Programming Strategy",
    "python_code": "import random\ndef play_move(robot1, robot2):\n    if robot1 == \"R\" and robot2 == \"P\": return 0\n    elif robot1 == \"R\" and robot2 == \"S\": return 1\n    elif robot1 == \"S\" and robot2 == \"P\": return 1\n    elif robot1 == \"S\" and robot2 == \"R\": return 0\n    else: return -1 # tie\n    \ndef play_match(robot1, robot2):\n    while True:\n        move1 = robot1.pop(0) if len(robot1) > 0 else robot1.extend(robot1[::-1]) or robot1.append(\"R\") # reset and start over, or play the first move of the program\n        move2 = robot2.pop(0) if len(robot2) > 0 else robot2.extend(robot2[::-1]) or robot2.append(\"R\")\n        \n        result = play_move(move1, move2)\n        if result == -1: # tie\n            continue\n        elif result == 0:\n            return \"L\" # robot1 wins\n        else:\n            return \"W\" # robot2 wins\n    \ndef play_tournament(robots):\n    n = len(robots)\n    while n > 1:\n        for i in range(n//2):\n            winner = play_match(robots[i], robots[n-i-1]) # the last bot is the loser of the first match, so it plays second\n            if winner == \"W\":\n                del robots[n-i-1] # remove the loser\n        n //= 2\n    return robots[0][::-1] # reverse the program to start at the beginning and end with the winning move\n    \ndef main():\n    T = int(input())\n    for t in range(T):\n        A = int(input())\n        opponents = []\n        for i in range(A):\n            C = input()\n            if len(C) > 50: # handle invalid input\n                print(\"Case #{}: IMPOSSIBLE\".format(t+1))\n            else:\n                opponents.append(list(C))\n        robots = [play_tournament([opponent[i] for opponent in opponents if i % 2 == j] for j in range(A%2, A)) for _ in range(2)] # play each round separately\n        print(\"Case #{}: {}\".format(t+1, \"\".join(robots[-1]))\n        \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:42:04.099970",
    "generation_time": 17.732497692108154,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\round_2\\contransmutation",
    "problem_name": "Contransmutation",
    "python_code": "import sys\nfrom math import inf\n\ndef main():\n    T = int(input())\n    \n    for i in range(1, T+1):\n        M, G = map(int, input().split())\n        \n        formulas = [list(map(int, input().split())) for _ in range(M)]\n        lead_grams = 0\n        \n        while True:\n            max_lead_formula = -1\n            max_metal = None\n            \n            for metal in range(2, M+1):\n                formula = formulas[metal-1]\n                \n                if len(set(formula)) == 2 and formula.index(metal) != 0:\n                    metal_to_lead = formula.index(1)\n                    \n                    if formula[metal_to_lead] > max_lead_formula:\n                        max_lead_formula = metal_to_lead\n                        max_metal = metal\n            \n            if not max_metal:\n                break\n            \n            grams_of_max_metal = G[max_metal-1]\n            if grams_of_max_metal == 0:\n                break\n            \n            formulas.pop(max_metal-1)\n            G[1-1] += max_lead_formula * grams_of_max_metal\n            G[max_metal-1] = 0\n        \n        lead_grams += sum([G[0]] + [x for x in G if x > 0])\n        \n        print(f\"Case #{i}: {lead_grams % (10**6+7)}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:42:15.599747",
    "generation_time": 11.4708251953125,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\round_2\\new_elements_part_1",
    "problem_name": "New Elements: Part 1",
    "python_code": "import sys\n\ndef valid_orderings(molecules):\n    n = len(molecules)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if molecules[i][0] < molecules[j][0]:\n                count += 1\n            elif molecules[i][1] < molecules[j][1]:\n                count += 1\n    \n    return count\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        molecules = []\n        \n        for _ in range(n):\n            c, j = map(int, input().split())\n            molecules.append((c,j))\n            \n        print(\"Case #{}: {}\".format(i+1, valid_orderings(molecules)))\n    \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:42:22.262358",
    "generation_time": 6.654279708862305,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\round_2\\new_elements_part_2",
    "problem_name": "New Elements: Part 2",
    "python_code": "def main():\n    T = int(input())\n    for i in range(1, T+1):\n        N = int(input())\n        molecules = []\n        for j in range(N):\n            Ci, J = map(int, input().split())\n            molecules.append((Ci*2 + J, Ci, J))\n        if all([molecules[k][0] < molecules[k+1][0] for k in range(len(molecules)-1)]):\n            print(\"Case #{}: IMPOSSIBLE\".format(i))\n        else:\n            c, j = min([(C, J) for C in range(1, 101) for J in range(1, 101) if not any((C*2 + J < molecules[k][0] and C >= molecules[k][1]) or (J*2 + C < molecules[k][0] and J >= molecules[k][2]) for k in range(len(molecules)-1)])\n            print(\"Case #{}: {} {}\".format(i, c))",
    "generated_at": "2025-05-03T20:42:29.886837",
    "generation_time": 7.610407114028931,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\round_3\\datacenter_duplex",
    "problem_name": "Datacenter Duplex",
    "python_code": "def main():\n    T = int(input())\n    for t in range(1, T + 1):\n        R, C = map(int, input().split())\n        matrix = []\n        for i in range(R):\n            row = list(input())\n            if not all(c.isalpha() and c.isupper() for c in row):\n                raise ValueError(\"Invalid input\")\n            matrix.append(row)\n        # Check if A cells are connected and B cells are connected\n        a_connected, b_connected = check_connection(matrix)\n        if not (a_connected and b_connected):\n            print(f\"Case #{t}: IMPOSSIBLE\")\n            continue\n        # Build connections through diagonal adjacencies\n        build_connections(matrix)\n        # Check if the resulting matrix is valid\n        a_connected, b_connected = check_connection(matrix)\n        if not (a_connected and b_connected):\n            raise ValueError(\"Invalid connection\")\n        print(f\"Case #{t}: POSSIBLE\")\n        for row in matrix:\n            print(\"\".join(row))\n\ndef build_connections(matrix):\n    # Helper function to find the diagonal connection pair with the most connections\n    def count_connections(i, j):\n        a = [(-1, -1), (-1, 0), (0, -1)]\n        b = [(1, 0), (0, 1), (1, 1)]\n        counts = []\n        for di, dj in a + b:\n            count = 0\n            ni, nj = i + di, j + dj\n            while 0 <= ni < R and 0 <= nj < C:\n                if matrix[ni][nj] == \"A\":\n                    break\n                elif matrix[ni][nj] == \"B\":\n                    count += 1\n                    break\n                ni, nj = ni + di, nj + dj\n            counts.append(count)\n        return max(counts)\n\n    for i in range(R):\n        for j in range(C):\n            if matrix[i][j] == \"A\" and not (matrix[i - 1][j] == \"B\" or matrix[i + 1][j] == \"B\" or matrix[i][j + 1] == \"B\"):\n                max_count = count_connections(i, j)\n                if max_count > 0:\n                    for di, dj in [(max_count, -1), (-1, max_count)]:\n                        ni, nj = i + di, j + dj\n                        while 0 <= ni < R and 0 <= nj < C:\n                            if matrix[ni][nj] == \"A\":\n                                break\n                            elif matrix[ni][nj] == \"B\" and count_connections(i, j) > 1:\n                                matrix[ni][nj] = \"/\"\n                                break\n                            ni, nj = ni + di, nj + dj\n            if matrix[i][j] == \"B\" and not (matrix[i - 1][j] == \"A\" or matrix[i + 1][j] == \"A\" or matrix[i][j + 1] == \"A\"):\n                max_count = count_connections(i, j)\n                if max_count > 0:\n                    for di, dj in [(max_count, -1), (-1, max_count)]:\n                        ni, nj = i + di, j + dj\n                        while 0 <= ni < R and 0 <= nj < C:\n                            if matrix[ni][nj] == \"B\":\n                                break\n                            elif matrix[ni][nj] == \"A\" and count_connections(i, j) > 1:\n                                matrix[ni][nj] = \"\\\\\"\n                                break\n                            ni, nj = ni + di, nj + dj\n    return matrix\n\ndef check_connection(matrix):\n    # Helper function to check if A cells are connected and B cells are connected\n    def dfs(i, j, visited, company):\n        if not (0 <= i < R and 0 <= j < C) or visited[i][j] or matrix[i][j] != company:\n            return False\n        visited[i][j] = True\n        for di, dj in [(-1, -1), (-1, 0), (0, -1)]:\n            dfs(i + di, j + dj, visited, company)\n        return all(visited)\n    a_connected = dfs(0, 0, [[False] * C for _ in range(R)], \"A\")\n    b_connected = dfs(0, 0, [[False] * C for _ in range(R)], \"B\")\n    return a_connected and b_connected\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:43:10.166618",
    "generation_time": 32.290985107421875,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\round_3\\napkin_folding",
    "problem_name": "Napkin Folding",
    "python_code": "import math\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return abs(a * b) // gcd(a, b)\n\ndef get_ratio(x1, y1, x2, y2):\n    d = math.gcd(math.gcd(x1, y1), math.gcd(x2, y2))\n    return f\"{x1 // d}/{y1 // d}\", f\"{x2 // d}/{y2 // d}\"\n\ndef get_intersecting_segments(polygon):\n    intersecting_pairs = set()\n    for i in range(len(polygon)):\n        p1, p2 = polygon[i], polygon[(i + 1) % len(polygon)]\n        for j in range(i + 2, len(polygon)):\n            q1, q2 = polygon[j], polygon[(j + 1) % len(polygon)]\n            if (p1, p2) == (q1, q2):\n                continue\n            x1, y1, x2, y2 = p1[0] - p2[0], p1[1] - p2[1], q1[0] - q2[0], q1[1] - q2[1]\n            if x1 * (y2 - p2[1]) == y1 * (x2 - p2[0]) and (p1, q1) != (p2, q2):\n                intersecting_pairs.add(frozenset([polygon[i], polygon[(i + 1) % len(polygon)]))\n    return intersecting_pairs\n\ndef find_neat_folding_patterns(polygon, k):\n    if k == 2:\n        return get_intersecting_segments(polygon)\n    \n    def is_neat(segment1, segment2, segments):\n        for segment in segments:\n            if segment != segment1 and segment[0] not in segment1 and segment[1] not in segment1:\n                return False\n            if segment != segment2 and segment[0] not in segment2 and segment[1] not in segment2:\n                return False\n        return True\n    \n    def get_neat_segments(polygon, k):\n        segments = []\n        for i in range(len(polygon)):\n            p1, p2 = polygon[i], polygon[(i + 1) % len(polygon)]\n            for j in range(i + 2, len(polygon)):\n                q1, q2 = polygon[j], polygon[(j + 1) % len(polygon)]\n                if (p1, p2) == (q1, q2):\n                    continue\n                x1, y1, x2, y2 = p1[0] - p2[0], p1[1] - p2[1], q1[0] - q2[0], q1[1] - q2[1]\n                if x1 * (y2 - p2[1]) == y1 * (x2 - p2[0]):\n                    segment = frozenset([p1, p2])\n                    segments.append(segment)\n        for _ in range(k - 3):\n            new_segments = []\n            for i, s1 in enumerate(segments):\n                for j, s2 in enumerate(segments[i + 1:], start=i + 1):\n                    if is_neat(s1, s2, segments) and not (is_neat(s2, s1, segments)):\n                        new_segment = tuple(sorted([*s1, *s2]))\n                        if not any(new_segment[0] in segment for segment in segments):\n                            new_segments.append(new_segment)\n            segments += new_segments\n        return set(map(tuple, segments[-k:])\n    \n    neat_patterns = get_neat_segments(polygon, k + 1)\n    if len(neat_patterns) >= k:\n        return list(neat_patterns)[-k:]\n    else:\n        return None\n\ndef main():\n    T = int(input())\n    for i in range(T):\n        N, K = map(int, input().split())\n        polygon = []\n        for _ in range(N):\n            x, y = map(int, input().split())\n            polygon.append((x, y))\n        \n        neat_patterns = find_neat_folding_patterns(polygon, K - 1)\n        if neat_patterns:\n            print(\"Case #%d: POSSIBLE\" % (i + 1))\n            for segment in neat_patterns:\n                x1, y1 = min(segment[0][0], segment[1][0]), min(segment[0][1], segment[1][1])\n                x2, y2 = max(segment[0][0], segment[1][0]), max(segment[0][1], segment[1][1])\n                print(\"A%sB%s\" % (get_ratio(x1, y1, x2, y2)) if x1 == x2 else \"A%s/%dB%s/%d\" % (x1 // lcm(x1, y1), y1 // gcd(x1, y1), x2 // lcm(x1, y1), y2 // gcd(x1, y1)))\n        else:\n            print(\"Case #%d: IMPOSSIBLE\" % (i + 1))\n        \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:43:49.193037",
    "generation_time": 39.00818181037903,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\round_3\\pancake_pyramid",
    "problem_name": "Pancake Pyramid",
    "python_code": "import sys\nfrom collections import deque\ndef pyramid_cost(pancakes):\n    n = len(pancakes)\n    total = 0\n    for L in range(n):\n        pq = deque()\n        for i in range(L, n - 1):\n            while pq and pq[0][1] <= pancakes[i]:\n                pq.popleft()\n            if not pq or pq[-1][0] != pancakes[i]:\n                pq.append((pancakes[i], i))\n        total += n - 1 - i\n    return total % (10**6 + 7)\n\ndef main():\n    T = int(input())\n    for case in range(1, T + 1):\n        S = int(input())\n        pancakes = list(map(int, input().split()))\n        print(\"Case #%d: %d\" % (case, pyramid_cost(pancakes))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:43:57.448837",
    "generation_time": 8.245802640914917,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\round_3\\zillionim",
    "problem_name": "Zillionim",
    "python_code": "import random\nimport sys\n\ndef main():\n    T = int(input())\n    W = int(input())\n    games_won = 0\n\n    for i in range(T):\n        coins = list(range(1, 51))\n        ai_turns = True\n        while len(coins) >= 10:\n            if ai_turns:\n                valid_moves = []\n                for j in range(len(coins) - 9):\n                    if all([x not in coins for x in range(coins[j], coins[j] + 10)]):\n                        valid_moves.append(coins[j])\n                move = random.choice(valid_moves)\n                print(move)\n                sys.stdout.flush()\n                ai_turns = False\n            else:\n                p = int(input())\n                if p == -1:\n                    break\n                coins = [x for x in coins if x not in range(p, p + 10)]\n                ai_turns = True\n        else:\n            games_won += 1\n\n        if games_won >= W:\n            print(\"I win!\")\n            sys.exit()\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:44:06.444284",
    "generation_time": 8.98303484916687,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\world_finals\\board_meeting",
    "problem_name": "Board Meeting",
    "python_code": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    return tuple(map(int, input().split()) + [None])\n\ndef write_output(line):\n    print(line)\n    sys.stdout.flush()\n\ndef main():\n    T, Nmax, M, R = read_input()\n    for _ in range(T):\n        kings = defaultdict(list)\n        requests = []\n        for i in range(Nmax):\n            xi, yi = map(int, input().split())\n            kings[xi].append((yi, i))\n        \n        write_output(\"READY\")\n        for _ in range(R):\n            a, b = read_input()\n            if a == \"DONE\":\n                break\n            elif a == \"ERROR\" or b == \"ERROR\":\n                continue\n            \n            total_moves = 0\n            for xi, yis in kings.items():\n                total_moves += max(abs(xi - a), abs(yis[0][0] - b))\n                \n            write_output(total_moves)\n        \n        else:\n            continue\n        break\n    \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:44:15.649091",
    "generation_time": 9.16770625114441,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\world_finals\\go_to_considered_helpful",
    "problem_name": "Go To Considered Helpful",
    "python_code": "import sys\nfrom collections import deque\n\ndef get_input():\n    T = int(sys.stdin.readline().strip())\n    for i in range(1, T+1):\n        R, C = map(int, input().split())\n        matrix = [list(map(str, sys.stdin.readline().strip())) for _ in range(R)]\n        M_pos = None\n        N_pos = None\n        \n        for r in range(R):\n            for c in range(C):\n                if matrix[r][c] == 'M':\n                    M_pos = (r, c)\n                elif matrix[r][c] == 'N':\n                    N_pos = (r, c)\n        \n        if not M_pos or not N_pos:\n            print(f\"Case #{i}: IMPOSSIBLE\")\n        else:\n            bfs(M_pos, N_pos, R, C, matrix)\n\ndef bfs(start, end, R, C, matrix):\n    queue = deque([((start, 0)])\n    visited = set()\n    \n    while queue:\n        pos, depth = queue.popleft()\n        \n        if pos == end:\n            print(f\"Case #{i}: {depth}\")\n            return\n        \n        if pos in visited:\n            continue\n            \n        visited.add(pos)\n        \n        for neighbor in get_neighbors(pos, R, C, matrix):\n            queue.append((neighbor, depth+1))\n    \n    print(f\"Case #{i}: IMPOSSIBLE\")\n\ndef get_neighbors(pos, R, C, matrix):\n    r, c = pos\n    neighbors = []\n    \n    if r > 0 and matrix[r-1][c] != '#':\n        neighbors.append((r-1, c))\n        \n    if r < R-1 and matrix[r+1][c] != '#':\n        neighbors.append((r+1, c)\n    \n    if c > 0 and matrix[r][c-1] != '#':\n        neighbors.append((r, c-1))\n        \n    if c < C-1 and matrix[r][c+1] != '#':\n        neighbors.append((r, c+1)\n    \n    return neighbors\n\nget_input()",
    "generated_at": "2025-05-03T20:44:31.061350",
    "generation_time": 15.401705503463745,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\world_finals\\juggle_struggle_part_1",
    "problem_name": "Juggle Struggle: Part 1",
    "python_code": "import sys\nfrom itertools import combinations\n\ndef main():\n    test_cases = int(input())\n    \n    for i in range(test_cases):\n        n = int(input())\n        \n        jugglers = []\n        pairs = []\n        \n        for _ in range(n*2):\n            x, y = map(int, input().split())\n            jugglers.append((x,y))\n            \n        for pair in combinations(jugglers, 2):\n            if is_magnificent(pair[0], pair[1]):\n                pairs.append(str(pair))\n                \n        print(\"Case #{}: {}\".format(i+1), \" \".join(pairs))\n        \ndef is_magnificent(jug1, jug2):\n    return abs(jug1[0] - jug2[0]) != abs(jug1[1] - jug2[1]) and abs(jug1[0] - jug2[0]) + abs(jug1[1] - jug2[1]) == 0\n    \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:44:38.619660",
    "generation_time": 7.540542364120483,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\world_finals\\juggle_struggle_part_2",
    "problem_name": "Juggle Struggle: Part 2",
    "python_code": "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.readline()\n    T = int(input())\n    for t in range(1, T + 1):\n        N = int(sys.stdin.readline().strip())\n        jugglers = []\n        pairs = defaultdict(set)\n        for i in range(N):\n            x, y, x2, y2 = map(int, sys.stdin.readline().split())\n            jugglers.append((x, y))\n            jugglers.append((x2, y2))\n            pairs[i].add((x, y))\n            pairs[N + i].add((x2, y2))\n        for i in range(N):\n            for j in range(i + 1, N):\n                if not is_collinear(jugglers[i], jugglers[j]):\n                    pairs[i].add(j)\n                    pairs[j].add(i)\n        result = set()\n        for i in range(N):\n            if len(pairs[i]) < N - 1:\n                result.add(i + 1)\n        print(\"Case #{}:\".format(t), \"MAGNIFICENT\" if not result else sorted(result))\n\ndef is_collinear(j1, j2):\n    x1, y1 = j1\n    x2, y2 = j2\n    return (x1 - x2) * (y1 - y2) == 0\n\nmain()",
    "generated_at": "2025-05-03T20:44:48.920882",
    "generation_time": 10.28719687461853,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\world_finals\\sorting_permutation_unit",
    "problem_name": "Sorting Permutation Unit",
    "python_code": "import math\n\ndef sort_array(arr):\n    return sorted(arr)\n\ndef main():\n    T = int(input())\n    for i in range(T):\n        P, S, N, K = map(int, input().split())\n        arrays = [list(map(int, input().split())) for _ in range(K)]\n        permutations = []\n        for j in range(P):\n            permutation = list(map(int, input().split()))\n            permutations.append([permutation[i] - 1 for i in range(N)])\n        \n        instructions = []\n        for k in range(K):\n            S_prime = int(input())\n            if S_prime > S:\n                print(\"Invalid input\")\n                return\n            instruction = [int(x) - 1 for x in input().split()]\n            if len(set(instruction)) != len(instruction):\n                print(\"Invalid input\")\n                return\n            instructions.append(instruction)\n        \n        for k in range(K):\n            sorted_array = arrays[k][:]\n            for s in instructions[k]:\n                sorted_array = sort_array([sorted_array[permutations[s][i] - 1] for i in range(N)] if len(instructions[k]) == S else sort_array(sorted_array)\n            print(\" \".join(map(str, sorted_array))\n            \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:44:58.735362",
    "generation_time": 9.805094718933105,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\world_finals\\wont_sum_must_now",
    "problem_name": "Won't sum? Must now",
    "python_code": "import sys\nsys.setrecursionlimit(10**6)\ndef is_palindrome(n):\n    return str(n) == str(n)[::-1]\n\ndef find_minimum_terms(s, terms=[]):\n    if s < 1:\n        return terms\n    for i in range(10**len(str(s)), 10**(len(str(s)-1), -1, -1):\n        if is_palindrome(i) and i <= s:\n            new_terms = find_minimum_terms(s-i, terms+[i])\n            if sum(new_terms) == s:\n                return new_terms\n    return []\n\ndef main():\n    num_cases = int(input())\n    for case in range(1, num_cases + 1):\n        s = int(input())\n        terms = find_minimum_terms(s)\n        if len(terms) == 1:\n            print(\"Case #{}: {}\".format(case, terms[0])\n        elif len(terms) == 2:\n            print(\"Case #{}: {} {}\".format(case, terms[0], terms[1])\n        else:\n            print(\"Case #{}: {} {} {}\".format(case, terms[0], terms[1], terms[2])\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:45:07.485073",
    "generation_time": 8.733328342437744,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\qualification_round\\esab_atad",
    "problem_name": "ESAb ATAd",
    "python_code": "import random\nfrom collections import defaultdict\n\ndef main():\n    T = int(input())\n    \n    for test in range(T):\n        B, N = map(int, input().split())\n        \n        # initialize the array with 0's\n        arr = [0] * B\n        \n        # keep track of queries and fluctuations\n        query_count = defaultdict(int)\n        fluctuation_count = defaultdict(int)\n        \n        for i in range(N):\n            # make a random query between 1 and B (inclusive)\n            pos = random.randint(1, B)\n            \n            # increment the count of queries at this position\n            query_count[pos] += 1\n            \n            # check if it's time for a fluctuation\n            if i + 1 in [j * (j+10) for j in range(1, 15)]:\n                fluc = random.randint(1,4)\n                \n                # increment the count of fluctuations at this position\n                fluctuation_count[pos] += fluc\n                \n                if fluc == 3:\n                    arr[pos-1] = not arr[pos-1]\n        \n        print(\" \".join(map(str, arr))\n\nif __name__ == \"__main__\":\n    main()\n\n# this is just a starting point; you should add more test cases and optimize the algorithm to find the entire array",
    "generated_at": "2025-05-03T20:45:18.431656",
    "generation_time": 9.14608097076416,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\qualification_round\\indicium",
    "problem_name": "Indicium",
    "python_code": "import itertools\n\ndef generate_latin(n):\n    elements = range(1, n+1)\n    for perm in itertools.permutations(elements):\n        if len(set(perm)) == n and len(set(zip(*perm))) == n:\n            return perm\n    return None\n\ndef main():\n    T = int(input())\n    for i in range(1, T+1):\n        N, K = map(int, input().split())\n        if K < N or K > N*N:\n            print(\"Case #{}: IMPOSSIBLE\".format(i))\n        else:\n            latin_square = generate_latin(N)\n            if not latin_square:\n                print(\"Case #{}: IMPOSSIBLE\".format(i))\n            else:\n                trace = sum([latin_square[x][x] for x in range(N)])\n                while trace != K:\n                    latin_square = generate_latin(N)\n                    if not latin_square:\n                        print(\"Case #{}: IMPOSSIBLE\".format(i))\n                        break\n                    else:\n                        trace = sum([latin_square[x][x] for x in range(N)])\n                if trace == K:\n                    print(\"Case #{}: POSSIBLE\".format(i))\n                    for row in latin_square:\n                        print(*row)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:45:27.690740",
    "generation_time": 9.236456155776978,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\qualification_round\\nesting_depth",
    "problem_name": "Nesting Depth",
    "python_code": "import re\n\ndef solve(S):\n    stack = []\n    result = ''\n    for i, c in enumerate(S):\n        if c == '(':\n            stack.append((c, i) if not stack else (stack[-1][0] + 1, max(stack[-1][1], i)) )\n        elif c == ')':\n            if not stack or stack[-1][0] % 2 == 1:\n                result += '(' * (int(c)*2) + c\n                continue\n            while stack and stack[-1][0] < int(c):\n                stack.pop()\n            if not stack:\n                result += '('*int(c)*2 + c\n        else:\n            depth = len(stack) * 2\n            result += '('*depth + c + ')'*depth\n    while stack:\n        result += ')'*(stack[-1][0]-1) + ')'\n        stack.pop()\n    return result\n\ndef main():\n    T = int(input())\n    for i in range(1, T+1):\n        S = input().strip()\n        print(\"Case #%d: %s\" % (i, solve(S))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:45:35.722520",
    "generation_time": 8.02143669128418,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\qualification_round\\parenting_partnering_returns",
    "problem_name": "Parenting Partnering Returns",
    "python_code": "import sys\r\nsys.setrecursionlimit(10**6)\r\n\r\ndef dfs(graph, visited, current, path):\r\n    if len(path) == len(graph):\r\n        return True\r\n    for i in range(len(graph)):\r\n        if not visited[i] and (current[-1][0] < graph[i][0] or current[-1][1] < graph[i][1]):\r\n            visited[i] = True\r\n            path.append((graph[i], i)\r\n            if dfs(graph, visited, path) is True:\r\n                return True\r\n            else:\r\n                path.pop()\r\n                visited[i] = False\r\n    return False\r\n\r\ndef find_schedule(activities):\r\n    graph = [(a[1], a[2]) for a in activities]\r\n    visited = [False] * len(graph)\r\n    schedule = [''] * len(graph)\r\n    dfs(graph, visited, [(0, 0)])\r\n    for i in range(len(visited)):\r\n        if not visited[i]:\r\n            return \"IMPOSSIBLE\"\r\n        else:\r\n            schedule[i] = 'C' if activities[i][3] == 'C' else 'J'\r\n    return ''.join(schedule)\r\n\r\nn_cases = int(input())\r\nfor i in range(1, n_cases+1):\r\n    N = int(input())\r\n    activities = []\r\n    for j in range(N):\r\n        S, E, C = map(int, input().split())\r\n        activities.append((S, E, C)\r\n    schedule = find_schedule(activities)\r\n    if schedule == \"IMPOSSIBLE\":\r\n        print(\"Case #%d: IMPOSSIBLE\" % i)\r\n    else:\r\n        print(\"Case #%d: %s\" % (i, schedule)",
    "generated_at": "2025-05-03T20:45:48.475744",
    "generation_time": 12.72285532951355,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\qualification_round\\vestigium",
    "problem_name": "Vestigium",
    "python_code": "import sys\n\ndef get_trace(matrix):\n    trace = 0\n    for i in range(len(matrix)):\n        trace += matrix[i][i]\n    return trace\n\ndef count_repeated_rows(matrix):\n    rows_with_repeats = []\n    cols_with_repeats = []\n    seen_rows = set()\n    seen_cols = set()\n    \n    for i in range(len(matrix)):\n        row_set = set([matrix[i][j] for j in range(len(matrix))])\n        col_set = set([matrix[j][i] for j in range(len(matrix)])\n        \n        if len(row_set) != len(matrix):\n            rows_with_repeats.append(i+1)\n            \n        if len(col_set) != len(matrix):\n            cols_with_repeats.append(i+1)\n    \n    return (rows_with_repeats, cols_with_repeats)\n\ndef is_natural_latin_square(matrix):\n    rows_with_repeats, cols_with_repeats = count_repeated_rows(matrix)\n    return len(rows_with_repeats) == 0 and len(cols_with_repeats) == 0\n    \ndef main():\n    T = int(input())\n    \n    for i in range(1, T+1):\n        N = int(input())\n        \n        matrix = []\n        for _ in range(N):\n            row = list(map(int, input().split()))\n            matrix.append(row)\n            \n        trace = get_trace(matrix)\n        rows_with_repeats, cols_with_repeats = count_repeated_rows(matrix)\n        \n        if is_natural_latin_square(matrix):\n            print(\"Case #%d: %d 0 0\" % (i, trace))\n        else:\n            print(\"Case #%d: %d %d %d\" % (i, trace, len(rows_with_repeats), len(cols_with_repeats)))\n        \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:46:03.522732",
    "generation_time": 13.560146570205688,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\round_1a\\pascal_walk",
    "problem_name": "Pascal Walk",
    "python_code": "import itertools\nimport math\n\ndef binomial_coefficient(n, k):\n    return math.comb(n, k) % (10**9 + 7)\n\ndef pascal_triangle():\n    triangle = [[1]]\n    for i in range(1, 51):\n        row = [binomial_coefficient(i, j) for j in range(i+1)]\n        triangle.append(row)\n        yield row\n\ndef find_pascal_walk():\n    n = int(input())\n    print(\"Case #{}\".format(n))\n    walk = [(1, 1)]\n    for i, row in enumerate(pascal_triangle()):\n        if sum(row) == n:\n            print(\" \".join([str(i+1) for i in range(len(walk))]))\n            return\n        elif sum(row) > n:\n            break\n        else:\n            max_index = row.index(max(row[:-1]) + 1)\n            walk.append((i+1, max_index))\n    print(\" \".join([str(i+1 for i in range(len(walk)))])\n        \nfor _ in range(int(input())):\n    find_pascal_walk()",
    "generated_at": "2025-05-03T20:46:11.346756",
    "generation_time": 7.795962572097778,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\round_1a\\pattern_matching",
    "problem_name": "Pattern Matching",
    "python_code": "def main():\n    T = int(input())\n    for i in range(1, T + 1):\n        N = int(input())\n        patterns = []\n        for j in range(N):\n            patterns.append(input().strip())\n        name = ''\n        found_name = False\n        for c in ascii_uppercase:\n            if not found_name:\n                for pattern in patterns:\n                    if '*' in pattern:\n                        index = pattern.index('*')\n                        if len(pattern) == 1 or (len(pattern[0:index]) != '' and name[:index] == pattern[0:index] and name[-1] not in ascii_uppercase):\n                            found_name = True\n                            break\n                    else:\n                        if len(name) < len(pattern):\n                            for c in ascii_uppercase:\n                                name += c\n                                if pattern == name:\n                                    found_name = True\n                                    break\n                                elif '*' not in pattern and pattern != name:\n                                    name = ''\n        print(f\"Case #{i}: {name}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:46:19.388019",
    "generation_time": 8.013848066329956,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\round_1a\\square_dance",
    "problem_name": "Square Dance",
    "python_code": "import sys\n\ndef main():\n    T = int(input())\n    for i in range(1, T+1):\n        R, C = map(int, input().split())\n        S = []\n        for j in range(R):\n            row = list(map(int, input().split()))\n            S.append(row)\n        interest_level = 0\n        while True:\n            eliminated = False\n            new_S = [[] for _ in range(R)]\n            for j in range(C):\n                for k in range(R):\n                    if S[k][j] == -1: continue\n                    neighbors = 0\n                    neighbor_sum = 0\n                    if k > 0 and S[k-1][j] != -1:\n                        neighbors += 1\n                        neighbor_sum += S[k-1][j]\n                    if k < R-1 and S[k+1][j] != -1:\n                        neighbors += 1\n                        neighbor_sum += S[k+1][j]\n                    if j > 0 and S[k][j-1] != -1:\n                        neighbors += 1\n                        neighbor_sum += S[k][j-1]\n                    if j < C-1 and S[k][j+1] != -1:\n                        neighbors += 1\n                        neighbor_sum += S[k][j+1]\n                    \n                    if neighbors > 0 and S[k][j]/neighbors < neighbor_sum/neighbors:\n                        S[k][j] = -1\n                        eliminated = True\n                        \n            for j in range(C):\n                for k in range(R):\n                    if S[k][j] == -1: continue\n                    new_S[k].append(S[k][j])\n                    \n            if not any([len(x) > 0 for x in new_S]): break\n            \n            interest = sum([sum(x) for x in S])\n            interest_level += interest\n            S = new_S\n        print(\"Case #{}: {}\".format(i, interest_level))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:46:34.493762",
    "generation_time": 15.08639407157898,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\round_1b\\expogo",
    "problem_name": "Expogo",
    "python_code": "import sys\n\ndef expogo_stick(x, y):\n    if x == 0 and y == 0:\n        return \"IMPOSSIBLE\"\n    n = abs(x) + abs(y)\n    jumps = \"\"\n    current_x = 0\n    current_y = 0\n    for i in range(1, n+1):\n        if x > y:\n            if current_x < x and current_y == y:\n                jumps += \"E\" * (i*2 - 1) + \"N\" * (i-1)\n                current_x = i * i\n                current_y = 0\n        elif x < y:\n            if current_x == x and current_y < y:\n                jumps += \"S\" * (i*2 - 1) + \"W\" * (i-1)\n                current_x = 0\n                current_y = i * i\n        elif x > 0:\n            if current_x < x and current_y == y:\n                jumps += \"E\" * (i*2 - 1) + \"N\" * (i-1)\n                current_x = i * i\n                current_y = 0\n        elif x < 0:\n            if current_x > x and current_y == y:\n                jumps += \"W\" * (i*2 - 1) + \"S\" * (i-1)\n                current_x = -i * i\n                current_y = 0\n        elif y < 0:\n            if current_y > y and current_x == x:\n                jumps += \"N\" * (i*2 - 1) + \"E\" * (i-1)\n                current_y = -i * i\n                current_x = 0\n        elif y > 0:\n            if current_y < y and current_x == x:\n                jumps += \"S\" * (i*2 - 1) + \"W\" * (i-1)\n                current_y = i * i\n    return jumps\n\ninputs = int(sys.stdin.readline())\nfor i in range(1, inputs+1):\n    x, y = map(int, input().split())\n    print(\"Case #{}: {}\".format(i, expogo_stick(x, y))",
    "generated_at": "2025-05-03T20:46:57.489510",
    "generation_time": 14.861827373504639,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\round_1b\\join_the_ranks",
    "problem_name": "Join the Ranks",
    "python_code": "import sys\n\nT = int(input())\nfor i in range(1, T + 1):\n    R, S = map(int, input().split())\n    if R * S <= 14:\n        n_ops = min((R - 1) // 2) + (S - 1)\n        print(\"Case #{}: {}\".format(i, n_ops))\n        for j in range(n_ops):\n            a = max(j * 2 + 1, R % 2) if j < S else R - 2 * (R // 2)\n            b = min((R - a), j + 1)\n            print(\"{} {}\".format(a, b))\n    elif T <= 100 and R <= 40 and S <= 40:\n        n_ops = min((R - 1) // 2 * (S + 1) + (S - 1))\n        print(\"Case #{}: {}\".format(i, n_ops))\n        for j in range(n_ops):\n            a = max(j * 2 + 1, R % 2) if j < S else R - 2 * (R // 2)\n            b = min((R - a), j + 1)\n            print(\"{} {}\".format(a, b))\n    else:\n        sys.exit()",
    "generated_at": "2025-05-03T20:47:08.601982",
    "generation_time": 11.094898700714111,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\round_1c\\overexcited_fan",
    "problem_name": "Overexcited Fan",
    "python_code": "def get_picture(X, Y, M):\n    x = X\n    y = Y\n    moves = {\"N\": (0, -1), \"E\": (1, 0), \"S\": (0, 1), \"W\": (-1, 0)}\n    \n    for move in M:\n        dx, dy = moves[move]\n        x += dx\n        y += dy\n        \n    return abs(x) + abs(y)\n        \ndef main():\n    T = int(input())\n    \n    for i in range(1, T+1):\n        X, Y = map(int, input().split())\n        M = input()\n        \n        if len(M) == 0:\n            print(\"Case #{}: IMPOSSIBLE\".format(i))\n        else:\n            result = get_picture(X, Y, M)\n            \n            if result <= max(abs(X), abs(Y)):\n                print(\"Case #{}: {}\".format(i, result))\n            else:\n                print(\"Case #{}: IMPOSSIBLE\".format(i))\n                \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:47:16.932079",
    "generation_time": 8.30336856842041,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\round_1c\\overrandomized",
    "problem_name": "Overrandomized",
    "python_code": "def main():\n    T = int(input())\n    for t in range(T):\n        U = int(input())\n        records = []\n        \n        for i in range(104):\n            M, Ri = input().split()\n            if M == '-1':\n                M = None\n            else:\n                M = int(M)\n            records.append((M, Ri))\n            \n        D = recover_digit_string(records, U)\n        print(\"Case #{}: {}\".format(t+1, ''.join(D))\n        \ndef recover_digit_string(records, U):\n    digit_map = [None] * 10\n    \n    for i in range(104):\n        M, Ri = records[i]\n        if not M:\n            continue\n        for j, c in enumerate(Ri):\n            if digit_map[j]:\n                if c != digit_map[j]:\n                    return None # Conflict found\n            else:\n                digit_map[j] = c\n    \n    for i in range(104):\n        M, Ri = records[i]\n        if not M:\n            continue\n        \n        if len(Ri) != 5:\n            return None # Invalid response length\n        \n        if not all(c.isupper() and c.isalpha() for c in Ri):\n            return None # Non-letter character found\n        \n        mapping = {}\n        for j, c in enumerate(Ri):\n            if c not in mapping:\n                mapping[c] = digit_map[j]\n                \n    for i in range(104):\n        M, Ri = records[i]\n        if not M:\n            continue\n        \n        base10_str = ''.join([mapping[c] for c in Ri])\n        if int(base10_str) < 1 or int(base10_str) > U:\n            return None # Out-of-range response found\n    \n    return digit_map\n\n# Read input from file\nwith open('input.txt', 'r') as f:\n    T = int(f.readline())\n    for t in range(T):\n        U = int(f.readline().strip())\n        records = []\n        \n        for i in range(104):\n            M, Ri = f.readline().split()\n            if M == '-1':\n                M = None\n            else:\n                M = int(M)\n            records.append((M, Ri))\n            \n        D = recover_digit_string(records, U)\n        print(\"Case #{}: {}\".format(t+1, ''.join(D), file=open('output.txt', 'a'))",
    "generated_at": "2025-05-03T20:47:35.877863",
    "generation_time": 17.157302856445312,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\round_1c\\oversized_pancake_choppers",
    "problem_name": "Oversized Pancake Choppers",
    "python_code": "import math\n\ndef main():\n    T = int(input())\n    \n    for t in range(1, T+1):\n        N, D = map(int, input().split())\n        A = list(map(float, input().split()))\n        \n        def angle_to_area(angle):\n            return 0.5 * math.sin(math.radians(angle)) + 0.5\n        \n        total_area = sum([angle_to_area(a) for a in A])\n        min_cuts = float('inf')\n        \n        for i in range(1, len(A)+1):\n            if D*i > N:\n                continue\n            \n            target_area = total_area / (D*i)\n            cuts = 0\n            current_angle = A[0]\n            \n            while angle_to_area(current_angle) < target_area and i <= len(A):\n                cuts += 1\n                current_angle -= min(current_angle, sum(A[i:]) / (len(A)-i))\n                \n            min_cuts = min(min_cuts, cuts)\n            \n        print(\"Case #{}: {}\".format(t, min_cuts))\n        \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:47:44.652121",
    "generation_time": 8.758972644805908,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\round_2\\emacs",
    "problem_name": "Emacs++",
    "python_code": "import sys\nfrom collections import deque\n\ndef parse_input():\n    T = int(sys.stdin.readline().strip())\n    for t in range(T):\n        K, Q = map(int, input().split())\n        P = list(map(str, input()))\n        \n        LRP = [list(map(int, input().split())) for _ in range(Q)]\n        SRE = [list(map(int, input().split())) for _ in range(Q)]\n        \n        # process queries here and calculate time cost\n        time_costs = []\n        for i in range(Q):\n            Li, Ri, Pi = LRP[i]\n            Sj, Ej = SRE[i]\n            \n            if (Sj == 1 or P[Sj-2] == '(') and (Ej == K or P[Ej-1] == ')'):\n                time_costs.append(abs(Li - Ri))\n            else:\n                # find the matching parenthesis for teleportation\n                stack = deque()\n                for j in range(Sj, Ej+1):\n                    if P[j-1] == '(':\n                        stack.append(j)\n                    elif P[j-1] == ')':\n                        stack.pop()\n                    \n                matching_parenthesis = stack[-1] if stack else -1\n                time_costs.append((abs(Sj - Li) + abs(Ej - matching_parenthesis)) * Pi)\n        \n        print(\"Case #{}: {}\".format(t+1, sum(time_costs))\n\nparse_input()",
    "generated_at": "2025-05-03T20:47:55.591556",
    "generation_time": 10.912729263305664,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\round_2\\incremental_house_of_pancakes",
    "problem_name": "Incremental House of Pancakes",
    "python_code": "def main():\n    T = int(input())\n    for i in range(1, T + 1):\n        L, R = map(int, input().split())\n        served_customers = 0\n        while L >= 1 and R >= 1:\n            if L > R:\n                L -= 1\n                served_customers += 1\n            elif R > L:\n                R -= 1\n                served_customers += 1\n            else:\n                break\n        print(\"Case #{}: {} {} {}\".format(i, served_customers, L, R))<|im_sep|>",
    "generated_at": "2025-05-03T20:48:01.184471",
    "generation_time": 5.573675155639648,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\round_2\\security_update",
    "problem_name": "Security Update",
    "python_code": "import sys\nfrom collections import defaultdict\n\ndef parse_input():\n    T = int(sys.stdin.readline().strip())\n    cases = []\n    for t in range(T):\n        C, D = map(int, input().split())\n        X = list(map(int, input().split()))\n        connections = defaultdict(set)\n        for _ in range(D):\n            U, V = map(int, input().split())\n            connections[U].add(V)\n            connections[V].add(U)\n        cases.append((C, D, X, connections))\n    return T, cases\n\ndef solve_case(C, D, X, connections):\n    latencies = [-1] * (C+1)  # initialize all latencies to -1\n    latencies[1] = 0  # source computer has zero latency\n    \n    def dfs(node, parent=-1):\n        for child in connections[node]:\n            if child == parent: continue  # skip back edges\n            if latencies[child] != -1: continue  # already visited\n            \n            if X[node-2] >= 0 and X[child-2] < 0:\n                latency = abs(X[node-2]) - abs(X[child-2])  # child received update before node\n            else:\n                latency = abs(X[node-2]) + abs(X[child-2])  # child received update after node\n            \n            if latency > 10**6: continue  # invalid latency value, skip this connection\n            latencies[child] = latency\n            dfs(child, node)\n    \n    dfs(1)  # start DFS from source computer\n    return latencies[2:]  # remove the source computer and return only non-source computers' latencies\n\ndef main():\n    T, cases = parse_input()\n    for i, (C, D, X, connections) in enumerate(cases):\n        latencies = solve_case(C, D, X, connections)\n        print(\"Case #{}: {}\".format(i+1), \" \".join(map(str, latencies))\n\nif __name__ == '__main__':\n    main()",
    "generated_at": "2025-05-03T20:48:15.886776",
    "generation_time": 14.68823504447937,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\round_2\\wormhole_in_one",
    "problem_name": "Wormhole in One",
    "python_code": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    num_cases = int(sys.stdin.readline().strip())\n    cases = []\n    for i in range(1, num_cases + 1):\n        n = int(sys.stdin.readline().strip())\n        holes = defaultdict(set)\n        for j in range(n):\n            x, y = map(int, sys.stdin.readline().strip().split())\n            holes[(x, y)].add((x, y))\n        cases.append(holes)\n    return num_cases, cases\n\ndef count_distinct_holes(holes):\n    max_count = 0\n    for start in holes:\n        visited = set()\n        current = start\n        count = 1\n        while True:\n            next_hole = None\n            for hole in holes[current]:\n                if hole not in visited:\n                    next_hole = hole\n                    break\n            else:\n                break\n            if not next_hole:\n                break\n            visited.add(next_hole)\n            count += 1\n            current = next_hole\n        max_count = max(max_count, count)\n    return max_count\n\ndef main():\n    num_cases, cases = read_input()\n    for i in range(num_cases):\n        print(\"Case #%d: %d\" % (i+1, count_distinct_holes(cases[i]))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:48:26.836679",
    "generation_time": 10.939873456954956,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\round_3\\naming_compromise",
    "problem_name": "Naming Compromise",
    "python_code": "import sys\nfrom collections import defaultdict\n\ndef edit_distance(s1, s2):\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n    return dp[-1][-1]\n\ndef find_compromise(s1, s2):\n    m, n = len(s1), len(s2)\n    min_edit_distance = float('inf')\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                edit_distances[s2[:j]] = edit_distance(s1, s2[:j])\n            elif j == 0:\n                edit_distances[s1[:i]] = edit_distance(s1[:i], s2)\n            else:\n                edit_distances[s1[:i] + s2[:j]] = min(edit_distances[s1[:i - 1] + s2[:j], dp[i][j - 1], dp[i - 1][j]) + 1)\n    for i in range(m):\n        for j in range(n):\n            if edit_distances[s1[:i+1] + s2[:j+1]] < min_edit_distance:\n                min_edit_distance = edit_distances[s1[:i+1] + s2[:j+1]]\n    return s1[:-min_edit_distance] + s2[-min_edit_distance:]\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        cameron, jamie = input().split()\n        edit_distances = defaultdict(int)\n        compromise = find_compromise(cameron, jamie)\n        print(\"Case #%d: %s\" % (i+1, compromise) if len(compromise) > 0 else \"Case #%d: No possible answer\" % (i+1))\n\nif __name__ == '__main__':\n    main()",
    "generated_at": "2025-05-03T20:48:45.702039",
    "generation_time": 18.841912269592285,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\round_3\\pen_testing",
    "problem_name": "Pen Testing",
    "python_code": "import sys\nfrom collections import Counter\n\ndef readline_int_list():\n    return map(int, input().split())\n\nt, n, c = readline_int_list()\npens = [0] * n # initialize all pens to 0 units of ink\nsuccesses = 0\nfor i in range(t):\n    for j in range(n):\n        print(j+1)\n        sys.stdout.flush()\n        spent_ink = int(input())\n        if spent_ink == 1: # pen still has ink left\n            pens[j] -= 1\n    min_ink = n\n    max_ink = -1\n    for j, ink in enumerate(pens):\n        if ink > 0 and ink < min_ink:\n            min_ink = ink\n        elif ink > max_ink:\n            max_ink = ink\n    if min_ink + max_ink >= c:\n        successes += 1\n    print(min_ink, max_ink)\n    sys.stdout.flush()\n    if successes == t:\n        break\nprint(0) # end of input\nsys.exit() # avoid TLE error by exiting gracefully",
    "generated_at": "2025-05-03T20:48:57.142166",
    "generation_time": 11.408833265304565,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\round_3\\recalculating",
    "problem_name": "Recalculating",
    "python_code": "def main():\n    T = int(input())\n    for i in range(T):\n        N, D = map(int, input().split())\n        repair_centers = []\n        for _ in range(N):\n            x, y = map(float, input().split())\n            repair_centers.append((x, y))\n        \n        # calculate area of each red square and blue section\n        total_area = 0\n        distinguishable_area = 0\n        for rc in repair_centers:\n            x, y = rc\n            total_area += (2*D+1)**2 - (x-D)*(y-D) + (x+D)*(y+D) - (x+D)*(y-D) - (x-D)*(y+D)\n        \n        # calculate the probability of being deployed to a distinguishable point\n        for rc in repair_centers:\n            x, y = rc\n            area_within_range = 2*(D+1)**2 - (x-D)*(y-D) + (x+D)*(y+D) - (x+D)*(y-D) - (x-D)*(y+D)\n            distinguishable_area += area_within_range\n        \n        prob = float(distinguishable_area)/float(total_area)\n        print(\"Case #{}: {} {}\".format(i+1, int(prob*10**9))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:49:10.325459",
    "generation_time": 13.164582252502441,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\round_3\\thermometers",
    "problem_name": "Thermometers",
    "python_code": "import sys\n\ndef min_thermometers(K, X, T):\n    N = len(X)\n    thermometers = []\n    \n    for i in range(N-1):\n        if T[i] != T[i+1]:\n            thermometers.append((X[i], T[i]))\n        \n    return len(thermometers)+1\n\ndef main():\n    T = int(input())\n    \n    for i in range(T):\n        K, N = map(int, input().split())\n        X = list(map(float, input().strip().split()))\n        T = list(map(int, input().strip().split()))\n        \n        print(\"Case #{}: {}\".format(i+1, min_thermometers(K, X, T))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:49:16.729512",
    "generation_time": 6.3660852909088135,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\virtual_world_finals\\adjacent_and_consecutive",
    "problem_name": "Adjacent and Consecutive",
    "python_code": "def main():\n    T = int(input()) # number of test cases\n    for i in range(1, T+1):\n        N = int(input()) # number of tiles and cells on the board\n        mistakes_A = 0\n        mistakes_B = 0\n        \n        moves = []\n        for j in range(N):\n            M, C = map(int, input().split())\n            moves.append((M,C)) # collect all the moves\n            \n        for j in range(1, len(moves)-1):\n            if (moves[j][0] == moves[j-1][0]+1 and abs(moves[j][1] - moves[j-1][1]) == 1) or \\\n               (moves[j][0] == moves[j+1][0]-1 and abs(moves[j][1] - moves[j+1][1]) == 1):\n                mistakes_A += 1 # mistake for A if two adjacent tiles are placed next to each other in a wrong way\n            elif (moves[j][0] == moves[j-1][0]+1 and abs(moves[j][1] - moves[j+1][1]) != 1) or \\\n                 (moves[j][0] == moves[j+1][0]-1 and abs(moves[j][1] - moves[j+1][1]) != 1):\n                mistakes_B += 1 # mistake for B if two adjacent tiles are not placed next to each other\n                \n        print(\"Case #{}: {} {}\".format(i, mistakes_A, mistakes_B))\n        \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:49:28.048339",
    "generation_time": 11.287713289260864,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\virtual_world_finals\\hexacoin_jam",
    "problem_name": "Hexacoin Jam",
    "python_code": "def main():\n    T = int(input())\n    for i in range(1, T+1):\n        N, D = map(int, input().split())\n        S, E = input(), input()\n        L = [input() for _ in range(N)]\n        count = 0\n        total = 0\n        for j in range(2**D):\n            if all(S <= hex(j)[-1] < E for j in range(N)):\n                count += 1\n            total += 1\n        y, z = count, total\n        print(\"Case #{}: {} {}\".format(i, y/z))",
    "generated_at": "2025-05-03T20:49:34.283846",
    "generation_time": 4.081662893295288,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\virtual_world_finals\\musical_cords",
    "problem_name": "Musical Cords",
    "python_code": "import math\nfrom itertools import combinations\n\ndef distance(i, j):\n    return round((2 * math.pi * R) / N * abs(j - i), 9)\n\nT = int(input())\nfor t in range(1, T + 1):\n    N, R, K = map(int, input().split())\n    D = [tuple(map(int, input().split())) for _ in range(N)]\n    D.sort(key=lambda x: x[0])\n    cords = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if abs(D[i][0] - D[j][0]) % (360 * 10**9) < 5:\n                cord_length = distance(D[i][0], D[j][0]) + D[i][1] + D[j][1]\n                cords.append((cord_length, i, j))\n    cords.sort(reverse=True)\n    print(\"Case #{}: {}\".format(t), end=\"\")\n    for cord in cords[:K]:\n        print(\" {:.9f}\".format(cord[0]), end=\"\")\n    print()",
    "generated_at": "2025-05-03T20:49:43.604628",
    "generation_time": 9.299455642700195,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\virtual_world_finals\\pack_the_slopes",
    "problem_name": "Pack the Slopes",
    "python_code": "# Solution starts here\nT = int(input()) # number of test cases\nfor i in range(1, T+1):\n    N = int(input()) # number of rest points\n    slopes = []\n    for j in range(N-1):\n        Ui, Vi, Si, Ci = map(int, input().split())\n        slopes.append((Ui, Vi, Si, Ci))\n    \n    max_skiers = 0\n    min_expense = float('inf')\n    \n    for j in range(N-1):\n        for k in range(j+1, N):\n            for l in range(k+1, N):\n                skiers = [0] * (N+1) # initialize an array of zeros to keep track of the number of skiers on each slope\n                expense = 0\n                \n                # traverse all possible combinations of slopes from rest point j to k and then from k to l, adding up their costs and bounties\n                for m in range(j+1):\n                    if m == k:\n                        skiers[m] += 1\n                        expense += Ci * Si # add the cost of slope j->k\n                    else:\n                        expense -= slopes[m][3] # subtract the bounty of each intermediate slope\n                for n in range(k+1, l):\n                    if n == k or n == l:\n                        skiers[n] += 1\n                        expense += Ci * Si # add the cost of slope k->l\n                    else:\n                        expense -= slopes[n][3] # subtract the bounty of each intermediate slope\n                for o in range(k+1, l):\n                    skiers[o] += 1\n                    if o == l:\n                        expense += Ci * Si # add the cost of slope k->l\n                    else:\n                        expense -= slopes[o][3] # subtract the bounty of each intermediate slope\n                skiers[l] += 1\n                \n                # update maximum number of skiers and minimum expense\n                max_skiers = max(max_skiers, sum(skiers))\n                min_expense = min(min_expense, expense)\n    \n    print(\"Case #{}: {} {}\".format(i, max_skiers, -min_expense)) # output the result for case i\n# Solution ends here",
    "generated_at": "2025-05-03T20:49:59.653126",
    "generation_time": 16.039367198944092,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\virtual_world_finals\\replace_all",
    "problem_name": "Replace All",
    "python_code": "import sys\n\ndef main():\n    T = int(input())\n    for i in range(T):\n        S, N = input(), int(input())\n        replacements = [tuple(map(str, input().split())) for _ in range(N)]\n        max_chars = 0\n        \n        for p1, p2 in replacements:\n            max_chars += len([c for c in S if c not in p1]) + 1\n            S = S.replace(p1, p2)\n            \n        print(\"Case #{}: {}\".format(i+1, max_chars))\n        \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:50:04.867669",
    "generation_time": 5.204488277435303,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\qualification_round\\cheating_detection",
    "problem_name": "Cheating Detection",
    "python_code": "import math\n\ndef sigmoid(x):\n    return 1 / (1 + math.exp(-x))\n\ndef main():\n    T = int(input())\n    P = float(input())\n    for i in range(T):\n        correct_answers = []\n        cheater = -1\n        players = [[] for _ in range(100)]\n        for j in range(1, 101):\n            skill_levels = list(map(float, input().split()))\n            question_difficulty = float(input())\n            cheater_probability = sum([sigmoid(skill - question_difficulty) for skill in skill_levels]) / 100\n            if random.random() < cheater_probability:\n                cheater = j\n            else:\n                correct_answers.extend([int(x) for x in input().split()])\n        for player, answers in enumerate(players):\n            if sum(1 for answer in correct_answers[:j] if answer == 0) / len(correct_answers[:j]) >= P:\n                cheater = player + 1\n                break\n        print(\"Case #{}: {}\".format(i+1, cheater))\n            \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:50:13.255407",
    "generation_time": 8.370729207992554,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\qualification_round\\median_sort",
    "problem_name": "Median Sort",
    "python_code": "import sys\nfrom random import randint\n\ndef find_order(n, q):\n    # Generate T} lists of n elements randomly\n    lists = [sorted([randint(1, 2*n) for _ in range(n)] for i in range(t)]\n    \n    # Process each test case\n    for i in range(t):\n        # Initialize the list to be sorted\n        unsorted_list = lists[i]\n        \n        # Keep track of the current order, assume it is not reversed\n        order = [x-1 for x in range(n+1)]\n        \n        # Track how many questions have been asked so far\n        num_questions_asked = 0\n        \n        while num_questions_asked < q:\n            # Pick three distinct indices to compare\n            a, b, c = randint(1, n), randint(1, n), randint(1, n)\n            while (a == b or a == c or b == c):\n                a, b, c = randint(1, n), randint(1, n), randint(1, n)\n            \n            # Ask the judge for the median of these three elements\n            print(f\"{a} {b} {c}\")\n            sys.stdout.flush()\n            answer = int(input())\n            \n            if answer == -1:\n                break\n            num_questions_asked += 1\n            \n            # Update the order of the elements based on the response\n            if a == answer or b == answer:\n                order[a], order[b] = b, a\n            else:\n                order[c] = n-1\n        \n        # Sort the remaining elements using the updated order\n        sorted_list = [unsorted_list[order.index(x)] for x in range(n)]\n        \n        # Print the final answer and wait for judge's response\n        print(\" \".join([str(x) for x in sorted_list]))\n        sys.stdout.flush()\n        result = int(input())\n        \n        if result == -1:\n            break\n    \n    return\n\n# Read input from the testing tool\nt, n, q = map(int, input().split())\nfind_order(n, q*t)",
    "generated_at": "2025-05-03T20:50:31.262307",
    "generation_time": 14.059239149093628,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\qualification_round\\moons_and_umbrellas",
    "problem_name": "Moons and Umbrellas",
    "python_code": "import sys\n\ndef min_copyright_cost(x, y, s):\n    cost = 0\n    for i in range(len(s) - 1):\n        if s[i] == '?' and (s[i:i+2] == \"CJ\" or s[i:i+2] == \"JC\"):\n            if s[i+1] == '?':\n                cost += x + y\n            else:\n                cost += min(x, y)\n    return cost\n\ndef main():\n    test_cases = int(input())\n    for i in range(test_cases):\n        x, y, s = map(int, input().split())\n        print(\"Case #%d: %d\" % (i+1, min_copyright_cost(x, y, s)) \n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:50:37.362565",
    "generation_time": 6.074079751968384,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\qualification_round\\reversort",
    "problem_name": "Reversort",
    "python_code": "import sys\n\nT = int(input())\nfor i in range(1, T+1):\n    N = int(input())\n    L = list(map(int, input().split()))\n    total_cost = 0\n    for j in range(N-1, 0, -1):\n        index = L.index(min(L[j:]) + j)\n        L = L[:index+1][::-1] + L[index+1:]\n        total_cost += (index+1)\n    print(\"Case #{}: {}\".format(i, total_cost))",
    "generated_at": "2025-05-03T20:50:42.000467",
    "generation_time": 4.620684385299683,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\qualification_round\\reversort_engineering",
    "problem_name": "Reversort Engineering",
    "python_code": "import sys\nfrom collections import defaultdict\n\ndef reversort(n, c):\n    if n == 1 and c != 0:\n        return \"IMPOSSIBLE\"\n    elif c < n - 1 or c > (n * (n-1) // 2):\n        return \"IMPOSSIBLE\"\n    \n    result = []\n    for i in range(1, n+1):\n        if not result:\n            result.append(i)\n        \n        elif len(result) == c - (n-i):\n            result.insert(0, i)\n        \n        else:\n            result.append(i)\n    \n    return \" \".join([str(x) for x in result] if len(set(result)) == n else \"IMPOSSIBLE\"\n\ndef main():\n    t = int(input())\n    for i in range(1, t+1):\n        n, c = map(int, input().split())\n        print(\"Case #{}: {}\".format(i, reversort(n, c)) if len(reversort(n, c)) != 1 else \"IMPOSSIBLE\")\n\nif __name__ == '__main__':\n    main()",
    "generated_at": "2025-05-03T20:50:51.130334",
    "generation_time": 9.117625713348389,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\round_1a\\append_sort",
    "problem_name": "Append Sort",
    "python_code": "import sys\r\n\r\nsys.setrecursionlimit(10**6)\r\n\r\ndef min_operations(lst):\r\n    n = len(lst)\r\n    if n == 1:\r\n        return lst[0]\r\n    elif n == 2:\r\n        if lst[0] < lst[1]:\r\n            return lst[1] - lst[0]\r\n        else:\r\n            return 0\r\n    else:\r\n        dp = [0]*n\r\n        for i in range(n):\r\n            dp[i] = float('inf')\r\n        dp[0] = 0\r\n        dp[1] = lst[1] - lst[0] if lst[1] > lst[0] else 0\r\n        for i in range(2, n):\r\n            for j in range(i-1, -1, -1):\r\n                if lst[j] < lst[i]:\r\n                    dp[i] = min(dp[i], dp[j]+(lst[i]-lst[j])+1)\r\n        return dp[-1]\r\n\r\nT = int(input())\r\nfor i in range(1, T+1):\r\n    N = int(input())\r\n    lst = list(map(int, input().split()))\r\n    print(\"Case #%d: %d\" % (i, min_operations(lst))\r\n\r\n# Time Complexity : O(N^2)",
    "generated_at": "2025-05-03T20:51:00.711329",
    "generation_time": 9.572365522384644,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\round_1a\\hacked_exam",
    "problem_name": "Hacked Exam",
    "python_code": "import fractions\nfrom collections import Counter\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\n\ndef get_gcd_lcm(scores):\n    gcd_value = 1\n    lcm_value = 1\n    for score in scores:\n        gcd_value = gcd(gcd_value, score[0])\n        lcm_value = lcm(lcm_value, score[1])\n    return (gcd_value, lcm_value)\n\ndef get_expected_score(answers, scores):\n    correct_answers = [char for char in answers if char == 'T']\n    expected_score = len(correct_answers) / sum([1 for score in scores if score[0] >= len(correct_answers)])\n    return expected_score\n\ndef main():\n    T = int(input())\n    for i in range(1, T + 1):\n        N, Q = map(int, input().split())\n        students = []\n        for _ in range(N):\n            A, S = input(), int(input())\n            students.append((A, S))\n        \n        scores = [Counter([student[0][i] for student in students]) for i in range(Q)]\n        \n        gcd_value, lcm_value = get_gcd_lcm(scores)\n        expected_score = 0\n        for score in scores:\n            expected_score += int((score['T'] * lcm_value / gcd_value) * (Q - sum(score.values())) + len(correct_answers))\n        \n        print(\"Case #%d: %s %s/%s\" % (i, ''.join(['T' for _ in range(expected_score)]), lcm_value // gcd_value) if expected_score >= 0 else \"Case #%d: impossible\" % i)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:51:14.501115",
    "generation_time": 13.771703481674194,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\round_1a\\prime_time",
    "problem_name": "Prime Time",
    "python_code": "def prime_time():\n    T = int(input())\n    for i in range(T):\n        M = int(input())\n        primes = []\n        counts = []\n        for _ in range(M):\n            P, N = map(int, input().split())\n            primes.append(P)\n            counts.append(N)\n        # check if there is a valid split of cards\n        def is_valid_split():\n            sum_counts = sum(counts)\n            for i in range(M):\n                for j in range(i+1, M):\n                    left_sum = primes[i] * counts[i]\n                    right_product = 1\n                    for k in range(j, M):\n                        right_product *= primes[k] ** counts[k]\n                    if left_sum == right_product:\n                        return True\n            return False\n        \n        # find the maximum score of a valid split\n        def max_score():\n            max_score = 0\n            for i in range(M):\n                for j in range(i+1, M):\n                    left_sum = primes[i] * counts[i]\n                    right_product = 1\n                    for k in range(j, M):\n                        right_product *= primes[k] ** counts[k]\n                    if left_sum == right_product:\n                        max_score = max(max_score, left_sum)\n            return max_score\n        \n        # main logic\n        if is_valid_split():\n            print(\"Case #{}: {}\".format(i+1, max_score()))\n        else:\n            print(\"Case #{}: 0\".format(i+1))\n            \nprime_time()",
    "generated_at": "2025-05-03T20:51:25.725335",
    "generation_time": 11.211680889129639,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\round_1b\\broken_clock",
    "problem_name": "Broken Clock",
    "python_code": "import math\ndef calculate_time(A, B, C):\n    h = (B - A) / 3600 * 12 % 12\n    m = (C - B) / 60 % 60\n    s = (C - A) / 720 % 60\n    n = ((C - A) % 720) * 1e9 // 720 % 1e9\n    return f\"Case #{case+1}: {int(h)} {int(m)} {int(s)} {int(n)}\"\n    \nT = int(input())\nfor case in range(T):\n    A, B, C = map(float, input().split())\n    print(calculate_time(A, B, C))",
    "generated_at": "2025-05-03T20:51:31.739757",
    "generation_time": 5.966059923171997,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\round_1b\\subtransmutation",
    "problem_name": "Subtransmutation",
    "python_code": "import sys\n\ndef alchemy_spell(N, A, B, U):\n    if max(U) < N:\n        return \"IMPOSSIBLE\"\n    \n    for i in range(1, N+1):\n        if sum([u for u in U if u >= i]) > 0 and (i - A) <= 0:\n            continue\n        elif sum([u for u in U if u >= i]) < 0:\n            return \"IMPOSSIBLE\"\n        else:\n            return i\n\ndef main():\n    T = int(input())\n    \n    for t in range(1, T+1):\n        N, A, B = map(int, input().split())\n        U = list(map(int, input().split()))\n        \n        result = alchemy_spell(N, A, B, U)\n        \n        print(\"Case #{}: {}\".format(t, result))\n    \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:51:47.473790",
    "generation_time": 7.333284139633179,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\round_1c\\closest_pick",
    "problem_name": "Closest Pick",
    "python_code": "def main():\n    T = int(input())\n    for i in range(T):\n        N, K = map(int, input().split())\n        P_set = set(map(int, input().split()))\n        max_win_prob = 0.0\n        for a in range(1, K+1):\n            for b in range(a+1, K+1):\n                if len(P_set) == N:\n                    win_prob = (N/K)**2\n                else:\n                    P_set.add(a)\n                    P_set.add(b)\n                    win_prob = ((len(P_set)-1)/K)**2 + 2*(a==b)*((N+1)/K)**2 - (2*a==b)*((N-1)/K)**2\n                max_win_prob = max(max_win_prob, win_prob)\n        print(\"Case #%d: %.6f\" % (i+1, max_win_prob))",
    "generated_at": "2025-05-03T20:51:54.387222",
    "generation_time": 6.885533571243286,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\round_1c\\double_or_noting",
    "problem_name": "Double or NOTing",
    "python_code": "from collections import deque\ndef main():\n    T = int(input())\n    \n    for i in range(1, T+1):\n        S, E = input().split()\n        \n        if len(S) > 8 or len(E) > 8 or (len(S) == 1 and S[0] != '0') or (len(E) == 1 and E[0] != '0'):\n            print(\"Case #{}: IMPOSSIBLE\".format(i))\n        else:\n            queue = deque()\n            queue.append((S, 0))\n            \n            while queue:\n                s, count = queue.popleft()\n                \n                if s == E:\n                    print(\"Case #{}: {}\".format(i, count)\n                        break\n                    \n                for operation in [\"NOT\", \"DOUBLE\"]:\n                    new_s = apply_operation(s, operation)\n                    if new_s not in queue and len(new_s) <= 8:\n                        queue.append((new_s, count+1))\n                        \n            else:\n                print(\"Case #{}: IMPOSSIBLE\".format(i))\n                    \ndef apply_operation(binary, operation):\n    binary = int(binary, 2)\n    if operation == \"NOT\":\n        return format(~binary & ((1 << len(binary)), 'b')\n    elif operation == \"DOUBLE\":\n        return format((binary<<1), 'b')\n    \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:52:04.715379",
    "generation_time": 10.317309141159058,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\round_1c\\roaring_years",
    "problem_name": "Roaring Years",
    "python_code": "t = int(input()) # number of test cases\r\nfor i in range(1, t+1):\r\n    y = int(input())\r\n    z = y + 1\r\n    found_roaring_year = False\r\n    while not found_roaring_year:\r\n        if str(z) == ''.join([str(j) for j in range(y+1, z)]): # check if the decimal writing of z is concatenation of two or more consecutive integers in increasing order and without leading zeroes\r\n            print(\"Case #{}: {}\".format(i, z))\r\n            found_roaring_year = True\r\n        else:\r\n            z += 1\r\n    \r\n# Example input:\r\n# 3\r\n# 2021\r\n# 2019\r\n# 5678\r\n\r\n# Output:\r\n# Case #1: 2022\r\n# Case #2: 2024\r\n# Case #3: 5680",
    "generated_at": "2025-05-03T20:52:11.250069",
    "generation_time": 6.5239808559417725,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\round_2\\hidden_pancakes",
    "problem_name": "Hidden Pancakes",
    "python_code": "import math\nMOD = 10**9 + 7\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\n\ndef solve():\n    test_cases = int(input())\n    \n    for i in range(1, test_cases + 1):\n        n = int(input())\n        visible_pancakes = list(map(int, input().split()))\n        \n        result = 1\n        for j in range(n - 2, -1, -1):\n            if visible_pancakes[j] > visible_pancakes[j + 1]:\n                result *= lcm(visible_pancakes[j], result) // visible_pancakes[j + 1]\n        \n        print(\"Case #{}: {}\".format(i, result % MOD))\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T20:52:18.371657",
    "generation_time": 7.094010353088379,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\round_2\\matrygons",
    "problem_name": "Matrygons",
    "python_code": "import math\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return abs(a * b) // gcd(a, b)\n\ndef matrygon_sides(N):\n    result = 0\n    for i in range(1, N + 1):\n        if N % i == 0:\n            lcm_val = lcm(i, result)\n            gcd_val = gcd(i, result)\n            if (N // i) * i > result and gcd_val <= 2 * i:\n                result = lcm_val\n    return result\n\ndef main():\n    T = int(input())\n    for t in range(1, T + 1):\n        N = int(input())\n        print(\"Case #\" + str(t) + \": \" + str(matrygon_sides(N)))\n        \nif __name__ == '__main__':\n    main()",
    "generated_at": "2025-05-03T20:52:25.007176",
    "generation_time": 6.622066497802734,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\round_2\\minimum_sort",
    "problem_name": "Minimum Sort",
    "python_code": "def main():\n    T = int(input())\n    N = int(input())\n    for t in range(T):\n        exchange_count = 0\n        swaps = []\n        min_range = {}\n        \n        def get_minimum_in_range(i, j):\n            nonlocal exchange_count\n            nonlocal min_range\n            \n            if i > j:\n                return -1\n            \n            if (i, j) in min_range:\n                return min_range[(i, j)]\n            \n            exchange_count += 1\n            print(f\"D {i} {j}\", flush=True)\n            response = int(input())\n            if response == -1:\n                exit()\n            \n            if response < i or response > j:\n                return get_minimum_in_range(i, j)\n            \n            min_range[(i, j)] = response\n            return response\n        \n        def swap(i, j):\n            nonlocal exchange_count\n            print(f\"S {i} {j}\", flush=True)\n            input()\n            exchange_count += 1\n            \n        def sort():\n            for i in range(N-1):\n                min_pos = get_minimum_in_range(i, N-1)\n                \n                if min_pos == -1:\n                    exit()\n                \n                if i < min_pos:\n                    swap(i, min_pos)\n        \n        sort()\n        print(\"DONE\")\n        input()\n        \nmain()",
    "generated_at": "2025-05-03T20:52:36.324655",
    "generation_time": 9.554413795471191,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\round_2\\retiling",
    "problem_name": "Retiling",
    "python_code": "def retile_floor():\n    pass",
    "generated_at": "2025-05-03T20:52:37.331560",
    "generation_time": 0.9366381168365479,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\round_3\\binary_search_game",
    "problem_name": "Binary Search Game",
    "python_code": "for _ in range(int(input())):\n    N, M, L = map(int, input().split())\n    A = list(map(int, input().split()))\n    board_size = 2**L\n    scores = []\n    \n    for i in range(M):\n        referee = [i+1]*N if i < M-1 else [N]\n        alice_score = 0\n        bob_score = 0\n        \n        for j in range(L//2):\n            alice_choices = []\n            bob_choices = []\n            \n            for k in range(board_size // 2**(j+1)):\n                if A[k] > A[-1-k]:\n                    alice_choices.append((A[k], A[-1-k]))\n                else:\n                    bob_choices.append((A[k], A[-1-k]))\n            \n            for a, b in alice_choices:\n                if a < referee[0]:\n                    alice_score += b\n                else:\n                    bob_score += a\n            \n            board = [x for x in A if x not in alice_choices and x not in bob_choices]\n            board.sort(reverse=True)\n            \n        scores.append((alice_score + bob_score) % (10**9+7))\n    \n    print(\"Case #%d: %d\" % (_+1, sum(scores)))",
    "generated_at": "2025-05-03T20:52:47.665363",
    "generation_time": 10.31813907623291,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\round_3\\build-a-pair",
    "problem_name": "Build-A-Pair",
    "python_code": "def main():\r\n    T = int(input())\r\n    for i in range(1,T+1):\r\n        D = input()\r\n        digits = sorted([int(d) for d in set(D)]\r\n        max_digit = digits[-1] #get the maximum digit\r\n        min_diff = float('inf')\r\n        for j in range(1,max_digit+1):\r\n            for k in range(j+1,max_digit+1):\r\n                first = int(\"\".join([str(d) for d in digits if d>=k])\r\n                second = int(\"\".join([str(d) for d in digits if d<k])\r\n                diff = abs(first-second)\r\n                min_diff = min(min_diff, diff)\r\n        print(\"Case #{}: {}\".format(i, min_diff))",
    "generated_at": "2025-05-03T20:52:53.118892",
    "generation_time": 5.439929962158203,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\round_3\\fence_design",
    "problem_name": "Fence Design",
    "python_code": "n = int(input()) # number of poles\nfor i in range(1, n+1): \n    x_i, y_i = map(int, input().split())\n    poles[x_i][y_i] = True \nm = int(input()) # existing fences\np_k, q_k = list(map(int, input().split())) \nfor j in range(m-1):\n    p_j, q_j = map(int, input().split())\n    for k in range(p_j, q_j+1):\n        poles[x_i][y_i] = True \n    for l in range(q_k, p_k-1, -1):\n        poles[x_i][y_i] = True \n\nmax_fences = [] # list of new fences to add\ncount = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        if not (poles[i][j] or poles[j][i]):\n            max_fences.append((i, j))\n            count += 1\nprint(\"Case #\", i+1, \": \", count)\nfor fence in max_fences:\n    print(fence[0], fence[1])",
    "generated_at": "2025-05-03T20:53:01.564575",
    "generation_time": 8.425589799880981,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\round_3\\square_free",
    "problem_name": "Square Free",
    "python_code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(10**6)\n\ndef valid_matrix(r, c, rows, cols):\n    if r == 0 and c == 0:\n        return True\n    if r < 0 or c < 0:\n        return False\n    if not (rows[r] or cols[c]):\n        return False\n    rows[r] -= 1\n    cols[c] -= 1\n    if valid_matrix(r-1, c, rows, cols) or valid_matrix(r, c-1, rows, cols):\n        return True\n    else:\n        rows[r] += 1\n        cols[c] += 1\n        return False\n\ndef print_matrix(matrix, r, c, rows, cols):\n    for i in range(r):\n        row = []\n        for j in range(c):\n            if matrix[(i,j)]:\n                row.append('/')\n            else:\n                row.append('\\\\')\n        print(\"\".join(row))\n\ndef solve_case(t, r, c, rows, cols):\n    matrix = defaultdict(bool)\n    for i in range(r):\n        for j in range(c):\n            if valid_matrix(i,j,rows,cols):\n                matrix[(i,j)] = True\n            else:\n                matrix[(i,j)] = False\n    print(\"Case #%d:\" % (t+1), \"POSSIBLE\")\n    print_matrix(matrix, r, c, rows, cols)\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        r,c = map(int, input().split())\n        rows = list(map(int, input().strip().split()))[:r]\n        cols = list(map(int, input().split())[:c])\n        solve_case(i, r, c, rows, cols)\nmain()",
    "generated_at": "2025-05-03T20:53:14.473090",
    "generation_time": 12.895858526229858,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\world_finals\\cutting_cake",
    "problem_name": "Cutting Cake",
    "python_code": "import fractions\n\ndef get_enjoyment(x, y, a, b):\n    return abs((x * (a + b) / 2) - x * a) if x <= 0 else abs((W - x) * (b - a) / 2)\n\nT = int(input())\nfor i in range(1, T + 1):\n    N, W, H = map(int, input().split())\n    P, Q, R, S = map(int, input().split())\n    XYAB = [tuple(map(float, input().split())) for _ in range(N)]\n    \n    left_enjoyment = 0.0\n    right_enjoyment = 0.0\n    min_diff = float('inf')\n    for x in range(-1, W - max(P, R) + 2):\n        patches = []\n        for X, Y, A, B in XYAB:\n            if (X + P) * Q / 2 <= y < (X + R) * S / 2:\n                left_enjoyment += get_enjoyment(x - X, Y, A, B)\n            elif x >= (X + P) and x <= W - max(P, R):\n                right_enjoyment += get_enjoyment(x - (W - X), H - Y - Q, A, B)\n        diff = abs(left_enjoyment - right_enjoyment)\n        if diff < min_diff:\n            min_diff = diff\n    \n    print(\"Case #{}: {}/{}\".format(i, fractions.Fraction(min_diff).limit_denominator()))",
    "generated_at": "2025-05-03T20:53:26.713210",
    "generation_time": 12.2079439163208,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\world_finals\\divisible_divisions",
    "problem_name": "Divisible Divisions",
    "python_code": "def count_divisible(s: str, d: int) -> int:\n    def is_divisible(substring: str) -> bool:\n        return int(substring) % d == 0\n    \n    n = len(s)\n    result = 0\n    for i in range(1 << (n-1):\n        if not is_divisible(s[i]) and not is_divisible(s[i+1:i+2]):\n            continue\n        result += 1\n    \n    return result % (10**9 + 7)\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        s, d = input().split()\n        print(f\"Case #{i+1}: {count_divisible(s, int(d))}\")\n        \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:53:32.902586",
    "generation_time": 6.137992858886719,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\world_finals\\infinitree",
    "problem_name": "Infinitree",
    "python_code": "Here's a Python program that solves the problem:",
    "generated_at": "2025-05-03T20:53:35.101514",
    "generation_time": 0.43435120582580566,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\world_finals\\ropes",
    "problem_name": "Ropes",
    "python_code": "Here's a Python program based on the given description:",
    "generated_at": "2025-05-03T20:53:39.637687",
    "generation_time": 0.42201781272888184,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2021\\world_finals\\slide_circuits",
    "problem_name": "Slide Circuits",
    "python_code": "def main():\n    T = int(input())  # number of test cases\n    \n    for i in range(T):\n        B, S, N = map(int, input().split())  # number of buildings and slides, and operations to perform\n        \n        slides = [[False] * (S + 1) for _ in range(B + 1)]  # initialize all slides as disabled\n        \n        for j in range(N):\n            X, Y = map(int, input().split())  # read slide x and y values\n            if X < Y:  # enable the slide from building X to building Y\n                for k in range(X * S // X, (Y * S + 1) // Y + 1, S):  # iterate over all multiples of M between L and R\n                    slides[X][k] = True\n            else:  # disable the slide from building X to building Y\n                for k in range(X * S // X, (Y * S + 1) // Y + 1, S):\n                    slides[X][k] = False\n        \n        fun_slides = []\n        for j in range(S):\n            count = sum([slides[b][j] for b in range(B + 1)])  # count the number of enabled slides from building j\n            if count == B - 1:  # j is a circuit start\n                fun_slides.append(j * S // (B - 1))  # enable this slide to make the state fun\n        \n        print(\"Case #{}: {}\".format(i + 1, \" \".join([str(x) if x else \"X\" for x in fun_slides]))  # output the result\n    \n    return 0\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:53:52.463698",
    "generation_time": 12.81410551071167,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\qualification_round\\3d_printing",
    "problem_name": "3D Printing",
    "python_code": "import sys\n\ndef main():\n    T = int(input())\n    \n    for i in range(T):\n        C_i, M_i, Y_i, K_i = map(int, input().split())\n        \n        if C_i + M_i + Y_i <= 10**6 and K_i >= 10**6:\n            c = 10**6 - (C_i + M_i + Y_i)\n            print(f\"Case #{i+1}: {c} {M_i} {Y_i} {K_i}\")\n        else:\n            print(f\"Case #{i+1}: IMPOSSIBLE\")\n    \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:56:59.214224",
    "generation_time": 5.629324436187744,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\qualification_round\\chain_reactions",
    "problem_name": "Chain Reactions",
    "python_code": "def main():\n    T = int(input())\n    for i in range(1, T+1):\n        N = int(input())\n        F = list(map(int, input().split()))\n        P = list(map(int, input().split()))\n        max_fun = 0\n        visited = [False] * N\n        for j in range(N):\n            if not visited[j]:\n                chain_fun = []\n                current_module = j\n                while P[current_module] != -1:\n                    visited[current_module] = True\n                    chain_fun.append(F[current_module])\n                    current_module = P[current_module]\n                max_fun += max(chain_fun)\n        print(\"Case #%d: %d\" % (i, max_fun))\nmain()",
    "generated_at": "2025-05-03T20:57:05.197212",
    "generation_time": 5.958575010299683,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\qualification_round\\d1000000",
    "problem_name": "d1000000",
    "python_code": "import sys\nfrom itertools import combinations_with_replacement\nfrom collections import defaultdict\n\ndef longest_straight(dice):\n    sides = {side for die, side in dice}\n    max_length = 0\n    for i in range(1, len(sides) - max(dice)+1):\n        combos = combinations_with_replacement([die for die, _ in dice], i)\n        for combo in combos:\n            straight = defaultdict(int)\n            for die, side in dice:\n                if die in combo and side < 10**6:\n                    straight[side] += 1\n            if max_length < len(straight):\n                max_length = max(max_length, sum(count >= i for count in straight.values())+1)\n        if max_length == len(dice):\n            break\n    return max_length\n\ndef main():\n    T = int(input())\n    cases = [list(map(int, input().split())) for _ in range(T)]\n    for i, (N, *S) in enumerate(cases, 1):\n        dice = [(i, s) for i, s in enumerate(S, 1)]\n        print(f\"Case #{i}: {longest_straight(dice)}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:57:14.048508",
    "generation_time": 8.822181940078735,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\qualification_round\\punched_cards",
    "problem_name": "Punched Cards",
    "python_code": "import sys\r\n\r\ndef draw_punched_card(R,C):\r\n    for i in range(1,R+1):\r\n        if i==1:\r\n            print(\".\"*(2*C-1) + \"+\")\r\n        else:\r\n            print(\".|\" + \".\"*(C-2) + \"+\")\r\n        \r\n        for j in range(1,C):\r\n            if j<C:\r\n                print(\".-+\" + \"-\"*(C-2), end=\"+\")\r\n    print()\r\n    \r\nT = int(input())\r\nfor i in range(1,T+1):\r\n    R, C = map(int, input().split())\r\n    print(\"Case #%d:\" %i)\r\n    draw_punched_card(R-2,C-2)<|im_sep|>",
    "generated_at": "2025-05-03T20:57:19.635348",
    "generation_time": 5.576581001281738,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\qualification_round\\twisty_little_passages",
    "problem_name": "Twisty Little Passages",
    "python_code": "def main():\n    T = int(input())\n    for i in range(T):\n        N, K = map(int, input().split())\n        # initialize rooms with their number of passages\n        rooms = [[] for _ in range(N)]\n        for j in range(K+1):\n            R, P = map(int, input().split())\n            if j < K:\n                for k in range(P):\n                    room_to = int(input())\n                    rooms[R-1].append(room_to) # subtract 1 to index from 0 to N-1\n            else: # estimation operation\n                E = estimate_passages(rooms, K)\n                print(E)\n\ndef estimate_passages(rooms, K):\n    passages = 0\n    visited = set()\n    for i in range(K+1):\n        R, P = map(int, input().split())\n        if i < K: # walk through a passage and visit the connected room\n            room_to = random.choice(rooms[R-1]) # subtract 1 to index from 0 to N-1\n            visited.add(room_to)\n            passages += P - len(rooms[room_to-1]) + 1 # add number of new rooms visited minus the ones already visited\n        else: # estimation operation\n            return passages * 2 // 3, passages * 4 // 3\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:57:29.419362",
    "generation_time": 9.767997026443481,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\round_1a\\equal_sum",
    "problem_name": "Equal Sum",
    "python_code": "Here's a Python program based on the given description:",
    "generated_at": "2025-05-03T20:57:38.245138",
    "generation_time": 1.1955459117889404,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\round_1a\\weightlifting",
    "problem_name": "Weightlifting",
    "python_code": "def main():\n    T = int(input())\n    for i in range(1, T + 1):\n        E, W = map(int, input().split())\n        X = [list(map(int, input().split())) for _ in range(E)]\n        \n        min_ops = 0\n        stack = []\n        \n        for x in X:\n            for j in range(W):\n                if not stack or stack[-1] != j + 1:\n                    min_ops += 1\n                    stack.append(j + 1)\n                elif len(stack) > 0 and stack[-1] == j + 1:\n                    stack.pop()\n                    \n        print(\"Case #\" + str(i) + \": \" + str(min_ops))\n\nmain()",
    "generated_at": "2025-05-03T20:57:43.958888",
    "generation_time": 5.682082653045654,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\round_1b\\controlled_inflation",
    "problem_name": "Controlled Inflation",
    "python_code": "def main():\n    T = int(input())\n    for i in range(T):\n        N, P = map(int, input().split())\n        Xs = []\n        for _ in range(N):\n            Xs.append(list(map(int, input().split()))\n        min_presses = 0\n        current_pressure = 0\n        for j in range(P):\n            pressures = [Xs[k][j] for k in range(len(Xs))]\n            target_pressure = max(pressures)\n            diff = target_pressure - current_pressure\n            if diff > 0:\n                min_presses += diff\n                current_pressure += diff\n        print(\"Case #%d: %d\" % (i+1, min_presses))\n\nmain()",
    "generated_at": "2025-05-03T20:57:58.063872",
    "generation_time": 5.693950414657593,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\round_1b\\pancake_deque",
    "problem_name": "Pancake Deque",
    "python_code": "import collections\n\ndef max_customers(pancakes):\n    deque = collections.deque(pancakes)\n    total = 0\n    while len(deque) > 1:\n        if deque[0] >= min(deque[-1], deque[1]):\n            deque.popleft()\n        else:\n            deque.pop()\n        total += 1\n    return total + 1\n\ndef main():\n    num_cases = int(input())\n    for i in range(num_cases):\n        n = int(input())\n        pancakes = list(map(int, input().split()))\n        print(\"Case #{}: {}\".format(i+1, max_customers(pancakes))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:58:03.900905",
    "generation_time": 5.802849531173706,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\round_1c\\intranets",
    "problem_name": "Intranets",
    "python_code": "import random\nfrom fractions import Fraction\nfrom functools import reduce\nimport operator\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\n\ndef mod_inverse(n, p):\n    for i in range(p - 2, -1, -1):\n        if (n * i) % p == 1:\n            break\n    else:\n        raise ValueError(\"Inverse doesn't exist.\")\n    return i\n\ndef count_intranets(M, K):\n    total = reduce(operator.mul, range(1, M + 1), 1)\n    active_links = (M * (M - 1)) // 2\n    possible_priorities = [(i, j) for i in range(1, M + 1) for j in range(i+1, M + 1)]\n    active_combinations = [Fraction(sum([1 if random.randint(1, active_links) <= k else 0 for k in range(active_links)]) == K - 1 for _ in range(M * (M-1) // 2)]\n    count = sum(active_combinations)\n    return count / total\n\ndef compute_probability(M, K):\n    total = reduce(operator.mul, range(1, M + 1), 1)\n    active_links = (M * (M - 1)) // 2\n    possible_priorities = [(i, j) for i in range(1, M + 1) for j in range(i+1, M + 1)]\n    active_combinations = [Fraction(sum([1 if random.randint(1, active_links) <= k else 0 for k in range(active_links)]) == K - 1 for _ in range(total)]\n    count = sum(active_combinations)\n    probability = Fraction(count, total)\n    return (probability.numerator * mod_inverse(probability.denominator, 10**9 + 7)) % (10**9 + 7)\n\ndef main():\n    T = int(input())\n    for i in range(T):\n        M, K = map(int, input().split())\n        print(\"Case #{}: {}\".format(i+1, compute_probability(M, K))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:58:20.832906",
    "generation_time": 16.913994312286377,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\round_1c\\letter_blocks",
    "problem_name": "Letter Blocks",
    "python_code": "def main():\n    cases = int(input())\n    for i in range(1, cases+1):\n        num_towers = int(input())\n        towers = []\n        for j in range(num_towers):\n            towers.append(input().strip())\n        \n        def is_valid(towers):\n            for tower in towers:\n                if len(set(tower)) != len(towers[0]):\n                    return False\n            \n            for j in range(len(towers[0])):\n                current = towers[0][j]\n                for k in range(1, len(towers)):\n                    if current != towers[k][j]:\n                        return False\n            for tower in towers:\n                for j in range(len(tower)-1):\n                    if tower[j] == current and tower[j+1] != current:\n                        return False\n            \n            return True\n        \n        def build_mega_tower(towers):\n            result = []\n            for j in range(len(towers[0])):\n                if is_valid([tower[:j+1] for tower in towers]):\n                    result.append(towers[0][j])\n                else:\n                    break\n            \n            return \"\".join(result) if len(result) == num_towers*len(towers[0]) else \"IMPOSSIBLE\"\n        \n        print(\"Case #{}: {}\".format(i, build_mega_tower(towers))",
    "generated_at": "2025-05-03T20:58:31.422240",
    "generation_time": 10.535061120986938,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\round_1c\\squary",
    "problem_name": "Squary",
    "python_code": "import math\n\ndef is_squary(lst):\n    return sum([x**2 for x in lst]) == sum(lst)**2\n\ndef add_elements(lst, k):\n    if len(set(lst)) < len(lst):\n        lst = list(set(lst))  # remove duplicates to avoid adding the same integer multiple times\n    total_sum = sum(lst)\n    total_square = math.sqrt(total_sum**2 - sum([x**2 for x in lst])).is_integer() and k >= len(lst)\n    if total_square:\n        return [int(math.sqrt(total_sum**2 - sum([x**2 for x in lst))] * (len(lst) + 1))] * k\n    else:\n        return \"IMPOSSIBLE\"\n\nt = int(input())\nfor i in range(1, t+1):\n    n, k = map(int, input().split())\n    lst = list(map(int, input().split()))\n    if is_squary(lst) or len(set(lst)) < len(lst):  # check for squary and remove duplicates\n        print(\"Case #{}: {}\".format(i, add_elements(lst, k)) if not is_squary(lst) else \"IMPOSSIBLE\")\n    else:\n        print(\"Case #{}: IMPOSSIBLE\".format(i))",
    "generated_at": "2025-05-03T20:58:41.646786",
    "generation_time": 8.551377058029175,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\round_2\\i_o_bot",
    "problem_name": "I, O Bot",
    "python_code": "import sys\n\ndef main():\n    T = int(input())\n    for i in range(T):\n        N, C = map(int, input().split())\n        balls = []\n        for j in range(N):\n            x, s = map(int, input().split())\n            balls.append((x, s) if s == 1 else (-x, -s))\n        \n        balls.sort()\n        left_compartment = 0\n        right_compartment = 0\n        total_moves = 0\n        for ball in balls:\n            if ball[1] == 1:\n                if not left_compartment:\n                    total_moves += abs(ball[0]) + C\n                    left_compartment = ball[0]\n                else:\n                    total_moves += abs(left_compartment - ball[0]) * (C+1)\n                    left_compartment = 0\n            elif ball[1] == -1:\n                if not right_compartment:\n                    total_moves += abs(ball[0]) + C\n                    right_compartment = ball[0]\n                else:\n                    total_moves += abs(right_compartment - ball[0]) * (C+1)\n                    right_compartment = 0\n            elif left_compartment and not right_compartment:\n                total_moves += abs(left_compartment - ball[0]) + C\n                left_compartment = 0\n            else:\n                total_moves += abs(right_compartment - ball[0]) + C\n                right_compartment = 0\n        \n        print(\"Case #{}: {}\".format(i+1, total_moves))\n    \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:58:53.493039",
    "generation_time": 11.833690166473389,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\round_2\\saving_the_jelly",
    "problem_name": "Saving the Jelly",
    "python_code": "import math\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x1 - x2)**2 + (y1 - y2)**2)\n\ndef closest_sweet(children, sweets):\n    min_dist = float('inf')\n    closest_child = None\n    closest_sweets = []\n    for child in children:\n        dist = float('inf')\n        closest_jelly = None\n        for sweet in sweets:\n            if sweet != 1:\n                d = distance(children[child][0], children[child][1], sweets[sweet][0], sweets[sweet][1])\n                if d < dist:\n                    dist = d\n                    closest_jelly = sweet\n        if dist < min_dist or (dist == min_dist and len(closest_sweets) > 0 and child not in [x[0] for x in closest_sweets]):\n            min_dist = dist\n            closest_sweets = [(child, closest_jelly)]\n        elif dist == min_dist:\n            closest_sweets.append((child, closest_jelly))\n    return closest_sweets\n\ndef solve(children, sweets):\n    if len(closest_sweet(children, sweets)) > 1:\n        return \"IMPOSSIBLE\"\n    \n    order = []\n    for child in range(2, N+1):\n        dist = float('inf')\n        closest_jelly = None\n        for sweet in range(1, N+1):\n            if sweets[sweet] not in [x[1] for x in order]:\n                d = distance(children[child][0], children[child][1], sweets[sweet][0], sweets[sweet][1])\n                if d < dist:\n                    dist = d\n                    closest_jelly = sweet\n        order.append((child, closest_jelly))\n    \n    return \"POSSIBLE\\n\" + '\\n'.join([f\"Case #{i+1}: {x[0]} {x[1]}\" for i, x in enumerate(order)] if len(order) == N else \"IMPOSSIBLE\"\n\nT = int(input())\nfor t in range(1, T+1):\n    N = int(input())\n    \n    children = {}\n    sweets = {}\n    for i in range(N):\n        x, y = map(int, input().split())\n        children[i+1] = (x, y)\n        \n    for j in range(N+1):\n        x, y = map(int, input().split())\n        sweets[j+1] = (x, y)\n    \n    print(\"Case #{}: {}\".format(t), solve(children, sweets))",
    "generated_at": "2025-05-03T20:59:19.908101",
    "generation_time": 18.74478030204773,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\round_2\\spiraling_into_control",
    "problem_name": "Spiraling Into Control",
    "python_code": "import math\n\ndef find_shortcut(n):\n    shortcut = []\n    x, y = 1, n * n - 1\n    while x != y:\n        if x + 1 == y or y + 1 == x:\n            break\n        if (x % n) // (n - 1) == 0 and (y % n) // (n - 1) == 0:\n            shortcut.append((x, y))\n            return shortcut\n        elif (x % n) < (y % n):\n            x += math.ceil(n / 2) if n > 3 else 2\n            y -= math.ceil(n / 2) if n > 3 else 1\n        else:\n            x += math.floor(n / 2) if n > 3 else 2\n            y -= math.floor(n / 2) if n > 3 else 1\n    return shortcut\n\ndef main():\n    t = int(input())\n    \n    for i in range(t):\n        n, k = map(int, input().split())\n        \n        if k >= n * n - 1:\n            print(\"Case #{}: IMPOSSIBLE\".format(i + 1))\n        else:\n            shortcuts = find_shortcut(n)\n            \n            if len(shortcuts) < k:\n                print(\"Case #{}: {}\".format(i + 1, len(shortcuts))\n                for s in shortcuts[:k]:\n                    print(*s)\n            else:\n                print(\"Case #{}: IMPOSSIBLE\".format(i + 1))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:59:33.558526",
    "generation_time": 13.634152173995972,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\round_3\\duck_duck_geese",
    "problem_name": "Duck, Duck, Geese",
    "python_code": "import sys\nfrom itertools import combinations\n\ndef count_valid_choices(N, C, A, B, P):\n    def is_valid(choice):\n        counts = [0] * C\n        for i in range(len(choice)):\n            player = choice[i] - 1\n            color = P[player]\n            if choice[i+1] == N: # wrap around to beginning of list\n                player = 0\n            counts[color-1] += 1\n        return all([A[c] <= counts[c] <= B[c] for c in range(C)])\n\n    valid_choices = [list(combinations(range(N), i)) for i in range(2, N)]\n    valid_choices = sum([filter(is_valid, choices) for choices in valid_choices], [])\n    return len(valid_choices)\n\ndef main():\n    T = int(input())\n    for case in range(1, T+1):\n        N, C = map(int, input().split())\n        A = []\n        B = []\n        P = [0] * N # initialize with 0 to avoid index out of range errors\n        for i in range(C):\n            a, b = map(int, input().split())\n            A.append(a)\n            B.append(b)\n        P = list(map(int, input().split()))\n        print(\"Case #{}: {}\".format(case, count_valid_choices(N, C, A, B, P))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T20:59:45.153636",
    "generation_time": 9.864726781845093,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\round_3\\mascot_maze",
    "problem_name": "Mascot Maze",
    "python_code": "import sys\nfrom collections import defaultdict\n\ndef assign_mascots(N):\n    left_exits = list(map(int, input().split()))\n    right_exits = list(map(int, input().split()))\n    \n    # Create a graph to represent the maze\n    graph = {i: [left_exits[i], right_exits[i]] for i in range(N)}\n    \n    # Initialize dictionary of visited rooms and mascots\n    visited_rooms = defaultdict(set)\n    assigned_mascots = {}\n    \n    # Start at room 1 and recursively assign mascots to each connected component\n    def dfs(room, mascot):\n        # If we have already visited this room before, check if the mascot is valid\n        if room in visited_rooms[room]:\n            return assigned_mascots.get(room) == mascot\n        \n        # Mark room as visited and assign mascot to it\n        visited_rooms[room].add(mascot)\n        assigned_mascots[room] = mascot\n    \n        # Recurse on both exits with the same mascot\n        for exit in graph[room]:\n            if not dfs(exit, mascot):\n                return False\n        \n        # If we have visited all rooms in this component, return True\n        if len(visited_rooms) == N:\n            return True\n    \n    # Try each of the 13 possible mascots and check if they can be assigned to each connected component\n    for i, mascot in enumerate(\"ACDEHIJKMORST\"):\n        visited_rooms.clear()\n        assigned_mascots.clear()\n        \n        # Start at room 1 with the current mascot\n        if dfs(1, mascot):\n            return \"IMPOSSIBLE\" not in [assign_mascots(i+2) for i in range(N)]\n    \n    # If we reach here without returning, then no valid assignment was found\n    return \"IMPOSSIBLE\"\n        \n# Read input and process each test case\nT = int(input())\nfor t in range(1, T+1):\n    N = int(input())\n    \n    # Read the maze layout and check if it is possible to assign mascots without breaking rules\n    result = assign_mascots(N)\n    \n    print(\"Case #{}: {}\".format(t, result))",
    "generated_at": "2025-05-03T21:00:00.637171",
    "generation_time": 15.45909857749939,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\round_3\\revenge_of_gorosort",
    "problem_name": "Revenge of GoroSort",
    "python_code": "import random\nimport time\n\ndef sort_balls(arr):\n    n = len(arr)\n    assigned_colors = set()\n    while not all(i == arr[i-1] for i in range(1, n+1)):\n        colors = [random.choice(['red', 'blue', 'green']) for _ in range(n)]\n        assigned_colors |= set(colors)\n        color_dict = {color: [] for color in assigned_colors}\n        for i, ball in enumerate(arr):\n            color_dict[colors[i]].append(ball)\n        sorted_colors = [sorted(color_dict[color]) for color in assigned_colors]\n        arr = [ball for sublist in sorted_colors for ball in sublist]\n    return arr, len(assigned_colors), colors\n\ndef main():\n    T = int(input())\n    N = 100\n    K = 4500\n    bumps = []\n    \n    # Read test cases\n    for _ in range(T):\n        t_start = time.time()\n        \n        # Read input and sort balls\n        arr = list(map(int, input().split()))\n        sorted_arr, num_colors, colors = sort_balls(arr)\n        \n        # Check if time limit exceeded\n        if time.time() - t_start > 20:\n            print('Time Limit Exceeded')\n            exit()\n        \n        # Send output to judge\n        for color in colors:\n            print(color, end=' ')\n        print('\\n', flush=True)\n        \n        # Read bump result from judge\n        for _ in range(num_colors):\n            bumps.append(int(input()))\n    \n    # Check if memory limit exceeded\n    if len(bumps) > 1024 * 1024 * 1024:\n        print('Memory Limit Exceeded')\n        \nif __name__ == '__main__':\n    main()",
    "generated_at": "2025-05-03T21:00:14.297848",
    "generation_time": 13.62229323387146,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\round_3\\win_as_second",
    "problem_name": "Win As Second",
    "python_code": "# Read input for T test cases\nT = int(input())\nfor i in range(T):\n    # Read N for this case\n    N = int(input())\n    \n    # Generate tree edges\n    tree_edges = []\n    for j in range(N-1):\n        tree_edges.append((j+2, j+1))\n        \n    # Output tree edges\n    print(N-1)\n    for edge in tree_edges:\n        print(*edge)\n    \n    # Read M games to play on this tree\n    M = int(input())\n    \n    # Play M games\n    game_count = 0\n    while game_count < M and True:\n        # Ueli's turn\n        K = int(input())\n        \n        if K != N-1:\n            print(-1)\n            break\n        \n        A = list(map(int, input().split()))\n        for a in A[1:]:\n            if a not in tree_edges and (a,A[0]) not in tree_edges:\n                print(-1)\n                break\n            \n        # Vreni's turn - always choose the first vertex\n        print(N-2)\n        print(1)\n        \n        for j in range(2, N):\n            if (j, 1) not in tree_edges and (1,j) not in tree_edges:\n                print(-1)\n                break\n            \n        # Check if all vertices are red after Vreni's turn\n        is_red = [False]*N\n        is_red[0] = True\n        for a in A[1:]:\n            is_red[a-1] = True\n        \n        for edge in tree_edges:\n            if not (is_red[edge[0]-1] and is_red[edge[1]-1]):\n                break\n        else:\n            game_count += 1",
    "generated_at": "2025-05-03T21:00:31.545664",
    "generation_time": 12.713528633117676,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\world_finals\\goose_goose_ducks",
    "problem_name": "Goose, Goose, Ducks?",
    "python_code": "import math\nimport sys\nfrom collections import defaultdict\n\ndef distance(x1, y1, x2, y2):\n    return abs(x1 - x2) ** 2 + abs(y1 - y2) ** 2\n\ndef is_feasible(N, M, S, meetings, statements):\n    ducks = set()\n    geese = set(range(1, N+1))\n    for i in range(M):\n        xi, yi, ci = meetings[i]\n        for j in range(S):\n            ai, bi, ui, vi, di = statements[j]\n            if distance(xi, yi, ui, vi) <= ci ** 2:\n                ducks.add(ai)\n                geese.discard(ai)\n                ducks.discard(bi)\n                geese.discard(bi)\n    return len(ducks), len(geese)\n\ndef main():\n    T = int(input())\n    for i in range(1, T+1):\n        N, M, S = map(int, input().split())\n        meetings = [tuple(map(int, input().split())) for _ in range(M)]\n        statements = [(tuple(map(int, input().split())) for _ in range(S)]\n        min_ducks, max_geese = is_feasible(N, M, S, meetings, statements)\n        print(\"Case #{}: {}\".format(i, min_ducks))\n        \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T21:00:42.765196",
    "generation_time": 11.205342769622803,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\world_finals\\schrdinger_and_pavlov",
    "problem_name": "Schr\u00f6dinger and Pavlov",
    "python_code": "import sys\nsys.setrecursionlimit(10**6)\nMOD = 100000007\ndef count_configurations(n, s, tunnels):\n    def dfs(box, visited, cats):\n        if box == n:\n            return int(cats > 0 and all(visited))\n        for i in range(1, n+1):\n            if not visited[i] and (tunnels[i-1] == -1 or visited[tunnels[i-1]) and s[i-1] != 'C'):\n                return dfs(box + 1, visited[:i] + [True] + visited[i+1:], cats | (s[i-1] == 'C') << (i-1))\n        return 0\n    return sum(dfs(1, [False]*n, i) for i in range(2**n)) % MOD\n\ndef main():\n    t = int(input())\n    for test_case in range(t):\n        n = int(input())\n        s = input()\n        tunnels = list(map(int, input().split()))\n        cats = 0\n        for i in range(n):\n            if s[i] == 'C':\n                cats |= (1 << i)\n        result = count_configurations(n, s, tunnels)\n        print(\"Case #%d: %d\" % (test_case+1, result))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T21:00:54.630878",
    "generation_time": 11.852345943450928,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\world_finals\\slide_parade",
    "problem_name": "Slide Parade",
    "python_code": "import sys\nfrom collections import defaultdict\n\ndef find_route(buildings, slides):\n    visited = [False] * (len(buildings) + 1)\n    visited[0] = True\n    adjacency_list = {}\n    \n    for u, v in slides:\n        if u not in adjacency_list:\n            adjacency_list[u] = [v]\n        else:\n            adjacency_list[u].append(v)\n        \n        if v not in adjacency_list:\n            adjacency_list[v] = [u]\n        else:\n            adjacency_list[v].append(u)\n    \n    stack = [(1, 0)] # start at building 1 and take one step\n    while stack:\n        node, steps = stack.pop()\n        \n        if visited[node]:\n            continue\n        \n        visited[node] = True\n        if all(visited):\n            return steps + 1\n        \n        for neighbor in adjacency_list.get(node, []):\n            stack.append((neighbor, steps + 1))\n    \n    return \"IMPOSSIBLE\"\n\ndef main():\n    T = int(input()) # number of test cases\n    for i in range(T):\n        B, S = map(int, input().split())\n        \n        slides = []\n        for _ in range(S):\n            U, V = map(int, input().split())\n            slides.append((U, V))\n            \n        route_length = find_route([x+1 for x in range(B)], slides)\n        \n        if route_length == \"IMPOSSIBLE\":\n            print(\"Case #{}: IMPOSSIBLE\".format(i+1))\n        else:\n            visited = [False] * (len(slides)+1)\n            for u, v in slides:\n                if not visited[u]:\n                    visited[u] = True\n                    print(\"Case #{}: {} 1\".format(i+1), end=\" \")\n                if not visited[v]:\n                    visited[v] = True\n                    print(v, end=\" \")\n            print()\n        \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T21:01:10.424593",
    "generation_time": 14.142374038696289,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\world_finals\\triangles",
    "problem_name": "Triangles",
    "python_code": "def main():\n    T = int(input())\n    for t in range(1, T+1):\n        N = int(input())\n        points = []\n        for i in range(N):\n            x, y = map(int, input().split())\n            points.append((x,y))\n        \n        # Your code here to find the maximum set of triangles and print it\n        max_triangles = []\n        print(\"Case #{}: {}\".format(t), end=\"\\n\")\n        for triangle in max_triangles:\n            print(triangle[0], triangle[1], triangle[2])\n            \nmain()",
    "generated_at": "2025-05-03T21:01:14.503280",
    "generation_time": 4.043472051620483,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\world_finals\\wonderland_chase",
    "problem_name": "Wonderland Chase",
    "python_code": "import sys\nsys.setrecursionlimit(10**6) # Increase recursion limit for large inputs\nfrom collections import defaultdict, deque\n\ndef read_input():\n    T = int(input())\n    cases = []\n    for i in range(T):\n        J, C, A, Q = map(int, input().split())\n        adjacency_list = defaultdict(set)\n        for _ in range(C):\n            U, V = map(int, input().split())\n            adjacency_list[U].add(V)\n            adjacency_list[V].add(U)\n        cases.append((J, C, A, Q, adjacency_list))\n    return T, cases\n\ndef find_shortest_path(adjacency_list, start, end):\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        current_junction, distance = queue.popleft()\n        if current_junction == end:\n            return distance\n        for neighbor in adjacency_list[current_junction]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, distance + 1))\n    return -1 # No path found\n\ndef queen_moves(adjacency_list, current_pos, herald):\n    next_move = herald[current_pos]\n    if next_move == current_pos:\n        return False # Alice caught\n    del herald[current_pos]\n    for neighbor in adjacency_list[next_move]:\n        if neighbor not in herald:\n            herald[neighbor] = next_move\n    return True\n\ndef alice_moves(adjacency_list, current_pos):\n    distances = [find_shortest_path(adjacency_list, current_pos, target) for target in adjacency_list[current_pos]]\n    if not any(distances): # No possible move\n        return False # Caught by the Queen\n    return min(distances.index(min(distances)) + 1 # Minimum distance to a junction with no herald\n\ndef main():\n    T, cases = read_input()\n    for i in range(T):\n        J, C, A, Q, adjacency_list = cases[i]\n        herald = {Q: -1} # Initial position of the Queen's herald\n        alice_move = 0\n        queen_move = 0\n        while True:\n            if not queen_moves(adjacency_list, Q, herald): # Queen caught Alice\n                print(\"Case #{}: {}\".format(i+1, alice_move + queen_move))\n                break\n            if not alice_moves(adjacency_list, A): # Alice caught by the Queen\n                print(\"Case #{}: {}\".format(i+1, \"SAFE\")\n                break\n            alice_move += 1\n            queen_move += 1\n            if alice_move + queen_move >= 2*10**9: # Both have made half the moves each\n                print(\"Case #{}: {}\".format(i+1, \"SAFE\")\n                break\n        else: # Alice not caught after 10^9 moves\n            print(\"Case #{}: {}\".format(i+1, alice_move + queen_move)\n            \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T21:01:37.466029",
    "generation_time": 22.926477193832397,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2016\\world_finals\\gallery_of_pillars",
    "problem_name": "Gallery of Pillars",
    "python_code": "import math\n\ndef is_visible(x, y, r):\n    if x == 0 and y == 0:\n        return False\n    elif x < 0 or y < 0:\n        return True\n    else:\n        return (r**2 >= x**2 + y**2)\n\ndef main():\n    T = int(input())\n    \n    for i in range(1, T+1):\n        N, R = map(int, input().split())\n        \n        count_visible = 0\n        for j in range(N-1):\n            for k in range(N-1):\n                if is_visible(j+0.5, k+0.5, R/1e6) and is_visible(-j+0.5, -k+0.5, R/1e6) and is_visible(-j+0.5, k+0.5, R/1e6) and is_visible(j+0.5, -k+0.5, R/1e6):\n                    count_visible += 1\n        \n        print(\"Case #{}: {}\".format(i, count_visible))\n    \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T21:02:54.755911",
    "generation_time": 7.798670768737793,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2018\\practice_session\\number_guessing",
    "problem_name": "Number Guessing",
    "python_code": "import sys\nfrom collections import namedtuple\n\nTestCase = namedtuple(\"TestCase\", [\"A\", \"B\", \"N\"])\n\ndef main():\n    T = int(input())  # Read number of test cases\n    for i in range(T):\n        A, B, N = map(int, input().split())  # Read the three integers for each test case\n        guessed_range = B - A + 1\n        if guessed_range > 30:\n            print(\"WRONG_ANSWER\")\n            sys.exit()\n        \n        P = (A + B) // 2  # Guess the middle of the range as initial guess\n        for _ in range(N):\n            print(P)  # Output your guess to standard output\n            response = input().strip()  # Read judge's response from stdin\n            \n            if response == \"CORRECT\":\n                break\n            elif response == \"TOO_SMALL\":\n                P = (A + P) // 2\n            else:  # response == \"TOO_BIG\"\n                P = (P + B) // 2\n        else:\n            print(\"WRONG_ANSWER\")  # If not solved after N tries, output WRONG_ANSWER and exit with error code 1\n        \n    sys.exit(0)\n    \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T21:04:13.551175",
    "generation_time": 8.943818807601929,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\qualification_round\\dat_bae",
    "problem_name": "Dat Bae",
    "python_code": "# This is a Python program to simulate the broken worker database system described above. It reads input from stdin and writes output to stdout.\n\nimport sys\n\ndef main():\n    T = int(input()) # read number of test cases\n    \n    for i in range(T):\n        N, B, F = map(int, input().split())  # read the number of workers and broken workers\n        \n        bits = []\n        calls = 0\n        broken_workers = [False] * N\n        \n        while len(bits) < N:\n            if calls >= F:\n                print(\"-1\")\n                sys.exit()\n            \n            line = input().strip()\n            bits += [int(c) for c in line]\n            calls += 1\n        \n        for j in range(N):\n            if not broken_workers[j]:\n                print(bits[j], end=' ')\n        \n        print(\"\") # newline after each test case output\n        \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T21:04:38.327611",
    "generation_time": 6.288026809692383,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2019\\round_2\\pottery_lottery",
    "problem_name": "Pottery Lottery",
    "python_code": "def main():\n    T = int(input()) # read number of test cases\n    for i in range(T):\n        V, P = map(int, input().split()) # read V and P on turn 100\n        if P == 100:\n            print(\"100 99\") # insert your token into vase 99\n        else:\n            pass # do nothing\n            \nmain()",
    "generated_at": "2025-05-03T21:04:58.831278",
    "generation_time": 2.6294472217559814,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2020\\round_1b\\blindfolded_bullseye",
    "problem_name": "Blindfolded Bullseye",
    "python_code": "def main():\n    T = int(input())\n    for i in range(T):\n        A, B = map(int, input().split())\n        R = random.randint(A, B)\n        X, Y = random.sample([-109, 109], 2)\n        for j in range(300):\n            x, y = map(int, input().split())\n            if (x - X) ** 2 + (y - Y) ** 2 <= R ** 2:\n                print(\"CENTER\")\n                break\n            else:\n                print(\"WRONG\")\n        else:\n            continue\n    print(\"CORRECT\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T21:05:46.119199",
    "generation_time": 4.687634229660034,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\round_1a\\double_or_one_thing",
    "problem_name": "Double or One Thing",
    "python_code": "import sys\r\nsys.setrecursionlimit(10**6)\r\nT = int(input())\r\nfor i in range(1, T+1):\r\n    S = input()\r\n    result = ''\r\n    for c in S:\r\n        if c == 'H':\r\n            result += 'HH'\r\n        else:\r\n            result += c*2\r\n    print('Case #%d: %s' % (i, result)",
    "generated_at": "2025-05-03T21:05:58.627816",
    "generation_time": 2.7738234996795654,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\round_1b\\asedatab",
    "problem_name": "ASeDatAb",
    "python_code": "import random\n\ndef flip_bits(binary):\n    return ''.join(['0' if bit == '1' else '1' for bit in binary]\n\ndef reset_record(binary, rotation):\n    rotated = binary[rotation:] + binary[:rotation]\n    return ''.join([flip_bits(bit) for bit in rotated])\n\ndef main():\n    try:\n        T = int(input())\n        for case in range(1, T+1):\n            initial_value = bin(random.randint(1, 254))[2:].zfill(8)\n            current_value = initial_value\n            num_exchanges = 0\n            while current_value != '0'*8 and num_exchanges <= 30:\n                new_value = reset_record(current_value, random.randint(1, 7))\n                print(new_value)\n                N_i = int(input())\n                if N_i == -1:\n                    break\n                current_value = ''.join(['0']*N_i + ['1']*(8-N_i))\n                num_exchanges += 1\n            else:\n                print('Wrong Answer')\n    except Exception as e:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T21:06:11.719097",
    "generation_time": 8.7727792263031,
    "model": "wizardcoder:13b-python-q4_0"
  },
  {
    "source": "2022\\round_2\\pixelated_circle",
    "problem_name": "Pixelated Circle",
    "python_code": "def set_pixel_to_black(x, y):\n    pass  # Implement this function to color a pixel black",
    "generated_at": "2025-05-03T21:06:16.107859",
    "generation_time": 0.8009448051452637,
    "model": "wizardcoder:13b-python-q4_0"
  }
]