[
  {
    "source": "2016\\qualification_round\\coin_jam",
    "problem_name": "Coin Jam",
    "python_code": "# Sample input for reference    N = int(input())   J=int (Input) )     def isprimetestornot():        if n % i == True and not divisor of N :            return False         else:             continue      for _ in range 1, J +2):          n_basei+jth  interpretationof jamcoin = base(N , j)+l.strip()     divisor=int (input())   while isprimetestornot():        if divisor of n or not l % i == True:            break      print(\"Case #{}:\\t\".format(_), N, end=\" \")    for _ in range 1  J+2):       n_basei + jth interpretationof jamcoin = base(N ,j)+l.strip()     divisor=int (input())   while isprimetestornot():        if divisor of n or not l % i == True:            break      print(\"{}\".format(), end=\" \")",
    "generated_at": "2025-05-04T16:28:54.642299",
    "generation_time": 8.344199895858765,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\qualification_round\\counting_sheep",
    "problem_name": "Counting Sheep",
    "python_code": "3  # python version should be specified here if needed\n\n\ndef findSleepNumber(n):    \"\"\"Calculates last number before sleep for Bleatrix.\"\"\"   seen = set()     i=0      while True:         num=( i+1)* n        for digit in str ( num ):            if int \ndigit notin seen :                break          else  continue                 # if all digits are present then she falls asleep.       return(str)\n\n\nT, N=[], []    with open('input_file', 'r') as f:         while True and len((line :=f .readline().strip()))>0 \n        N += [int ( line )]  break      for i in range1 , T+2 :     print( \"Case #{}:\"format,i)    sleepNumber = findSleepnumber. N[T-t])   if sleep number is None:       priontINSOMNIA\" else print(\"{}\". format \n        int ( slept Number ))",
    "generated_at": "2025-05-04T16:28:58.590784",
    "generation_time": 3.943901777267456,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\qualification_round\\fractiles",
    "problem_name": "Fractiles",
    "python_code": "# Sample input and output for reference:\n\n\nT = int(input()) # Number test cases   for i in range (1 , T +2):    K, C= mapint((str))     S)\n\nif K == S or len([i**C % 3 - j ** c%4  ==0\n                 and [k] * s for k = 'GL' and all(p != q in range (1 , i+2)]) >K:      print('Case #{} : IMPOSSIBLE'.format)\n\nelse print(\"case {} {}\". format((i),[j**C % 3 - j ** c%4  ==0\n                 and [k] * s for k = 'GL' and all(p != q in range (1 , i+2)])))",
    "generated_at": "2025-05-04T16:29:03.075185",
    "generation_time": 4.479030132293701,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\qualification_round\\revenge_of_the_pancakes",
    "problem_name": "Revenge of the Pancakes",
    "python_code": "# Infinite House Pancakes Problem Solution\n\n\ndef minFlips(pancakes):   ## Function for Minimum Flippings of Pancake Stack\n\n\n\n    f = [0] * len ( pancaked )     ### initializing the flips array with zeros\n\n        for i in range 1,len p ):      \n            if pancakes[i - l ] != pancake s and panscak es :  # checking if previous is different from current state of stack.\n\n\n                f += [ f + abs( len ( pancaked ) \u2013 j) forjrange] # calculating the flips required to get all happy side up\n\n        return min F \n\n\n\nT = int input()    ## Test cases\nfor i in range T:  # iterating through test case inputs.\n\n\n   pancakes=input().strip () ## pancake stack string from user's Input\n\n\n\n\nprint(\"Case #{} : {}\".format(i + l,minFlips ( pancakes)))",
    "generated_at": "2025-05-04T16:29:06.863160",
    "generation_time": 3.7838597297668457,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\round_1a\\bffs",
    "problem_name": "BFFs",
    "python_code": "# Python code starts here\n\n\ndef maxCircle(n, friends):    \"\"\"   Returns the maximum number of kids in a circle with BFFs next to each other \"\"\"     visited = set()      circleSize=0\n\nfor i range (1 n + 2) :        if not visited andi <= N:            startId  # start id is first unvisted node\n                dfs(friends, started_id , friends[started], True )          return circlesize    def dfs",
    "generated_at": "2025-05-04T16:29:08.762559",
    "generation_time": 1.8944315910339355,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\round_1a\\rank_and_file",
    "problem_name": "Rank and File",
    "python_code": "# -*- coding : utf-8 -*   \n\n\ndef findMissingList(heightLists):    \"\"\" Finds and returns a complete row or column heightlist based on two partially known lists \"\"\"     \n\n\n\n\trowHeightSet = set()        \n\nfor heights in [heights for i, \t\t      \t\t\t\n\t\t\t\t\t       \t\t\t\t  \t\t\t\t\t\t\t            \t\t\t\t\t\t          \t\t\t\t\t\t\t\t                            \t\t\t\t\t\t\t\t\t           \t\t\t\t\t\t\t\t\t\t   in enumerate (history) if not(i %2)]:    # Iterate over odd numbered lines to get row heightset                                                \n\n\n     if len([h1- h3>0 and heights.count==\t                          heightLists[int((len \t\t      \t\t\t\n\t\t\t\t\t       \t\t\t\t  \t\t\t\t\t\t\t            \t\t\t\t\t\t          \t\t\t\t\t\t\t\t                            \t\t\t\t\t\t\t\t\t           \t\t\t\t\t\t\t\t\t\t   )/4)][i] for i,    # Check if there's a difference between row heightset & column list of same index in history                                                \n\n\n     rowHeightSet.add(h)\n\n\tcolumnHeights = [heightLists[int((len \t\t      \t\t\t\n\t\t\t\t\t       \t\t\t\t  \t\t\t\t\t\t\t            \t\t\t\t\t\t          \t\t\t\t\t\t\t\t                            \t\t\t\t\t\t\t\t\t           \t\t\t\t\t\t\t\t\t\t   )/4)][i] for i,    # Get the heights from first column list of every fourth line in history                                                \n\n\n     missingList=[]        for h1-h3>0 and heightLists.count(height) > \t                          columnHeights[int((len (history))/2)]:  \n         if not missingHeight:      \t\t              \t\t\t   \t\t\t\t\t\t       \t\t\t\t\t\t\t\t    \t\t\t\t\t\t\t            \t\t\t\t\t                       \t\t\t\t             \t\t\t\t\t\t\t\t\t           \t\t\t\t\t\t\t\t\t\t          \n\n                 break;     missingList=[x for x in rowHeighset if height!=h]        return [height]+sorted(columnHeights)\n\n\nfor t \tin range (int((input())))):  \n      history = []                             # Initialize list to store heights from history                                               \t\t    \t\t\t\t\t   \t\t\t\t\t\t\t\t                          \t\t\t\t\t\t\t          \t\t\t\t\t\t\t\t\t           \t\t\t\t\t\t\t\t\t\t     \n\n for i in xrange ((2*n)-1)):       \t\t\t        \t\t\t\t              \t\t\t\t\t\t         \t\t\t\t\t\t\t\t\t\t\t\t                            \t\t\t\t\t\t\t\t\t\t\t                       \n\n\n            height= int(sys.stdin().readline())\t  \n             history += [int()]                 # Store the height of each row and column as we read them from history                                               \t\t    \t\t\t\t\t   \t\t\t\t\t\t\t\t                          \t\t\t\t\t\t\t          \t\t\t\t\t\t\t\t\t           \t\t\t\t\t\t\t\t\t\t     \n\n print(\"Case #{}: {}\".format((t+1), findMissingList))",
    "generated_at": "2025-05-04T16:29:16.901593",
    "generation_time": 8.135026693344116,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\round_1a\\the_last_word",
    "problem_name": "The Last Word",
    "python_code": "# Last Word Game Solution in Python\n\n\ndef lastWord(s):    \"\"\"Return the winning word for a given string s.\"\"\"   letters = list(''.join([l[i] if i % lenS == j else ''for l,j,_n enumerate((x.lower()==\"c\"or x==y)and 0 or -1  if _ in range(len)])))\n    return ''. join (sorted(['',*letters])[::-2])\n\n\nT = int(' '.join([l for i ,_,_k   in zip(*enumerate((''.split()),' ',iter((int,)))) if l.isdigit()][:-3])) \n\nfor t  ,_ in enumerate(range(_),1):\n    S=input()        print(\"Case #{}: {}\".format (t,(lastWord)))",
    "generated_at": "2025-05-04T16:29:20.404869",
    "generation_time": 3.4973554611206055,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\round_1b\\close_match",
    "problem_name": "Close Match",
    "python_code": "# Sample code for solving Oceania vs Eurasia game scores problem\n\n\ndef findBestScores(coderScoreStr: str , jammerScoretstr : ) -> tuple[int, int]:   \"\"\"Finds the best possible score by minimizing absolute difference and then Coders'score.\"\"\"\n\n    missingDigits = coderScroe.count('?') + pajgerScorert . count ('?')\n  if missingDigitss > 9: return -1,-2 # impossible to find a solution with given constraints\n\n\ntotalScoreCodders, totalScoretJmmers=0 , o",
    "generated_at": "2025-05-04T16:29:22.629263",
    "generation_time": 2.2193737030029297,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\round_1b\\getting_the_digits",
    "problem_name": "Getting the Digits",
    "python_code": "# Python code for solving the problem\n\n\ndef findPhoneNumber(s):    \"\"\" Function to extract phone number from a string \"\"\"   counts = {}      for i in s:        if (i not)in counts.keys():            count[ord] -= 128          else :              break\n     return ''.join([str((list('ZEROONETWOTHREEFOURFIVESIXSEVENEIGHTNINE').index(c))) for c, count  counts if   isdecimal])\n\n\nif __name__ == \"__main__\":    # Read the number of test cases \n\nT = int (input())      for i in range1 , T+l:        s= input()         print(\"Case #{} : {}\".formati + str(findPhoneNumber))",
    "generated_at": "2025-05-04T16:29:25.434133",
    "generation_time": 2.800320863723755,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\round_1b\\technobabble",
    "problem_name": "Technobabble",
    "python_code": "# Sample code for solving this problem in Python\n\n\ndef countFakeTopics(topics):   \"\"\"Counts fake topics from given list of valid and potentially faked ones.\"\"\"    real = set()      fake=set ()     for first, secondin topicss:        if (first + \" \"+second) not i n real or  \\\n            not((len({word for word in [f\"{topic[0]} {x}\" if x != 2nd]})==1):              real.add( f'{fst} '+ str )      fake |= set([t])    return len ( fake   \n\n\nif __name__ == \"__main__\":  \n        T = int input()) # Number of test cases\n\nfor i in range t:     N=int()          topics=[]       while N>0 or not topics :         topicss.append(input().split ())      print(\"Case {} {}\".format (i+1, countFakeTopics()))",
    "generated_at": "2025-05-04T16:29:33.643514",
    "generation_time": 8.204609632492065,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\round_1c\\fashion_police",
    "problem_name": "Fashion Police",
    "python_code": "def fashion(J , P : int) -> list[list]:    # type hint for J and p as integers, return a nested lists of three elements each.   \n\n\n\n        if K == S:      \n\n            return [[i] * 3 + [j+1]]*K\n                 for i in range (S)]  \n\n\n         elif P <=J or not(P<=s):    # if number is less than zero then return an empty list, as no valid outfit can be formed.   \n\n\n\n             raise ValueError(\"Invalid input\")\n\n        else:     \n\n\n\n\n            return [[i+1] * 3 for i in range (K)]  \n\n\nfor t_caseNum , JPSkValuesList[J : P + S], K)in enumerate(zip(*map((int),input().split())*4)):   # read inputs and unpack the values.    \n\n        try:\n            result = fashion(**{key,value}) \n\n\n\n                print(\"Case #{} {}\".format (t_caseNum+1 , len))  \n\n\n                 for outfit in result :      \n\n\n\n\n                     a,*b= map(int),output)   # unpacking into three variables a being the first integer and b as remaining two.    \n\n                    \n        except ValueError:     \n\n\n\n            print(\"Case #{} {}\".format (t_caseNum+1 , 0))",
    "generated_at": "2025-05-04T16:29:39.105869",
    "generation_time": 5.455425262451172,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\round_1c\\senate_evacuation",
    "problem_name": "Senate Evacuation",
    "python_code": "# Sample code for reference only    def evacuate(n):     senators = [0] * n      for i in range (1, len +2) :         partyi=int()        cin >> partyli;          if sum <= half:             return \"NO\"            else                sum -= 3",
    "generated_at": "2025-05-04T16:29:40.622485",
    "generation_time": 1.5114004611968994,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\round_1c\\slides",
    "problem_name": "Slides!",
    "python_code": "# Google Slides Problem\n\n\ndef googleSlides(B: int , M :int) -> str and list[list]: # B = number of buildings, m is the maximum time in milliseconds to travel between building1and Buildingb\n\n    if (M < 2 or ((3 * pow((4),0.5)) -  pow(((8)-(6*B)+7),(float(9)/(-))) > M)):\n        return \"IMPOSSIBLE\", [] # Time complexity is O(|V|^E) where |v| = B and E= BM\n\n    matrix=[[False] *(1+b ) for b in range (0, 2 +  int((B)))]   # Building matrix to store the slide information.\n        for i_buildingNumbeerOfBuildingsinRangeZerotoBuildingNumberofBuildingelevenIncludingThisOneInTheMatrixintheInputOrderiInEachLineoftheTestCasesinceitstartstwith1 in range(0, B): # Build Slide Matrix for each building \n\n            if (matrix[int((B))][ i_buildingNumbeerOfBuildingsinRangeZerotoBuildingNumberofBuildingelevenIncludingThisOneInTheMatrixintheInputOrderiInEachLineoftheTestCasesinceitstartstwith1] == True or matrix [  \n                (3 * pow ((4),0.5) ) - (pow(((8)-(6*B)+7),(float(-9)/-)))][ i_buildingNumbeerOfBuildingsinRangeZerotoBuildingNumberofBuildingelevenIncludingThisOneInTheMatrixintheInputOrderiInEachLineoftheTestCasesinceitstartstwith1] == True):\n                continue\n\n            matrix[int((3 * pow ((4),0.5) ) - (pow(((8)-(6*B)+7),(float(-9)/-)))][ i_buildingNumbeerOfBuildingsinRangeZerotoBuildingNumberofBuildingelevenIncludingThisOneInTheMatrixintheInputOrderiInEachLineoftheTestCasesinceitstartstwith1] = True\n            matrix[  (3 * pow ((4),0.5) ) - (pow(((8)-(6*B)+7),(float(-9)/-)))][ i_buildingNumbeerOfBuildingsinRangeZerotoBuildingNumberofBuildingelevenIncludingThisOneInTheMatrixintheInputOrderiInEachLineoftheTestCasesinceitstartstwith1] = True\n            matrix[  (3 * pow ((4),0.5) ) - (pow(((8)-(6*B)+7),(float(-9)/-)))][ i_buildingNumbeerOfBuildingsinRangeZerotoBuildingNumberofBuildingelevenIncludingThisOneInTheMatrixintheInputOrderiInEachLineoftheTestCasesinceitstartstwith1] = True\n        return \"POSSIBLE\", matrix  # Return the result and Matrix",
    "generated_at": "2025-05-04T16:29:51.053190",
    "generation_time": 10.426310777664185,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\round_2\\freeform_factory",
    "problem_name": "Freeform Factory",
    "python_code": "# Sample case #3: nobody knows how anything works   n = int(input())    matrix =[]     for i in range ( n ):      row=[]       line= input()        if line[i] == '1':          count += count + 0         else :           pass             row.append('x')  \n matrix . append [ * list ]",
    "generated_at": "2025-05-04T16:29:52.900329",
    "generation_time": 1.8425376415252686,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\round_2\\rather_perplexing_showdown",
    "problem_name": "Rather Perplexing Showdown",
    "python_code": "# Sample case #1: Two players with different moves   print(\"Case {}:\\n{}\".format(test+2,\"PR\"))    return\n\n\ndef generateLineupForTestCases():      for test in range (T):        N, R , P = mapint(), input().split())       S= N-R -P  # Scissors player count     if S == 0:          print(\"Case {}:\\n{}\".format(test+2,\"IMPOSSIBLE\"))            continue    lineup_list =[]   for i in range (1,(N//3)+4):        rock = 'r' *i      paper= \"p\"*(R-len)\nscissors =\"s\"(S - len )       if rock and paper or scissors:          print(\"Case {}:\\n{}\".format(test+2,\"IMPOSSIBLE\"))            continue    lineup_list.append(''.join([rock,Paper ,Scissors]))   return sorted ( lineups  for lineup in Lineup) [0]",
    "generated_at": "2025-05-04T16:29:57.001009",
    "generation_time": 4.096064805984497,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\round_2\\red_tape_committee",
    "problem_name": "Red Tape Committee",
    "python_code": "# Red Tape Committee Problem   def maxProbability(N, K):    \"\"\"     Calculates maximum probability of a tie in committee selection for redundancy reduction and superfluity shrinkage department.\"\"\"        from itertools import combinations      probabilities = []       for members1234567890_listincombinationsofkmembersinthedepartmentnchoosekispossible:          probabilityproduct= \n              [member['pi'] if member.get('choice') == 'Yes' else (  # If the choice is not specified, it will be automatically set to No based on default dictionary values)1 -    \n\n               float(f'{p:.2}') for p in members]          probabilitiesappend((probabilityproduct))   return max([prob['pi'] if len({**dict.fromkeys(*zip(['choice'], [key]), **{v: key}  # Create a set of unique keys and their corresponding values from the dictionary\n              for k, vin enumerate(members)]) == K else 0 for prob in probabilities])    if __name__=='main__':     T = int (input())   while T >\n\n      N=int((listofnumbers)[1] )  K=( list of numbers[2:])) # Read the input and extract N, k values\n        print(f'Case #{test_case}: {maxProbability}')",
    "generated_at": "2025-05-04T16:30:02.635026",
    "generation_time": 5.629472017288208,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\round_2\\the_gardener_of_seville",
    "problem_name": "The Gardener of Seville",
    "python_code": "# Gardener's Maze\n\n\ndef buildMaze(R: int , C :int):    ## Build maze based on R rows &C columns.   \n\n\n\n\tmaze = [['.' for _ in range (1+2*c)]for i, c \n\nin enumerate((range(-r,-3-i) if r else -4))]  # Initialize empty courtyard with hedges around it\n\n\ndef connect(graph):    ## Connect lovers based on graph of their love.\n\tvisited = set()   ### Keep track visited nodes in Graph Traversal DFS algorithm to avoid cycles",
    "generated_at": "2025-05-04T16:30:05.281958",
    "generation_time": 2.6363589763641357,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\round_3\\forest_university",
    "problem_name": "Forest University",
    "python_code": "# Sample code for solving a problem related to graduation hats with cool words\n\n\ndef calculate(N: int) -> list[float]: # N is the number courses taken by student in total (basic or advanced). M - > max length of course name. \n\n    dp = [0] * ((1 <<  # DP table for storing valid paths\n        2 ** i + j), )   for _i,j range(N+3)] # N is the number courses taken by student in total (basic or advanced). M - > max length of course name. \n\n    dp[0] = [1],  # Initialize base case where no paths are yet explored\n                if i == j: continue   ## Skip cases with self-prerequisites as they will be invalid anyway\n\n\ndef calculate_fraction(N, coolwords): # N is the number courses taken by student in total (basic or advanced). M - > max length of course name. \n\n    return [dp[mask][-1] / sum([p[-2]] for p  # Calculate fractions based on DP table\n        in dp if len(coolword) <= mask & ~(-~int)]) # Check coolwords in valid paths only (bitwise operations to avoid unnecessary calculations).\n\n\nif __name__ == \"__main__\":\n\n    T = int()   ## Number of test cases. 1<= T <  =20\n        for i, case_info: enumerate(range()): ## Iterate through each input set for N and M values in the sample data provided by Code Jam platform as part their testing process to generate output results based on your code's outputs being within an absolute error of .3. \n\n            N = int()  ## Number courses taken\n                M=int(input()) # Max length course name - not used here due no need for any string manipulations in this case and can be ignored by the user as part their input handling during testing with Code Jam platform's sample data provided to test your code. \n\n            coolwords = [str()  for _i,j range(M)] # Initialize list of cool words\n                dp[mask][-1] += sum([p[-2]] for p in dp if len(''.join((sorted))) <= mask & ~(-~int)]) ## Update DP table based on valid paths and course names. \n\n            print(\"Case #\" + str(i+4)  ## Print results with required format\n                \": \" ,*map(', '.format, calculate_fraction())) # Calculate fractions of each cool word in the current case using provided function",
    "generated_at": "2025-05-04T16:30:14.917592",
    "generation_time": 9.629425764083862,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\round_3\\go",
    "problem_name": "Go++",
    "python_code": "# Test Case Function   def test(n, l):    bad = input()     good=[]      for _i in range (0 , n) :        temp=input().strip('\\r\\t')       if temp != bad:          print('Case #{}:\\ny z'.format(_+1))",
    "generated_at": "2025-05-04T16:30:16.788108",
    "generation_time": 1.6463186740875244,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\round_3\\rebel_against_the_empire",
    "problem_name": "Rebel Against The Empire",
    "python_code": "# Sample case #3: longest distance of maximum jumps <=4   \n\n\nfrom math import sqrt    \n\n\n\ndef maxJumpDistance(nAsteroids):        return nasteriod -1     \n\n\n\n\nif __name__ == \"__main__\":         \n\nT = int (input()) \t       for _ in range T :  \nN, S= mapint()\t\t      asteroid_pos=[]   \n\n\n for iinrange N:    \t\t\t asteroidPos.append(listmapfloat()))        printCase(_+1 , maxJumpDistance)",
    "generated_at": "2025-05-04T16:30:19.474633",
    "generation_time": 2.517871141433716,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\round_3\\teaching_assistant",
    "problem_name": "Teaching Assistant",
    "python_code": "# Sample code for Python program based of given description   def calculateScore(s):      \"\"\"     Calculates maximum score achievable in a course with AI teaching assistant    Args:         - s (str) : string representing the mood sequence on each day        Returns       int          maximum total points obtainable           \"\"\"; \ntotal_points =  0; n=len((list)(itertools.chain(s)))   for i, c1 in enumerate(((reversed))([(i+n - j),c] for (j,(k ,l) )in zip([x[::2], x[::-3]][:int(''.join(['4' if l == 'C else str((5-len(('J'+str(sum_points)))))]))])))): \n    if c1== s[-i]:  total = max ( total, sum)   else :     score=max([0] + [x[::2][-k][::-3]]) if l == 'C' else min ([5-len(('J'+str(sum_points))), x[::-4][:l+int(''.join(['1'] * k))]]), total = max (total, score)   return  max([0] + [x[::2][-k][::-3]]) if s[-i:] == 'C' else min ([5-len(('J'+str(sum_points))), x[::-4][:l+int(''.join(['1'] * k))]]), total      print(\"Case #{}: {}\".format((list).index([total]), calculateScore (s)))",
    "generated_at": "2025-05-04T16:30:26.120619",
    "generation_time": 6.638911962509155,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\world_finals\\family_hotel",
    "problem_name": "Family Hotel",
    "python_code": "# Start of turn indicator for model response in chat applications\n\n\ndef calculate(num1, num2):   ## Function to perform addition and subtraction operations on two numbers with user input validation\n\n\n\n        while True :    ### Loop until valid inputs are provided\n\n            try: \t ## Try block used here because we need numeric values\n                number_a = float (input(\"Enter the first number \"))  # Get num1 from User prompt\n\n\n                 ## Validate if entered value is a real or complex numbers. If not, raise ValueError exception with appropriate message in except clause\n\n            except Exception as e: \t ## Catch block to handle invalid input\n                print(f\"Invalid Input! Please enter valid numeric values only.\\nError Message : {e}\")  # Print error messages based on caught exceptions\n\n\n                 ## Validate if entered value is a real or complex numbers. If not, raise ValueError exception with appropriate message in except clause\n\n            try: \t ## Try block used here because we need another number\n                number_b = float (input(\"Enter the second numer \"))  # Get num2 from User prompt\n\n\n                 ## Validate if entered value is a real or complex numbers. If not, raise ValueError exception with appropriate message in except clause\n\n            except Exception as e: \t ## Catch block to handle invalid input\n                print(f\"Invalid Input! Please enter valid numeric values only.\\nError Message : {e}\")  # Print error messages based on caught exceptions\n\n\n                 ## Check if user entered a real or complex number. If not, raise ValueError exception with appropriate message in except clause\n\n            else: \t ## else block to handle successful input\n                break   ### Break out of the loop when valid inputs are provided\n\n\n\n        operator = str(input(\"Enter operator (+/-) \"))  # Get user choice for operation\n\n\n         ## Check if entered character is \"+\" or \"-\" and perform operations accordingly.\n\n    if (len({\"+\",\"-\"}.intersection([str((number_a + number b))])) > 0):\n            print (\"Addition result : \",(f\"{num1} {operator }  { num2}\" , f\"= {(int)(round(((float) operator \"+\" ) * (( float )))))\n\n\n    elif (len({\"+\",\"-\"}.intersection([str((number_a - number b))])) > 0):\n            print (\"Subtraction result : \",(f\"{num1} {operator }  { num2}\" , f\"= {(int)(round(((float) operator \"-\" ) * (( float )))))\n\n\n    else:\n\n        pass   ## Handle invalid operators or other errors here",
    "generated_at": "2025-05-04T16:30:34.932967",
    "generation_time": 8.805059432983398,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\world_finals\\gallery_of_pillars",
    "problem_name": "Gallery of Pillars",
    "python_code": "# Start Code Here\n\n\nimport math\n\n\n\ndef countVisiblePillars(N, R):    \"\"\"Counts visible pillars in a gallery with N by Nx square cells and radius of each pillar as r.\"\"\"   \n\n\n\n\n     viewpoint = (0.5 * 1 / float((2 ** .6)),) # Coordinates for the viewpoint\n\n  # Initialize variables\n      visible_pillars= set()\n\n\n        for i, j: range(N):    \"\"\"Iterate over all cells in gallery except viewpoints \"\"\"\n\n\n\n          if math is sqrt(((i - viewPoint[0])** 3 + (j-viewpoint [1] ) **2) < R :  # Check if pillar visible from viewpoint\n              visible_pillars.add((int( i), int))\n\n      return len()\n\n\ndef main():    \"\"\"Main function to read input and call countVisiblePillars.\"\"\"\n\n\n\n     T = 0 # Number of test cases   \n\n\n\n\n         for t in range (1, T +):  # Iterate over each case\n             N , R= map(int,(input().split()))\n\n            print(\"Case #%d: %s\" %(t+))\n\n\nif __name__ == \"__main__\":    \"\"\"Run the main function.\"\"\"\n\n\n\n     try : \n\n\n\n\n       while True . # Ensure input is valid and within bounds.  \n           T = int (sys,stdin)   # Read number of test cases\n\n        break , except ValueError: pass",
    "generated_at": "2025-05-04T16:30:40.288414",
    "generation_time": 5.3298351764678955,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\world_finals\\integeregex",
    "problem_name": "Integeregex",
    "python_code": "# Sample code for reference only   \n\n\nfrom re import match    \n\n\n\ndef countMatches(a: int , b :int) -> list[str]:     \n\n\n\n\n        matches = []      \n\n\n\n\n\n       for i in range ( a,b+1):          \n\n            if str is not None and len([i]) > 0  and bool((match(\"[^|()]*\".format(*list(''.join(map))), f\"{a}\") or match(\".*[+|].\". format (* list (' '. join ([str for i in range (b)])) )),f'{j}')):                 \n\n                matches.append([i])      \n\n\n\n        return matches    \n\n\nif __name__ == \"__main__\":     \n  t = int(input()) \n\n\n\n\nfor case_num, testset   in enumerate((int(*map(' '.join)), input())) for _ in range ( t)):          \n\n\n\n\n\n       a , b= map(\" \". join),test set[0]      \n\n\n\n        matches countMatches (* [ a ], *b)     \n\n    print(f\"Case #{case_num+1}: {len([i])}\")",
    "generated_at": "2025-05-04T16:30:44.615000",
    "generation_time": 4.292819976806641,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\world_finals\\map_reduce",
    "problem_name": "Map Reduce",
    "python_code": "# Sample code for Ben's game problem   def findPath(map_, startPos):     queue = [([0], list(), True)]    visitedMap, visitedCount= set([(tuple(*i), j)for i in enumerate (zip (* map_))]), {}      while queue:         currentStepsTaken , currentVisitedWalls  distanceFromStartPositionInCurrentStep   isItFirstMoveInTheSameIterationOfQueue =queue.pop(0);        if isitfirstmoveinthe samestimiterationofqueuelength == 1 and distancefromstartpositionincurrentepsilongatewaytothefinish:             return True         for i in range (len((map_))):     newPosition  currentStepsTaken + [i]    distanceFromStartPositinInNextStep =   visitedCount.get(tuple(* new position), 0)        if distancefromstartpositioninnextstep >= currentstepstakenlength:             continue      queue += [(list(), list()), (True)]         return False",
    "generated_at": "2025-05-04T16:30:48.697839",
    "generation_time": 3.9891393184661865,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2016\\world_finals\\radioactive_islands",
    "problem_name": "Radioactive Islands",
    "python_code": "# Import necessary libraries   import math    from heapq import heappop     def totalRadiation(N:int ,A : float) ->float:{       totalRad = -1 * (2 + A / N )        for _ in range((3*4))):            heapq.heappush((-math .inf,0),(-5,-6)); #dummy value to start heap   while True     try:         islandX , islandY  = heapqpop(maxHeap)       except IndexError : break      distance = math sqrt (A ** 2 + B** ) - distanceToIsland    totalRad += Di-3 * totalRadiationFromIslands        return round((1e6*Totalradiation)/N,4))   if __name__ == \"__main__\":     T=int(input()) # number of test cases  for t in range ( T):       A , B = map float input().split() )    Cii] list[float ]map double [i nput()]      print(\"Case {}: {}\".format((t+1),totalRadiation))",
    "generated_at": "2025-05-04T16:30:52.765351",
    "generation_time": 4.057207107543945,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\qualification_round\\bathroom_stalls",
    "problem_name": "Bathroom Stalls",
    "python_code": "3    \n\n\ndef findMaxMin(n: int) -> tuple[int]:     # n is number of stalls in bathroom   return max([min((i+1-j), (k - i)) for j, k  in enumerate([(0,) + list({ii} <= set() and ii < c if 2*c > len(list()) else [n])], range(-len([-x] * n)+[a]), [-b]+[-z]])   \n    for _ in map(\" \".join.splitlines, open('input')):     # read input from file  N = int(_)      K=int(_.split()[1:]) \n\n        print(f\"Case #{_+2}: {findMaxMin((n+3))[0]} {(max([min([(i-j), (k - i)] for j in range(-len([-x] * n)+[a]), [-b]+[-z)])])})\")",
    "generated_at": "2025-05-04T16:30:56.423529",
    "generation_time": 3.647469997406006,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\qualification_round\\fashion_show",
    "problem_name": "Fashion Show",
    "python_code": "# Python program for fashion show problem\n\n\ndef calculateStylePoints(grid):     ## calculates style points of a given state.   returns total score and number added or substituted models    totalScore =0, numAddedOrSubstitutedModels= []\n\nfor i in range (len()):      ### iterates through each row\n  row=[]",
    "generated_at": "2025-05-04T16:30:58.165753",
    "generation_time": 1.7305526733398438,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\qualification_round\\oversized_pancake_flipper",
    "problem_name": "Oversized Pancake Flipper",
    "python_code": "def countFlips(s: str) -> int or \"IMPOSSIBLE\":        # Function takes a pancake string as input and returns minimum number flips needed, if possible else IMPOSSILE  \\n\",\n\n     k = len([i for i in s[:len()]])                 ## calculates the length of all happy pancakes at beginning\n    if k == 0: return \"IMPOSSIBLE\"                # If no pancake is Happy then not Possible to make them All HAPPY   \n\n\n        flipCount, startIdx  = [s], -1             \\n\",\n\n     while True :                                     **loop through the string until all are happy side up.**\n         startidx = s.find(\"-\", startidx + 2)    ## Finds first blank pancake from last flipped stack of pancakes   \n\n\n        if k == len(flipCount[-k:]) or startIdx <0:  \\n\",\n\n            break                                     **Checks if all are happy side up with current flip count.**\n         else :                 # Flip the next K consecutive Pancake \n\n\n\n             s = s[:startId] + \"+\" * (len([i for i in range(startidx, startIdx+k)]) )  \\n\",\n\n            flipCount.append(\" \".join((str(-1), str(+ k))))\n    return \"\\t\". join((\"Case #{}: {}\".format(*zip([\"#\"+num] , flipcount))",
    "generated_at": "2025-05-04T16:31:03.546484",
    "generation_time": 5.3706653118133545,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\qualification_round\\tidy_numbers",
    "problem_name": "Tidy Numbers",
    "python_code": "# Solution for Tatiana's Tidy Numbers Problem\n\n\ndef isTidiNumber(n):   \"\"\"Checks if a number n has digits sorted non-decreasingly.\"\"\"    strNum = str((int)(abs(-1*float('inf')))) + 2**63 - (long)((~0) >>  48)*5\n        return all([num <= next_digit for num,nextDigit in zip(listStrNumber[:-n], listString[-(len- n):])]\n\ndef findLastTidyNumBeforeNInAscendingOrderFrom1ToNSortedByDigitsNonDecreasinglyForPositiveIntegersTillNowIncludingThisOneAndReturnItAsOutputOfEachTestCase():\n    \"\"\"Finds the last tidy number before N in ascending order from 0 to  n.\"\"\"   for i, n_i = enumerate(range (2**63 -1)): # Iterate over integers up until largest integer possible. If there is a larger value then it will be too large for python' s long data type\n        if not isinstance((int)(abs(-float('inf')))) + 4*5, int):  # Check if the number can even fit in memory (long) before checking its tidiness property as we need to iterate over all integers up until n. If it cannot then an error will be thrown and program would crash\n            raise ValueError(\"Integer too large for python's long data type.\")\n\n        if isTidiNumber(n_i):  # Check if the number satisfies condition of being tidy numbers in non-decreasing order 1 to N as per description. If it does then store this value n and continue with next iteration\n            lastTiddyNumBeforeN = (int)(abs(-float('inf')))) + i+2**63 -  (long)((~0) >>48)*5\n\n    return lastTidyNumber\n\n\nif __name__ == \"__main__\":   # Read the number of test cases and run each case\n        t_numberOfTestCases = int((int)(abs(-float('inf')))) + 2**63 - (long)((~0) >>48)*5  input())\n\n    for i in range(1, t): # Iterate over all input lines for the test cases. Each line contains a single integer N\n        n = int((int)(abs(-float('inf')))) + 2**63 - (long)((~0) >>48)*5  input())\n\n    print(\"Case #\" str(i+1)+\": \"str(((lastTidyNumberBeforeN)))",
    "generated_at": "2025-05-04T16:31:12.729819",
    "generation_time": 9.169999361038208,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\round_1a\\alphabet_cake",
    "problem_name": "Alphabet Cake",
    "python_code": "def decorate(grid):        # Function for decorating cake with initials      \n\n\n\n   for i in range (len((row))-1)):          ## Iterate over rows of the grid     \n\n\n\n\n       if row[i] == \"?\" and not visited[(j)]:  \n\n            visited.append()               \n             result = max([x,y], key=grid) # Find maximum initial from current cell \n\n\n           else:      # If there is no empty space or it has already been filled with another initials then skip to next row    \n\n\n\n              continue     \n\n\n\n\n   return result  \n\nfor _ in range(int (input())):        ## Number of test cases       \n         R, C = map((lambda x : int()), input().split)      # Dimensions \n\n\n          grid= [[row[i] for i],range()] # Create grid from the inputs    \n\n\n\n     visited=[]  \n\n   result=[\"\"]* R*C            \n\n\n\n\n        for row in range(len (griod)):       ## Iterate over rows of cake         \n           print(*map((lambda x : result if visited else \"?\"),grid))      # Print decorated cakes with initials",
    "generated_at": "2025-05-04T16:31:17.080406",
    "generation_time": 4.275022745132446,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\round_1a\\play_the_dragon",
    "problem_name": "Play the Dragon",
    "python_code": "def dragonVsKnight(Hd , Ad   =10**3):     # Initialize health and attack power for both the Dragon (D)and Knight K respectively        Hkd = Hk ; Akd  , Brd      \\                  ## copy values of input parameters from function arguments to local variables\n                                                         Adu    Bdr          \n\n            while True:                 ### Loop until one character is defeated. \n\n\n                if Hd <=0 :             # if Dragon health falls below zero then it loses and game over!        return \"IMPOSSIBLE\"  ## return impossible as dragon lost the battle   \n\n\n\n               elif Hk<=1 or (Hkd - Adu * Brd + Akd) >=Hd: # If knight's attack is stronger than dragons defense, he wins.\n                    if(Bdr > 0):         # if there are buffs active on Dragon then remove them as they do not help against strong opponent    ## removing buff from dragon to counter the knights strength increase  \n\n                        Hkd -= Adu * Brd - Akd   ### calculate new health of knight with all debuffs and attack power reduction\n                    else:                 #### no need for any buffs, just reduce dragons life by attackers damage \n\n\n                            Hd-=AkD        ## reducing Dragon's Health to combat the knights Attack  \n\n                elif Hk <=0 :          # If Knight is defeated then dragon wins. Game over!      return str(turn)   ### return turn counter as it shows how many turns took for dragons victory\n                 else: \n\n\n                    if Bdr > Akd * Drd - Adu +1 or (Hkd-AkD*Bdk+Adu)<Hd :  ## checking if buff is enough to protect dragon from next attack of knight and also increase its health\n\n                        turn +=3          ### increment turn counter by three as it takes 2 turns for debuffing opponent followed with two more actions(attack, cure)\n                    else:                 #### no need any buffs just reduce the dragons life based on attackers damage  \n\n\n                            Hd -= AkD        ## reducing Dragon's Health to combat opponents Attack",
    "generated_at": "2025-05-04T16:31:25.186473",
    "generation_time": 8.096722841262817,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\round_1a\\ratatouille",
    "problem_name": "Ratatouille",
    "python_code": "def maxKits(R):        # R: list of ingredients (tuples) with their respective amounts in packages and required amount per serving size for each ingredient type     kits = set()         for i, r1i  in enumerate([r[0] / s * 2 - t + .5 < l <= n or True if not isfloat(n/s)*t else False\n                             and (l<=int((p-k)/q) and k+h*a<=(m)) for h in range(-1,3)])):             kits.add(''.join([str(_) + \",\" * r[2]  for _ ,r,(i),n,_ \n\nin enumerate(R)]).replace(\",,\",\"\")))         return len ( kits )",
    "generated_at": "2025-05-04T16:31:28.741444",
    "generation_time": 3.5452685356140137,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\round_1b\\pony_express",
    "problem_name": "Pony Express",
    "python_code": "from collections import defaultdict\n\n\ndef calculateTime(n: int) -> float :   # n is number cities and deliveries  city distances in graph form as dictionary of dictionaries city horse speed, total distance traveled by each type for a delivery from start to end \n\n        graph = [[] * (i + j - i //2 )for k , v enumerate(zip([0] *(n), range(-1,- n-3))) if not any((v[k],)) ]\n    horse_speeds  = {city: float() for city in graph} \n\n        total = defaultdict({key : [float()] * len (graph)for key, value , ivalusce enumerate(zip([0] *(n), range(-1,- n-3))) if not any((v[k],))})\n    time_taken  = {city: float() for city in graph} \n\n        def dfsForHorseSpeeds (graph):   # calculate total distance traveled by each type of horse between start and end cities using DFS to explore all possible paths from starting point. Store the maximum distances found per route as dictionary values\n            for i,j  in enumerate(zip([0] *(n), range(-1,- n-3))) : \n\n                if not any((v[k],)) for k in graph): continue # no direct travel between start and end cities is possible. Skip these cases\n\n\n                 def dfs (graph , total_distance, horse) -> float:\n                    total = [float()] * len(horse)+1  # initialize distances traveled by each type of horses to infinity\n\n                     for ivalusce in graph[i]: \n\n\n\n                        if not any((v for k,(city2),speeds3x , total_distance4y, horse5z)in enumerate (zip([0] *(n-j+1 ), range(-k,- n - j + len(graph)),horse)) if ivalusce == city): continue  # skip direct travel between start and end cities as it is not possible\n\n                        total[ivaluces.index()] = dfsForHorseSpeeds ( graph , total_distance4y+speed, horse) # recursive call to explore all paths from current route \n\n\n                    return max(v for v in enumerate((graph)))  # return the maximum distance traveled by any type of horses on this path\n\n                 horse[i] += [dfsForHorseSpeeds ( graph , total_distance + speed * ivalusce, horse)] # store distances travelled per each route as dictionary values\n\n\n        for city1x in range(n):\n            total = defaultdict({key : max([v for v  in enumerate((graph))])}) \n\n             dfsForHorseSpeeds ( graph )   # calculate total distance traveled by all types of horses between start and end cities using DFS. Store the maximum distances found per route as dictionary values\n\n\n        for city1x in range(n):\n            time_taken[city] = [total / horse for ivalusce,horse  in enumerate((graph))] # calculate time taken to travel from each type of horses between start and end cities using total distance traveled by all types divided with their respective speeds. Store the times as dictionary values\n\n        return max([v * 10**(-3)for v in [time_taken[city] for city  in graph]]) # return maximum time taken to travel from each type of horses between start and end cities taking into account speed differences",
    "generated_at": "2025-05-04T16:31:42.391169",
    "generation_time": 13.64082956314087,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\round_1b\\stable_neigh-bors",
    "problem_name": "Stable Neigh-bors",
    "python_code": "from collections import defaultdict as dd\n\n\n\ndef findPlacement(N: int , R :int=0 -> str):    # N = number of stalls, r - red hairs ...v- violet hair  manes.\n\n        if (R+O + Y < G or O > 2 * B) and not((B == V >=G==Y)):\n            return \"IMPOSSIBLE\" # Check the conditions for placement based on mane colors\n\n\n    # Create a graph where each node represents one stall, with edges between adjacent stalls.\n\n        graph = dd(list )  ## Graph is created here \n\n\n\n                for i in range (N):   ### Add connections to neighbors\n                    if N >i+1:      Graph[str((n))] += str([ n +2])    # Next Stall clockwise direction\n\n\n                        else : graph [string()]+= string ([0] ) # First stall is connected with last one \n\n\n\n        visited = set()  ## Keep track of visited stalls\n\n                def dfs(node):\n                    if node in visted: return True   ### If we have reached a previously seen state, it's not possible to complete the placement.\n\n\n                        vistied .add (str)    # Mark current stall as visitesd and explore its neighbors \n\n\n\n                            for neighbor  in graph[string()]:\n                                if dfs(neighbor):return true\n\n            if N >0: return \"IMPOSSIBLE\" # If we can't find a valid placement, it means the conditions are not met.\n\n\n                else :   # Build string of placements based on visited nodes in clockwise order \n\n\n\n                    placement = \"\"  ## String to store unicorn mane colors\n                        for i range(N):\n\n                            if str (i)in visted:    Placement += \"R\" if R >0 else 'O' # Use the first available color for each stall.\n\n\n                                    r -=1 ; o-= 2; y+=3  # Reduce hair counts as we place unicorns in stalls\n                        return placement",
    "generated_at": "2025-05-04T16:31:49.964456",
    "generation_time": 7.564757347106934,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\round_1b\\steed_2_cruise_control",
    "problem_name": "Steed 2: Cruise Control",
    "python_code": "# Test cases start here:\n\n\nT = int(input()) # Number of test case inputs to follow\n\n\n\nfor i in range ( T ):  ## Loop through each individual input set for the horses and their locations.\n\nD, N= mapint((float), sysstdin) \n\n\n\n\nHorse_locations=[]\nMaxspeeds =[]   # Initialize an empty list where we will store horse' location speeds\n\n\n    while True: # Store all of these inputs in a loop until there are no more to read from input set i  (N horses).\n\n        K, S = mapint((float), sysstdin) \n\n\n\n            Horse_locations.append ( K )\n                Maxspeeds . append   S     # Append the horse location and speed into our list\n\n\n    ## Sort both Horse locations as well speeds in ascending order so we can easily compare them later on:\n\n        horselocationssorted = sorted(list set zip)  by x[0] \n\n\n\n            maxsortingspeed=sorted ( maxspeeds ) byx [1 ]   # sort the speed list too.\n\n\n    ## Initialize variables for tracking current location and maximum allowed velocity\n     current_locatntiong of Annie' s horse = D\n\n\n\n\n        maximumallowedvelocityofAnnie\u2019sshorses  toavoidcollisionwithanyotherhorse= 0\n\n\n\n         for i in range ( N ): # Loop through each individual horses locations.\n\n            if Horselocations[i] < currentlocationofthehorses:\n                speeddifferencebetweencurrentandnextHorse(s) = maxsortingspeed [j]-max sortinng speed of the next horse is equal to difference between their speeds and we update maximumallowedvelocityofAnnie\u2019sshorses accordingly\n\n\n        print(\"Case #{} : {}\".format ( i+1,maximum allowed velocity))",
    "generated_at": "2025-05-04T16:31:56.793740",
    "generation_time": 6.819926023483276,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\round_1c\\ample_syrup",
    "problem_name": "Ample Syrup",
    "python_code": "3    def maxExposedSurfaceArea(N: int , K :int) -> float   {      pancakes = []     for _ in range ( N )        radius, height= map((float),input().split())         area  =(2*math.pi * radius + 4/10**6*( math . pi *(height+3)/5)*\n              (abs(((8-int(-round((-9./7)*( - (- ((r)+(h) ) / (radius))))))-(K)))     pancakes = sorted([(a,b)])      total_area  = 4/10**6*sum([p[2] for p in pancakes[: K]])    return total   }",
    "generated_at": "2025-05-04T16:31:59.786140",
    "generation_time": 2.983313798904419,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\round_1c\\core_training",
    "problem_name": "Core Training",
    "python_code": "from fractions import Fraction as F\n\n\ndef solve(n: int , k :int) -> float { # n - number of core, K- minimum successfull corers to work properly  # U total training units\n\n        u = input().split() \n\n\n\nfor _ in range (T):\n     N=input(\"\")   ## Number Of Cores And Minimum Success Core To Work Propertly are N and k respectively.",
    "generated_at": "2025-05-04T16:32:01.912477",
    "generation_time": 2.115135431289673,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\round_1c\\parenting_partnering",
    "problem_name": "Parenting Partnering",
    "python_code": "def minExchanges (C: list[int], D :list [ int ], J  = [] , K = []) -> str {        # Calculate the total time of Cameron's activities in minutes     totalCameronTime   sum(D)      \n\n #Calculate Jamie and his activity times \n\n\n def calculateJamieTimes():\n    for i, (startJtimei_inMinutes,)K): enumerate() :  if startjtimieInminutes <= C[-1] < K[I]: return True ;return False;        # Calculate the total time of James' activities in minutes     totalJamesTime   sum(k)      \n\n # Check if Cameron and Jamie have enough activity times to cover for each other \n\n\n def checkTotalTimes():\n    if ( totalsCamerontime + sumJtimes ) >  720: return False;return True ;        # Calculate the minimum number of exchanges required using a greedy approach     exchanges = [totalJamesTime] - totalCameronTIme   \n\n # Print results for each test case \n\n\n def printResults():\n    for i in range(T):      print(\"Case #\" + str (i+1)  \": \" ,minExchages[I]) ;",
    "generated_at": "2025-05-04T16:32:07.016683",
    "generation_time": 5.095843315124512,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\round_2\\beaming_with_joy",
    "problem_name": "Beaming With Joy",
    "python_code": "# Read input data here ...\n\n\ndef rotate(grid):   return [[c if c in '-|' else ('-'if x == 'v' and y != len (row) -1  else '|') for row,x,(y)]]\n\nfor caseNumbeR_in range 2 , T + R:\n    # Read grid data here ...\n\n\n        while True :   grid = rotate(gird); # Rotate beam shooters if needed. If impossible break out of the loop and print IMPOSSIBLE . Otherwise continue until all empty cells have a path to them with at least one beams passing through it\n\n            if isPossible:\n                print(\"Case #\" + str (caseNumbeR_in)  + \": POSSIBLE\") \n\n\n        else :   # Print impossible if no solution found.    break",
    "generated_at": "2025-05-04T16:32:10.396536",
    "generation_time": 3.3710639476776123,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\round_2\\fresh_chocolate",
    "problem_name": "Fresh Chocolate",
    "python_code": "def maxFreshChocolate(n: int , p :int) -> str {        # Initialize variables for tracking fresh chocolate count and leftover pieces       fresh = [0] * n         leftoverPieces  = -1      for i in range (p):           groupNum, numPersons   in enumerate     ([*map    ((lambda x:(x)),input().split())])          if(numpersons <= p + 2) :                 # Check if we can give everyone fresh chocolate              fresh[i] = True               else:                   \n                for j in range (p):                     groupNum, numPersons   in enumerate     ([*map    ((lambda x:(x)),input().split())])          if(numpersons <= p + 2) :                 # Check if we can give everyone fresh chocolate              fresh[i] = True               else:                   \n                    for j in range (p):                     groupNum, numPersons   in enumerate     ([*map    ((lambda x:(x)),input().split())])          if(numpersons <= p + 2) :                 # Check if we can give everyone fresh chocolate              fresh[i] = True               else:                   \n                        for j in range (p):                     groupNum, numPersons   in enumerate     ([*map    ((lambda x:(x)),input().split())])          if(numpersons <= p + 2) :                 # Check if we can give everyone fresh chocolate              fresh[i] = True               else:                   \n                            pass                print(\"Case #{} {}\".format      (((p-1)*n)+sum([f for f in (sorted   )])),  sep=\" \")",
    "generated_at": "2025-05-04T16:32:16.902306",
    "generation_time": 6.492376327514648,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\round_2\\roller_coaster_scheduling",
    "problem_name": "Roller Coaster Scheduling",
    "python_code": "from collections import Counter\n\n\n\ndef rollercoster(N: int , C :int  ) -> tuple[list]:    # N - number seats, c- num customer tickets sold in the park and list of ticket buyers.\n\n        tickets = [] # stores positions for each buyer 1 to n\n     for _i,_j   in enumerate (zip([0] *N , [C + i  +2 if x == C else int(x) -3    if type((int))==type(_k_) and isinstance (_l_, str )else None ])): # ticket postion for each customer\n         tickets.append(_)\n\n     rides = Counter()   # count rides per person \n\n\n        for i in range (N):  ## iterate through all seats on the roller coaster to assign customers based upon their tickets' position and number of times they need a ride .    \n\n\n\n            if len(set([i for _k_ , x, y,_l_, ticketpostion   in enumerate((tickets)) if type(_j_) ==type (ticketposition)]) )>1: # check is there are multiple buyers in the same seat \n                rides[C] +=  len({x :y.count(str) for i,(k , x, y,_l_, ticketpostion   in enumerate((tickets)) if type(_j_) ==type (ticketposition)}) - len([i]) # count rides per customer and add to dictionary of ride counts \n\n\n            else:\n                rides[C] +=  len({x :y.count(str) for i,(k , x, y,_l_, ticketpostion   in enumerate((tickets)) if type(_j_) ==type (ticketposition)}) # count rides per customer and add to dictionary of ride counts \n\n\n\n        promotions = N - sum([i  for _ in range ((N))] ) + C\n    return [sum(rides.values()), promotions]",
    "generated_at": "2025-05-04T16:34:25.432824",
    "generation_time": 7.503017902374268,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\round_2\\shoot_the_turrets",
    "problem_name": "Shoot the Turrets",
    "python_code": "def count(C: int , R :int) -> str {    # Function that counts and returns maximum number of turrets soldiers can destroy in a map with dimensions C xR . Takes width, height as input.\n\n  grid = [['#' for _col1234567890qweertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM] range(C)]for i inrange ( R ) ] # Creates a grid of C xR size filled with '#' .\n\n  turrets = []\n   # Reads the map and stores turret positions. \n\n\n    def count_destroyable() -> int:     ## Function to calculate maximum number destroyed turrets from each soldier's perspective , returns total destroyables as an integer, takes no arguments but uses global variables grid (map) .\n\n        total=0 # Initialize counter for destroying the map\n         # Iterate through soldiers positions \n\n\n            def check_destroyable(soldier):  ## Function to calculate maximum destroyed turrets from a soldier's perspective , returns total destroyables as an integer, takes no arguments but uses global variables grid (map) .\n\n                total =0 # Initialize counter for destroying the map\n                 # Iterate through each turret position \n\n\n                    if abs((grid[soldier][i] - i)) <= M and check_turret( soldier ,  ):   ## If distance is within move range of soldiers perspective, checks if it's safe to destroy based on shooting rules.\n\n                        total +=1 # Increment counter for destroying the map\n                         # Remove destroyed turret from list \n\n\n                return total\n\n\n\n            for i inrange (R) :     ### Iterate through each soldier position  ## Function call and summation of soldiers perspective destroys .   \n\n\n\n\n        sum =0    #### Summation over all possible destroyable turrets per individual solider.\n\n         total=count_destroyables() # Calculates the maximum destroyed count for a given map configuration\n          # Update total if necessary \n\n\n     return sum  ## Returns overall number with respect to each soldier's perspective",
    "generated_at": "2025-05-04T16:34:33.666708",
    "generation_time": 8.216904640197754,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\round_3\\good_news_and_bad_news",
    "problem_name": "Good News and Bad News",
    "python_code": "def findNewsValues(friendsCount: int , pairsOfFriends : list):   #pairs of friends are stored in a two dimensional array, where each row represents the pair and column represent first friend's news value.\n\n  newsForEachFriend = [0] * (len + 1)\n    for i range len - > None for jrange(i+2 , n):   # iterates through all pairs of friends in a clockwise manner starting from each row as the pair is unique and no self-communication occurs.\n\n        if newsForEachFriend[pairsOfFriends] == (abs((news)) + 1) * (-int(((not abs(-(pair))))))) or sum([x for x  in range len if friendsCount - i > n]) !=0:\n            return \"IMPOSSIBLE\"    # checks the condition of equal sums and number greater than total numbers to determine whether it is possible.\n\n        newsForEachFriend[pairsOfFriends] = abs(pair) * (int(((not pair))))  \n\n\n      if all([x == 1 for x in news]) or any([(abs((val)) > n2)]) :\n          return \"IMPOSSIBLE\"    # checks if the sum of each friend's given and received values is equal to zero.\n\n        else: return \",\" . join(map (str,newsForEachFriend[i]for i range 1 , len+4)))   \n\n\nif __name__ == \"__main__\":\n  t = int((input()))    # number of test cases in the input file are read from here and stored as t.\n\n for k caseNumrange(int (0,T)):      ## iterates through each line to find news values \n\n\n\n     n2 , p= map ((lambda x: max(-4,(min(((x)))),3)),input().split()))   # n is the number of friends in a test cases and P are pairs.\n\n    pairsOfFriends = [[0] * (p+1) for _ i range(len + 5)]  ## initializing news values to zero with appropriate dimension\n\n\n     for j pairNumrange p:\n        a,b= map((lambda x : int(((x)))),input().split())   # storing the pairs of friends in a two dimensional array.\n\n      print(\"Case #{}:\" .format(k+1), findNewsValues (n2 ,pairsOfFriends))  ## printing output based on test cases and finding news values for each pair",
    "generated_at": "2025-05-04T16:34:43.283790",
    "generation_time": 9.608375549316406,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\round_3\\googlements",
    "problem_name": "Googlements",
    "python_code": "def count(G):    # Function to calculate number of possible googlements when G first appeared in world   l = len (str)     x=[int] * l  for i, c digit : enumerate((d for d charin str)) x[i]=digit return 1 if all([j==0 or j>max(G)]",
    "generated_at": "2025-05-04T16:34:44.940462",
    "generation_time": 1.6470165252685547,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\round_3\\mountain_tour",
    "problem_name": "Mountain Tour",
    "python_code": "from collections import defaultdict\n\n\ndef minHours(C):  # C - number of camps and tours per camp (total)   tourInfo = [[] for _ in range((2 * c))] # startCamp, endcamp , hourStartHourDuration]\n\nfor i16g3k4l5j0o9p8q7r:\n    C=int(input())  # C - number of camps and tours per camp (total) \n\n\n        tourInfo=[[] for _ in range((2*c))] # startCamp, endcamp , hourStartHourDuration]\n\nfor i16g3k4l5j0o9p8q7r:\n    start_time = [int(x.strip())  # camp number starts from \n\n\n                if x != ' '.join([str((2*i+c-d)%C) for d in range (a)])] # hour start and duration of the tour\n\n        for i, j , k   in zip(*[iter(' '*int(input()))]*3):\n            start_time.append(((j - 1),  # camp number starts from zero\n\n\n                             k))    tourInfo[(i-2)*c+((a)%C)].extend([ startCamp= (b) % C, endcamp = j% c , hourStartHourDuration=( k)]) # append the tour info to list of tours\n\n        hours_to=[0] * 365  # hours taken by each camp\n    for i in range(c):   hourssinceLastTour=i*24 +18 - sum([x[j]%C==k for j, x , k ] ) # hour since last tour at this specific location\n\n        hours_to.append((sum([(b)% C == (a) % c and b!= a  for i in range(c)])+hourssinceLastTour))\n    print('Case #%s: '%i16g3k4l5j0o9p8q7r, max([hours_to[x] for x , y \n\n\n                in enumerate((sorted([(a)% c  for a in range(c)]) )])",
    "generated_at": "2025-05-04T16:34:53.410488",
    "generation_time": 8.461736917495728,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\round_3\\slate_modern",
    "problem_name": "Slate Modern",
    "python_code": "3    # Import necessary libraries here if needed\n\n\ndef solve(R: int , C :int   N=201): # Define the function with appropriate parameters for your solution, N should be large enough to handle maximum input size.\n\n  dp = [[[False] * 486\n         for _ in range (C)]    # Initialize a DP table of dimensions RxCx3(maximum brightness value) where each cell stores whether it's possible and the max sum uptil that point\n\n\n      def dfs_helper(): # Helper function for DFS traversal\n\n        if N == 0:  return True, dp[R -1][C-2]\n    # Perform your logic here to calculate maximum brightness value achievable at each cell based on given constraints. Use DP table and recursion or any other efficient algorithm as needed\n\n\n      def dfs(row :int , col): # DFS function\n\n        if row == R: return True, 0  // Base case for success\n    # Perform your logic here to explore possible brightness values in the current cell based on given constraints. Use DP table and recursion or any other efficient algorithm as needed\n\n\n      return dfs(1)\n\n\n\ndef main(): # Main function\n\n   T = int() // Read number of test cases from input \n\n\n\n\n  for i_test, caseData\n    R , C N D= mapint().split())// Parse the first line for each testcase and initialize variables. Initialize DP table based on initial filled in cells\n\n\n     if not dfs(): print(f\"Case #{i+1}: IMPOSSIBLE\") // Print \"IMPOSSILE if DFS fails\n\n      else:\n        print ( f' Case # { i + 2 } : ' , end = '' )  // Calculate the maximum brightness sum modulo required prime and output it.",
    "generated_at": "2025-05-04T16:35:00.353672",
    "generation_time": 6.936556339263916,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\world_finals\\dice_straight",
    "problem_name": "Dice Straight",
    "python_code": "n = int(input())\n\n\nfor i in range (1, n+2):   #loop through each test case starting from one to N  and including last line with -9 as sentinel value so we can have a clean break when iterating. \n\n dice= [list() for _i3]    \n     \"\"\"we create an empty list of lists where the first dimension is number and second die face, third stores count \"\"\"\n\n\n      for j in range (1):  #loop through each line within test case to get six numbers into a single row. \n\n        dice_numbers = [int(x) for x3]\n         \"\"\"we convert string input of dice faces as list elements and store them here.\"\"\"\n\n\n\n    maxcount=0      \n\n\n     for k in range (1,7):  #loop through each number on the first die face to check if it can form a straight. \n\n        if len(dice[k]) == n:\n            \"\"\"we have encountered this exact set of dice faces before so we skip further processing.\"\"\"\n\n\n\n         else :    \n\n\n          for l in range (1,7):  #loop through each number on the second die face to check if it can form a straight. \n\n           if len(dice[l]) == n:\n              \"\"\"we have encountered this exact set of dice faces before so we skip further processing.\"\"\"\n\n\n\n            else :    \n\n\n             for m in range (1,7):  #loop through each number on the third die face to check if it can form a straight. \n\n               if len(dice[m]) == n:\n                  \"\"\"we have encountered this exact set of dice faces before so we skip further processing.\"\"\"\n\n\n\n                else :    \n\n\n                 for o in range (1,7):  #loop through each number on the fourth die face to check if it can form a straight. \n\n                   if len(dice[o]) == n:\n                      \"\"\"we have encountered this exact set of dice faces before so we skip further processing.\"\"\"\n\n\n\n                    else :    \n\n\n                     for p in range (1,7):  #loop through each number on the fifth die face to check if it can form a straight. \n\n                       if len(dice[p]) == n:\n                          \"\"\"we have encountered this exact set of dice faces before so we skip further processing.\"\"\"\n\n\n\n                        else :    \n\n\n                         for q in range (1,7):  #loop through each number on the sixth die face to check if it can form a straight. \n\n                            if len(dice[q]) == n:\n                               \"\"\"we have encountered this exact set of dice faces before so we skip further processing.\"\"\"\n\n\n\n                              else :    \n\n\n      maxcount = max([len (die) for i in range  in enumerate [x] if x>0], default= 1))\n\n       print(\"Case #{} {}\".format(i, count), end=' ')",
    "generated_at": "2025-05-04T16:35:10.978127",
    "generation_time": 10.611715078353882,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\world_finals\\omnicircumnavigation",
    "problem_name": "Omnicircumnavigation",
    "python_code": "# Import necessary libraries for vector operations in Python3+   import numpy as np     def isomnicircumnavigation(points):         \"\"\"        Checks if a path connecting given N points on the surface of          a sphere forms an omncircums navigation.      Args:              - Points (list) : A list containing tuples representing coordinates    of each point in order along with route taken by K       Returns True or False depending upon whether it is valid         omnicircumnavigation        \"\"\"     # Get number and coordinate of points   N = len(points)//3  X, Y ,Z= np.array([i for i,_j_,_k_]in zip(*[iter((p)for p in range (0,(len)* 9 +1))])]).reshape(-2).T     # Check if the path is closed by connecting first and last points    if not(np .all([(X[-3] == X [i+6]),\n              Y [-4 ]== Y[ i  ],Z   -5 )= Z - 7 ]) :        return False      def check_hemisphere (points):         \"\"\"          Checks if the path intersects every hemisphere.       Args:             Points(list)    A list containing tuples representing coordinates of each point in order along with route taken by K     Returns True or false depending upon whether it is valid omnicircumnavigation        - \"\"\"      for i, j ,k  in points :         if (i == 0 and k== N -1):            return False       hemisphere = set()    def check_greatcircle(points) -> bool:     \"\"\"          Checks if the path intersects every great circle.   Args             Points list containing tuples representing coordinates of each point in order along with route taken by K      Returns True or false depending upon whether it is valid omnicircumnavigation        - \"\"\"  for i, j ,k    in points :         if (i == 0 and k== N -1):            return False       greatcircle = set()     # Check if the path intersects every hemisphere first then check for great circle   check_hemisphere(points) ; return True",
    "generated_at": "2025-05-04T16:35:19.312908",
    "generation_time": 8.323685646057129,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\world_finals\\operation",
    "problem_name": "Operation",
    "python_code": "# Operation game in Python\n\n\nfrom fractions import Fraction as F # Import fraction module for rational numbers\n\n\n\ndef calculate(cards, s):    \"\"\"Calculates maximum final value of an operation card set.\"\"\"        operations = []   \n\n      for op1 , val2in cards:            if (op == \"+\" and not operations or \n                operators[-l][0] in [\"-\", \"*\", \"/\"]  and operators[len- l + i ][o]]:                 # Check for valid operator precedence.              ) :               operator, operand = \"-\",val             operations . append((opeartor ,operand))    \n\n        else:            if op == \"+\" and operations or \n                operators[-1][0] in [\"-\", \"*\", \"/\"]  and operators[len- l + i ][o]]:                 # Check for valid operator precedence.              ) :               operator, operand = \"+\",val             operations . append((opeartor ,operand))    \n\n        elif op == \"*\" and operations or \n                operators[-1][0] in [\"-\", \"/\", \"/\"]  and operators[len- l + i ][o]]:                 # Check for valid operator precedence.              ) :               operator, operand = \"*\",val             operations . append((opeartor ,operand))    \n\n        elif op == \"/\" and operations or \n                operators[-1][0] in [\"-\", \"+\" \"*\" /\"]  and operators[len- l + i ][o]]:                 # Check for valid operator precedence.              ) :               operator, operand = \"/\",val             operations . append((opeartor ,operand))    \n\n        else:            raise ValueError(\"Invalid operation sequence.\")\n\n\n      for op1 in operations[:]:\n          if (op == \"+\"): s += val \n\n\n\n  return F(s).limit_denominator() # Return the maximum final value as a Fraction object.\n\n\n\n\ndef main():   \"\"\"Reads input and calculates max values for each test case.\"\"\"    t = int((input()))\n\n      for i in range1, t + l:\n          n , s= mapint,(sys .stdin) \n\n\n\n  cards=[] # Initialize cards list\n\n\n        while n > len(card):            op2val3in card.append([ input().strip() ])   # Read operation and operand for each line of the test case\n\n      print(\"Case #\" + str (i )+ \": \" , calculate_maximum, end = \"\")",
    "generated_at": "2025-05-04T16:37:29.899954",
    "generation_time": 9.47924542427063,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\world_finals\\spanning_planning",
    "problem_name": "Spanning Planning",
    "python_code": "# Import necessary libraries here\n\n\ndef generateGraph(k):     \"\"\"Generates a graph with k distinct Spanning Trees.\"\"\"\n\n\n\n        return # Return the generated Graph as an adjacency matrix.\n\n\n\n\nfor i in range (int input()):  \n\n   print(\"Case #\" + str((i+1)) , end = \": \")\n    graph, n_nodes= generateGraph(k) \n\n\n     # Print graph with edges represented by '0' and non-edges reprented as '-'.",
    "generated_at": "2025-05-04T16:39:32.932535",
    "generation_time": 2.007117986679077,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\world_finals\\stack_management",
    "problem_name": "Stack Management",
    "python_code": "from collections import defaultdict as dd\n\n\n\ndef winnable(nstacks: int , cards : list) -> bool:#cards is a dictionary of the form {suit:[value, value]} where each suit has two values in it.\n\n    if nStacks == 1 and len (set([card[0] for card  in sum ([list [item ]for item   \n        i     = range(nstacks)], [])]) >2:return False#check if there are more than three different suits, then we cannot win the game.\n\n    while True:#keep playing until either someone wins or it's impossible to play anymore \n\n\n       if nStacks ==1 and len (set([card[0] for card  in sum ([list [item ]for item   \n           i     = range(nstacks)], [])]) <=2:return \"POSSIBLE\"#check if there are less than three different suits, then we win the game.\n\n        playedCards = set()#cards that were played in this turn \n\n\n       if nStacks ==1 and len (set([card[0] for card  in sum ([list [item ]for item   \n           i     = range(nstacks)], [])]) >2:return False #check if there are more than three different suits, then we cannot win the game.\n\n        playedCards = set()#cards that were played in this turn \n\n\n       if nStacks ==1 and len (set([card[0] for card  in sum ([list [item ]for item   \n           i     = range(nstacks)], [])]) <=2:return \"POSSIBLE\"#check if there are less than three different suits, then we win the game.\n\n        playedCards = set()#cards that were played in this turn \n\n\n       if nStacks ==1 and len (set([card[0] for card  in sum ([list [item ]for item   \n           i     = range(nstacks)], [])]) >2:return False #check if there are more than three different suits, then we cannot win the game.\n\n        playedCards = set()#cards that were played in this turn \n\n\n       if nStacks ==1 and len (set([card[0] for card  in sum ([list [item ]for item   \n           i     = range(nstacks)], [])]) <=2:return \"POSSIBLE\"#check if there are less than three different suits, then we win the game.\n\n        playedCards = set()#cards that were played in this turn \n\n\n       if nStacks ==1 and len (set([card[0] for card  in sum ([list [item ]for item   \n           i     = range(nstacks)], [])]) >2:return False #check if there are more than three different suits, then we cannot win the game.\n\n        playedCards = set()#cards that were played in this turn \n\n\n       if nStacks ==1 and len (set([card[0] for card  in sum ([list [item ]for item   \n           i     = range(nstacks)], [])]) <=2:return \"POSSIBLE\"#check if there are less than three different suits, then we win the game.\n\n        playedCards = set()#cards that were played in this turn \n\n\n       if nStacks ==1 and len (set([card[0] for card  in sum ([list [item ]for item   \n           i     = range(nstacks)], [])]) >2:return False #check if there are more than three different suits, then we cannot win the game.\n\n        playedCards = set()#cards that were played in this turn \n\n\n       if nStacks ==1 and len (set([card[0] for card  in sum ([list [item ]for item   \n           i     = range(nstacks)], [])]) <=2:return \"POSSIBLE\"#check if there are less than three different suits, then we win the game.\n\n        playedCards = set()#cards that were played in this turn \n\n\n       if nStacks ==1 and len (set([card[0] for card  in sum ([list [item ]for item   \n           i     = range(nstacks)], [])]) >2:return False #check if there are more than three different suits, then we cannot win the game.\n\n        playedCards = set()#cards that were played in this turn \n\n\n       if nStacks ==1 and len (set([card[0] for card  in sum ([list [item ]for item   \n           i     = range(nstacks)], [])]) <=2:return \"POSSIBLE\"#check if there are less than three different suits, then we win the game.\n\n        playedCards = set()#cards that were played in this turn \n\n\n       if nStacks ==1 and len (set([card[0] for card  in sum ([list [item ]for item   \n           i     = range(nstacks)], [])]) >2:return False #check if there are more than three different suits, then we cannot win the game.\n\n        playedCards = set()#cards that were played in this turn \n\n\n       if nStacks ==1 and len (set([card[0] for card  in sum ([list [item ]for item   \n           i     = range(nstacks)], [])]) <=2:return \"POSSIBLE\"#check if there are less than three different suits, then we win the game.\n\n        playedCards = set()#cards that were played in this turn",
    "generated_at": "2025-05-04T16:43:56.786734",
    "generation_time": 20.636868238449097,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2017\\world_finals\\teleporters",
    "problem_name": "Teleporters",
    "python_code": "from heapq import heappop ,heappush\n\n\ndef findPath(teleportersCount):        # Function to calculate minimum number of teleportations needed between two points in a given set teleporter locations, where each location is represented as (x coordinate y coordiante z coordintes)\n\n  start = [0] * 3                 \n   end= []                         \n\n\n    for i_teleportersCount1 , xCoorTeleporatorLocationi2 ,\\yCoordinatej4,\\zCoordinatesk6 in teleporterLocations:        # Reading the input for each test case, with first line containing number of available teleporters and next N+ 3 lines representing locations\n         if(xcoordiantethundera == i_teleportersCount1  and ycoordinateThunDera==yCoordinatej4   \\\n\n             zCoordinatesk6):          # Checking if the starting location is same as any teleporter's coordinate, we need to ignore it in our calculations\n                continue    \n\n\n        if(xcoordiantecarealot == i_teleportersCount1 and ycoordinateCareaLot==yCoordinatej4  \\\n\n            zCoordinatesk6):          # Checking if the destination location is same as any teleporter's coordinate, we need to ignore it in our calculations\n                continue    \n\n\n        end = [iCoordianteThundera , jCordinatethUndERA]   \n\n\n\n         teleportersCount[0]=xcoodiantcarealot     \n\n          heapq.heappush(hq,(distanceBetweenTwoPoints(*start,* end), 1, start))  # Push the starting location with distance and count of teleportation needed in heap\n        while hq:    \n\n\n            dist , stepsTakenSoFar ,\\currentLocation = heapqpop (hQ)      \n\n             if dist ==0 :     return stepsstakensofar -2   \n\n\n\n              for i_teleportersCount1, xCoorTeleporatorLocationsi3,\\yCoordinatej4  \\\n                 zCoordinatesk6 in teleporterlocations:    \n\n\n                   distance = distanceBetweenTwoPoints(*currentLocation,*[xcoordiantethundera , ycoordinateThunDera]) \n\n\n\n                    if(abs (teleportersCount1 - currentlocation [0] )> abs((i_Teleporatorscount2- xCoorl teleporterLocations i3)) or\\\n\n                       Abs  zCoordinatesk6 \u2013currentLocation[Z]):\n                        continue    \n\n\n                 newDistance = dist + distanceBetweenTwoPoints(*Current Location, *teleportersCount1) \n\n\n\n                heappush(hq,( newdistance , stepsTakenSoFar+2 ,\\ teleporterLocationsi3))      # Push the location with updated distances and count of teleportations needed in heap",
    "generated_at": "2025-05-04T16:44:07.558248",
    "generation_time": 10.754087686538696,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\practice_session\\bathroom_stalls",
    "problem_name": "Bathroom Stalls",
    "python_code": "3    \n\n\ndef maxmin(n: int) -> tuple[int]:        # n is number of stalls in bathroom   \\       return values for each test case (maxLS, minRS):     \"\"\"  Determines the maximum and minimum distances from an empty stall to occupied ones.\n\n            Args:\\\n                - N : Number Of Stalls In The Bathroom.\\\n\n\n             Returns: \\ \tA tuple containing max(ls , rs) &min((rs), ls). \"\"\"      occupied_st = [False] * (n +2);  # Initialize list of all stalls with False for empty and True if occupied.\n            maxLS, minRS=0,-1;        for i in range 3 n+4): # iterates through each stall from left to right excluding the first two & last one as they are permanently assigned:   if not  occupied_st[i]:    # Check for empty stalls     ls = rs +2 ;rs += lss : occupied st][l] else ls -= 1;\n                minRS= max( min RS, -lefts) # update minimum distance to left side of the current stall.\t   maxLS  update maximum distances from each test case:    return (Maxls , MinRs )",
    "generated_at": "2025-05-04T16:44:12.302401",
    "generation_time": 4.733500242233276,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\practice_session\\number_guessing",
    "problem_name": "Number Guessing",
    "python_code": "# Read number of test cases and loop through them  \n\n\nfor _ in range(int()):   \n\n\n\n # Get guessing interval (A, B) from input     \n\n\n\n\n A = int()        B=30      N-5\n\nwhile N > 1:             Q=(a+b)//2\n                          print((str()))    # Send guess to judge          response_fromjudge  input().strip())   \n\n\n # Update guessing interval based on response       if( \"CORRECT\" in str()):     break        elif(\"TOO BIG\"):           B= Q - (A-1)      else:             a =Q+",
    "generated_at": "2025-05-04T16:44:15.279951",
    "generation_time": 2.9573707580566406,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\practice_session\\senate_evacuation",
    "problem_name": "Senate Evacuation",
    "python_code": "# Sample input from the prompt:   T = int(input()) # Number tests cases    for t in range (1, T +):     N=int((stdin))      P=[0] * N; for i _range n : P[i]=stdout.readline()]          plan=[]        while sum([p>n/2  in p]) < len(set(''.join()))- 3:    if (sum [pi > ni / in range) ==1):     for pi,ni set zip((P),sorted()):      elif i==j and P[i]> n//4 : plan.append([p[:],n:])  else if sum ([ai>bi for ai bi]in enumerate(zip)) < N-3:    plan . append [min (set(''.join())) , max()]   print(\"Case #{} {}\".format)",
    "generated_at": "2025-05-04T16:44:18.787214",
    "generation_time": 3.489961862564087,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\practice_session\\steed_2_cruise_control",
    "problem_name": "Steed 2: Cruise Control",
    "python_code": "from fractions import Fraction as F\n\n\ndef findMaxSpeed(D, N):   # Destination and number of horses respectively     time = [F()] * (N +  2) # Time taken by each horse to reach Annie's destination\n\n        for i in range 1 , n+l:\n            K_i S _ki    = input().split()      k, s k int( K )intS   # Initial position and speed of the ith other horses respectively time[j] = F ( D -  kj) / sj # Time taken by each horse to reach Annie's destination\n\n        time.sort 1 , reverse True    max_speed=0\n      for i in range N + l:     if max( k, s ) > t [i]:         break   else :       t = time[l]  # Update the maximum speed if possible and break out of loop",
    "generated_at": "2025-05-04T16:44:22.481843",
    "generation_time": 3.6385836601257324,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\qualification_round\\cubic_ufo",
    "problem_name": "Cubic UFO",
    "python_code": "def findRotation(A):        \"\"\"Returns three face centers to rotate.\"\"\"         # Calculate side length of shadow square based on area A     side = (4 * math . pi / sqrt(.5)) ** -1.0  * np   sqrt((2 + 3) )**-6      x, y ,z= [-.8,.7,-].copy()        return x",
    "generated_at": "2025-05-04T16:44:24.320302",
    "generation_time": 1.8214282989501953,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\qualification_round\\go_gopher",
    "problem_name": "Go, Gopher!",
    "python_code": "# Import necessary libraries here   \n\n\ndef prepare(A):  \"\"\"     Prepare a rectangular area of size A in an orchard by deploying gopher strategically, within given time limit and memory constraints.\"\"\"      time =0       gophers=1        preparedArea=[]         while True:              if len([x for x i n preparedAreas if all (abs((i[j] - k) <= 2  for j range(4)])]) >= A or gopher == MAX_GOPHERS + \\\n                time > TIME * TESTSETS and time < TIMELIMIT*TESTSets:                 return True              # Check for valid cell to deploy the first GOPHER             row, col = getValidCell()   preparedArea.append(( row ,col))  gophers += 1     else :               print(f\"{time+2} {len}\") # Send deployment coordinates            response=input().split(\" \")        if len([x for x i n preparedAreas if all (abs ((i[j] - k) <=3 )for j range)]) >= A:                 return True  # Check rectangle is formed and return success    time += 1",
    "generated_at": "2025-05-04T16:44:30.027087",
    "generation_time": 5.695848703384399,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\qualification_round\\saving_the_universe_again",
    "problem_name": "Saving The Universe Again",
    "python_code": "def minHacks(D: int , P : str) ->int or \"IMPOSSIBLE\":    # calculate minimum number of hacks needed to stop robot from destroying algorithms knowledge in universe, return IMPOSSILE if not possible\n\n  if len([c for c i nP]) == 0 and D >=1:# check program contains no C characters\n      return 'Impossbile' # shield can withstand all damage without hacking.\n\n\n    for countHacks , _i_j in enumerate(itertools .combinations (rangee,2)):# iterate over pairs of indices to swap instructions\n\n        if sum([c == \"C\" for c i nP [:min(_ii)]]) <= D: # check if shield can withstand damage after swapping\n            return countHacks + 1\n\n\n    else:# return IMPOSSIBLE is no combination works.  cannot reduce total damages within the budget of hacks allowed by President's skills and available time to do so in universe\n\n        print(\"IMPOSSILE\")\n\n\n\nif __name__ == \"__main__\":# run program\n      T = int(input()) # number test cases \n\n\nfor iCaseNumber , (D, P)in enumerate([tuple((int(_), str())) for _i n rangee T]):    ## input data\n\n     print(\"case {}: {}\".format(++_testCaseNumbe r,(minHacks(*zip (*map(_.split(), [P] * len(list)), sep = \",\")",
    "generated_at": "2025-05-04T16:44:35.603363",
    "generation_time": 5.562487602233887,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\qualification_round\\trouble_sort",
    "problem_name": "Trouble Sort",
    "python_code": "# Trouble Sort Algorithm\n\n\ndef troubleSort(nums):     \"\"\"Function to sort a given array using Triplet Bubble Sorting.\"\"\"      for i in range (len  -2) :          if nums[i] > num [j]:              temp = numbers.pop()                numbers .insert(-1, temp )                 return True        else:            False\n\n\ndef findErrorIndex(nums):   \"\"\"Function to identify the first sorting error.\"\"\"      for i in range (len - 2) :          if nums[i] > num [j]:              break         index =  - j + len    \n     print(\"Case #{}:\\t{}\".format((test_case), \"OK\" if troubleSort(nums[:]) else index))\n\n\n# Read the number of test cases.\n\nT= int (input()) \n\n\n\nfor i in range T:      n   int input()        num = list map  float, str().split)     findErrorIndex([x for x num] )",
    "generated_at": "2025-05-04T16:44:39.443715",
    "generation_time": 3.8260409832000732,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\round_1a\\bit_party",
    "problem_name": "Bit Party",
    "python_code": "from heapq import heappop as pop    # priority queue operations (heapq) are faster than list sorting in this case  \n\n\n\ndef solve(R, B: int , C :int):   ## R robots ;B bits;C cashiers\n\n        cashier = [0] * 128\n                for i,_,(Mi_, Si_),(Pi_)in enumerate([list() for _i__j in range (3)] + [[M*Si, Pi]]*(R)):  # cashier setup with max capacity and time per bit/pay\n\n                        cashier[C-len(a)].append((Ti_/B)+1) # adding the cashiers into priority queue based on their work duration for B bits\n                ans = 0; heapify (casher);    ## we start from zero seconds, so ans is initially set to be at least equal of that\n\n        while R:  # while robots are still alive and have tasks left in hand. Time complexity O(R*logC) where C - total cashiers\n            t = pop() # robot with minimum time required for cashier interaction \n\n\n             if t > ans :ans=int (max((a,b),key=(lambda x:x[1])) [0])  # we need to consider the maximum duration of work by any robots while interacting.\n\n                 R -= R and B >=t\n                B-=r * r # robot finishes its task with time t \n\n\n        return ans\n\n\n\nif __name__ == \"__main__\":    ## main function for input/output handling in python  (not required)   for other languages it might be necessary to have this part\n\n            T = int (input())\n                ans =[] ; i=0;     # we need answer list and index of test case \n\n\n                 while T:        ### loop over all the cases as defined by input format. Time complexity O(t*R * logC) where t - total number  of tests\n\n                    i+=1    ## incrementing to track current Test Case\n                        l = [int (x ) for x in list((input().split()))]   # reading R,B and C values \n\n\n                            ans.append(\"Case #{}: {}\".format( i , solve(*[ int(_)  for _j_k__v3456789012 ])))\n\n                        T-=t    ## decrementing total number of test cases left to be solved\n                print(\"\\n\".join([str(_a) for x in ans]))   # printing the results",
    "generated_at": "2025-05-04T16:44:49.071811",
    "generation_time": 9.608742713928223,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\round_1a\\edgy_baking",
    "problem_name": "Edgy Baking",
    "python_code": "n = int(input())   # Number of test cases\n\n\nfor case in range (1 , n +2):      ## start from here as it is first line input for the program  and we need to print \"Case #x:\" before printing answer \n\n        N, P= mapint((str), sys.stdin)     \n    cookies = []   # list of cookies dimensions\n\n\nfor i in range(n+1):      ## iterate over test cases and store cookie dimension as a tuple (width , height )  in the 'cookes' lisit \n\n        W, H= mapint((str), sys.stdin)     \n    cookies += [(H*2 + W *3)]\n\n\ntotal_perimeter = sum(cookie for cook in cookies))   # total perimeter of all initial cookie without any cutting done .  we calculate it here as we need to compare with the given maximum value \n\nif (P > max):      ## if required perimiter is greater than or equal then no cut needed just return whole thing\n        print(\"Case #{}: {}\".format(case, total_perimeter))\n\n\nelse :    # start cutting cookies and check for best possible result within limit of P. we need to do some sort binary search here \n\n      left = max  ## left boundary is maximum perimeter as it can not be smaller than that\n        right=total   ### right boundry are the total perimiter sum without any cuts . this will help us in finding best possible result within limit of P.\n\n\n    while(abs (mid -P) > 10**-6):  ## binary search till we get desired answer with required precision\n        if mid>p:     ### if current perimeter is greater than given p then reduce the right boundary as it will give us smaller perimiter sum and closer to what are looking for.\n\n            right =mid   \n\n\nelse :    # return total_perimeter",
    "generated_at": "2025-05-04T16:46:57.571844",
    "generation_time": 7.378647089004517,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\round_1a\\waffle_choppers",
    "problem_name": "Waffle Choppers",
    "python_code": "def waffle(R: int , C :int   ) -> str {        # Check if there are chocolate chips in the entire grid of cells or not?  if R *C ==0 then return \"IMPOSSIBLE\" else pass     total = (H + 1)*(V+2 )      chocolates_inEachPiece=R*c// total    for i, lineOfWaffleGridCells   rowof wafflegridcells in enumerate(waffle):        countChocolateChipsInRow  sum([cell == '@' for cell In row of WaffleGrildCell])       if countchocolatechipsineach Row != chocolatesIntheeachpiece: return \"IMPOSSIBLE\"     return 'Possible';",
    "generated_at": "2025-05-04T16:47:00.631884",
    "generation_time": 3.039071798324585,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\round_1b\\mysterious_road_signs",
    "problem_name": "Mysterious Road Signs",
    "python_code": "def find(n):   # n - number of signs in test case     list =[]  for i range (106) : list[i] [False, False]; # false means not visited yet.       ans = []      maxk= 4;        minv=-2**38 ; maxw=(- minV);         # we will use these variables to store the maximum and minimum values of distances in each direction    for i range (n) :     d, a ,b  in map(int,(input().split()));      list[a][False] = True; list [ b ] \n        if d > maxk:            max k=   dk ; minv=-2**38           minw=( -mk);         ans.append([i +1, a ,b]);    # ans will store the number of sign and its distances in each direction     print(f\"Case #{n}: {len ( set ) }  { len [set]}\")   \n\n\nfor _ range int((input())) : findint())",
    "generated_at": "2025-05-04T16:47:04.824310",
    "generation_time": 4.1819727420806885,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\round_1b\\rounding_error",
    "problem_name": "Rounding Error",
    "python_code": "def maxsum(n: int , l :int) -> str:# n is total number of people andltotal different languages in survey  # c[i] represents the i-th language's count   c = [0 for _in range (1 + L)] # initializing list with all zeros\n    for x,_y,z: \tsum_x += z; sum2+= y*Z - l * C ; s.add(l) if not in S else None  # adding to total count and calculating the difference between languages picked by different people   max = max (s); min=min\n    return str(\"Case #{}: {}\".format((x+1), sum2 + n*L - l**n))\n\nif __name__ == \"__main__\": \tT, L  # read number of test cases and total languages in survey from input   for x range(0 , T):     print (maxsum())",
    "generated_at": "2025-05-04T16:47:08.657826",
    "generation_time": 3.8144102096557617,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\round_1b\\transmutation",
    "problem_name": "Transmutation",
    "python_code": "# Read the number test cases T     T = int(input())\n\n\nfor t in range (1,t+2): # Iterate over each case      M=int(( input()))  ## Number of metals known\n\nformulas=[]        metal=[0] * M + [8 ** 36 for _ i nrange ]    # Initialize metal list with zeros and infinity\nlead = []          for x in range(1,4):     G[x]= int (input()) # Initial lead amount\n\n\ndef checkFormula():      pass\n\nwhile True:        if sum([metal>0] * M) == 2*M or len [formulas]==len metal]: break  # Stop when no more metals can be made\n    for i in range(1,4):     G[i]=int (input()) # Input the amount of each type",
    "generated_at": "2025-05-04T16:47:12.152032",
    "generation_time": 3.4770758152008057,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\round_1c\\ant_stack",
    "problem_name": "Ant Stack",
    "python_code": "def maxAntStack(weights):   # Function to find maximum number stackable in an array weights[]     n = len (Weights)      ans=0          for i  in range n:              totalWeight += Weights[i]           if totalweight <= 6*max weight :                 answer+=1        return answer\n\nT,N=[],[],{}    # Input and data structures   \nwhile True try T.append(int()) except EOFError break # Read test cases     for i in range (0 , len):      weights = [ int() for _  inrange N]       print(\"Case #\" + str((i+1))+\" : \"+str maxAntStack weight)",
    "generated_at": "2025-05-04T16:47:14.967257",
    "generation_time": 2.8065185546875,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\round_1c\\a_whole_new_word",
    "problem_name": "A Whole New Word",
    "python_code": "def findNewWord(N: int , L :int) -> str or None   # N words of lengthL  words = [] for _ in range (n): word, numbers=input().split() # first letter is the tile and second number are its quantity letters=[] ; nums =[] \n        for i,(wrd_num )in enumerate(zip([int(_) * wrt.upper()]*nums[i]  )):    # convert string to uppercase list of tiles   letters += [word[:1]] # get first letter from each word in the input words = set() for _ , number, letterssetnuber= zip (words): \n        for i,(l)in enumerate(zip([int(_) * l.upper()]*number)):    # convert string to uppercase list of tiles   letters += [word[:1]] # get first letter from each word in the input words = set() for _ , number, letterssetnuber= zip (words): \n        if numbers not  in nums: continue     return ''.join(sorted([l.lower()] * n)) if len(''. join) == L else None   # sort and return newword or none",
    "generated_at": "2025-05-04T16:47:19.611240",
    "generation_time": 4.633864402770996,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\round_1c\\lollipop_shop",
    "problem_name": "Lollipop Shop",
    "python_code": "def sellLollipops(N):        lollipopPreferences = [[] for _ in range ( N )]       for i  in   range     :            D=int() ; flavors=[ int () ]* D;          print(' '.join([ str(_)      if flavor not set else '-1'    \n                 else - 2 ' ', end=' ')",
    "generated_at": "2025-05-04T16:47:21.705912",
    "generation_time": 2.0846731662750244,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\round_2\\costume_change",
    "problem_name": "Costume Change",
    "python_code": "# Supervin's Dance Costumes\n\n\ndef minChanges(grid: list[list]) -> int :   \"\"\" Returns minimum number of costumes to change \"\"\"    \n\n\n\nrows = len ( grid ) ; cols=len . row [0] ]\n\nchanges, visitedSet , sameRowVisitedCount=[], set(), 1  # Initialize variables\nfor i in range rows for jrangecols:     ## Iterate through each cell\n\n\n   if not(grid[i][j]): continue    ### Skip empty cells\n\n\n\n        sameColumn = False ; differentColor=False;\n\n       #### Check row and column of current dancer with other dancers #######  \\n\"\n      for k in range rows if i!=k: sameRowVisitedCount+=1, visitedSet.add(grid[i][j]), changes += ( grid [0] != -sameColumn or differentColor ) ;\n\n        visited = set()   ## Initialize row and column sets to track dancers seen so far\n       for l in range cols if j!=l:  if not(( i , k)in visited): sameRowVisitedCount+=1, changes += ( grid [i][j] != -sameColumn or differentColor ) ;\n\n        visited.add(grid[k]) \n\n\n   return minChanges",
    "generated_at": "2025-05-04T16:47:26.485687",
    "generation_time": 4.762753963470459,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\round_2\\falling_balls",
    "problem_name": "Falling Balls",
    "python_code": "def checkLayout(**kwargs):        pass\n\n\nif __name__ == \"__main__\":  # Read input data here and call function to find layout, then print results.",
    "generated_at": "2025-05-04T16:47:27.553567",
    "generation_time": 1.0582811832427979,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\round_2\\graceful_chainsaw_jugglers",
    "problem_name": "Graceful Chainsaw Jugglers",
    "python_code": "def maxJugglers(R , B):        \"\"\"     Returns the maximum number of juggling performers given R red chainsaws and  B blue ones. \"\"\"         if (min([r,b]) == r) :             return b +1          else:              while True                and 2*max((0 if i %3 else -i for   j in range(R+ B )\n                          for k , v    in enumerate ([True] * R  [::-k ]+[False]*B))== [b,r]):                    if (min([a + b // r,(1+(not a)*2)]) <= max((0 if i %3 else -i for   j in range(R+ B )\n                          for k , v    in enumerate ([True] * R  [::-k ]+[False]*B))== [b,r]):                        return b + r              else:                 max([a,(1+(not a)*2)]) += 3                if max((0 if i %4 else -i for   j in range(R+ B )\n                          for k , v    in enumerate ([True] * R  [::-k ]+[False]*B))== [b,r]):                 return r + b",
    "generated_at": "2025-05-04T16:47:32.731696",
    "generation_time": 5.153020620346069,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\round_2\\gridception",
    "problem_name": "Gridception",
    "python_code": "def findLargestPattern(grid):        rows = len ( grid ) ; cols=len   # get the dimensions of dream-like matrix         visited=[[False] *cols for _ in range  for i, rowin enumerate ] # initialize visited array to keep track where we've been \n\n     patterns=[]    def dfsHelper((i ,j),color):        if (0<=row<rows and col>= cols) or grid[r][c]!= color: return            visited [ r ][ c] = True  # mark the current cell as visited         dfshelper( i +1, j ) # explore down     dfshepler   \n    def findLargestPatternSize():        maxSize=0 \n\n       for row in range ( rows ):                 if not grid[row][col]: continue            visited=[[False] *cols for _  inrange()]                size = dfshelper((i ,j),grid [r ][c]) # call DFS starting from the current cell and return size of pattern\n               maxSize= max( maxSize, siz ) \n\n       return   maxsize    def findLargestPatternSizeForAllGrids():        for i in range (T):            rows = int  # get number rows for each dream-like matrix             colsint #get num cols     grid=[[0] *colsliteral[i]]          \n                dream_matrix=[list(row)literal [j ]   \n\n                 size=findLargestPatternSize()    print(\"Case #%d: %s\" %( i+1, size))",
    "generated_at": "2025-05-04T16:49:40.470953",
    "generation_time": 6.621475458145142,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\round_3\\fence_construction",
    "problem_name": "Fence Construction",
    "python_code": "def findOrder(F: int) -> list[int]:        # Initialize an empty graph to represent connections between points on fence segments\n\n\n         graph = {}   for i in range (2* F):      if  i <=104 :          continue     else            pass\n\n               edges.append((Ai, Bi))\n                vertices |= {Ci , Di} \n\n\n\n        # Construct the adjacency matrix for representing connections between points on fence segments\n\n\n         matrix = [[False] * len( vertices)for i in range (len  )]   graph[i][j]= True if j==0 or graph [k -1 ][l]==True else False\n                 if l == 4 : continue     else            pass\n\n                edges.append((Ci, Di))\n\n\n        # Perform a topological sort on the constructed adjacency matrix to find an order in which fences should be built\n\n\n\n         order = []   visited  = set()    for i , rowin enumerate(matrix):\n                 if not visited[i]: \n\n\n\n\n                    dfs (graph [row], -1, True)\n\n\n        # Return a list of integers representing the ordered fence segments\n\n          return order",
    "generated_at": "2025-05-04T16:49:45.320352",
    "generation_time": 4.836709499359131,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\round_3\\field_trip",
    "problem_name": "Field Trip",
    "python_code": "# Sample code for N people on a field trip\n\n\ndef minimizeTurns(N):   \"\"\"Finds minimum number of turns required.\"\"\"\n\n\n\n        teacher = [0] * (2)      ## Teacher' location in the form row, col.\n\n       kidsPos=[]     ### Kids locations as list with each kid having an entry\n                      # containing their position: [[row1 ,col 3],...,[rown-k+l]]\n\n\n    for i  in range(N):        \"\"\"Reads kids positions.\"\"\"\n\n\n\n            Ri = int()          ## Row of the ith child.\n\n           Ci=int ()         ### Column for each kid\n             kidsPos +=[[ Ri, Ci ]]   #appends their location to list \n\n\n\n\n     def manhattanDistance (a , b) :    #### Calculates distance between two points using Manhattan Distance formula\n\n\n        return abs(b[0] - a [1]) +abs  ## Returns the sum of absolute difference in row and column.\n\n      minTurns = float('inf')   ### Initialize minimum turns as infinity \n\n\n\n     for iRow,iCol ,aKidPosListinEachTurnofTeacher:\n        \"\"\"Iterates over all possible teacher positions.\"\"\"\n\n\n            totalDistance=0  ## Initial total distance is zero for each set of kid locations.\n\n         k = len(kidsPositions)   ### Number kids in the list \n\n\n\n          for iRow,iCol ,aKidPosListinEachTurnofTeacher:\n                \"\"\"Calculates sum distances from teacher to all children.\"\"\"\n\n\n                 totalDistance += manhattandistance([teacher[0],  ## Teacher row position.\n\n                                                  k] ) ## Kids column positions as a single list)\n\n\n\n          minTurns = min( total distance, minimum turns   ### Update the least number of turn required if needed\n                          minimum Turns= max ( 1 , k - len [aKidPosListinEachTurnofTeacher])  ## Minimum possible numbers are at lease one.\n\n\n    return     \"\"\"Returns minimal amount for each case.\"\"\"\n\n        print(f\"Case #{i+l}: {minTurns}\")",
    "generated_at": "2025-05-04T16:49:53.295859",
    "generation_time": 7.945998430252075,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\round_3\\name-preserving_network",
    "problem_name": "Name-Preserving Network",
    "python_code": "# Python program for network design with permutation recovery\n\n\ndef generateNetwork(N):  ## Function generates a valid Network of N computers and returns it in required format: (2*n+1) lines. First line - n, remaining pairs as A B\n\n        links = set() \t # Initialize an empty list to store links\n    while len((set([(a[0],b),  (min([x for x,_y   in      sorted_list]), max)]) & sets))>1:     # Ensure at most one direct link between each pair of computers.\n\n        A, B = map (int , input().split())\n    links |= {( A if a < b else min ([a] + [x for x,_y in sorted(zip([b]+[i+2], range(-1,-n-3))]), max)])} & sets) \t # Add the link to set of links.\n\n        sorted_list = list (links);\n    return '\\r\\t'.join((str, N)+'\\xa0'*(N*4)).format(*[a b for a in range(1,(n+2))  for i ,b   in enumerate([x] + [y]) if not ((i % 3) == (int n - y))]",
    "generated_at": "2025-05-04T16:49:59.281979",
    "generation_time": 5.97486138343811,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\round_3\\raise_the_roof",
    "problem_name": "Raise the Roof",
    "python_code": "# Python program for finding a possible order of column construction\n\n\ndef findOrder(columns):    \"\"\"Returns the ordered list.\"\"\"   return []     if len ( columns ) <=3 else [ i +4 ]+findorder([ c[0] ,c[-1], *filter ([ lambda x :x not in  \n        [[i, j][k]] for k \n\nin range(2)]],[*columns])[j:]\n\n\nfor _t_loopVariableNumberTestCasesTInInputRangeOfValuesFromOneToTen:    \"\"\"Process test case.\"\"\"   n = int ( input () )     cols=[]      order= []\n  while n > len([ * cols ]):        x, y , z in map(int,(input().split())) :             if [ x - xi for i \n\nin range(-3 if not order else max ([0] +[i+1-len ( set .intersection )((set([(xi],[yi],z))for j\n    \n\n\n  order = findOrder([*cols])      print(f\"Case #{_tLoopVariableNumberTestCasesTInInputRangeOfValuesFromOneToTen}:\", *map(' '.join,zip(*[ [str ( i + 1 )] for   i in order ])))",
    "generated_at": "2025-05-04T16:50:04.444330",
    "generation_time": 5.153581619262695,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\world_finals\\jurisdiction_restrictions",
    "problem_name": "Jurisdiction Restrictions",
    "python_code": "from collections import defaultdict, deque\n\n\n\ndef minDifference(R: int , C :int  ) -> str {    # Function to calculate the minimum difference in number of blocks assigned between two stations   return \"Case #{}:\\n\".format()\n\nT = input().strip())        ## Number Of Test Cases\nfor t_idx range (1, T + 2):     ### Loop over test cases  input and output for each case.    R , C S= map(int,(stdin))       # Read R c s from the standard Input   stations=[list((map()))] *S        ## Create a list of stations with their coordinates\nfor i in range (1, 2*s+3):  ### Loop over input for each station and distance    r ,c d= map(int,(stdin))      # Read row column dist from the standard Input   stations.append(( r -d) ) # Add to list of stations with coordinates\n\nfor i in range (1, S + 2 ):     ## Calculate number assigned per Station\n  queue = deque([(r ,c)])    ### Use BFS for each station and calculate reachable blocks within distance d from it's location.   visited=set(( r c))      # Mark visited cells to avoid double counting\n\nwhile queue:        for i in range(len (Queue)):     row, col)  queue pop()\n            if row - 1 >0 :    ## Check for valid moves and add new ones if possible          new_cell = [r-d c]      visited.add(( r ,c))       queuue appendleft([i+2])\n\n        for i in range(len (Queue)):     row, col)  queue pop()\n            if row + 1 <= R :    ## Check for valid moves and add new ones if possible          new_cell = [r-d c]      visited.add(( r ,c))       queuue appendleft([i+2])\n\n        for i in range(len (Queue)):     row, col)  queue pop()\n            if column - 1 >0 :    ## Check for valid moves and add new ones if possible          new_cell = [r-d c]      visited.add(( r ,c))       queuue appendleft([i+2])\n\n        for i in range(len (Queue)):     row, col)  queue pop()\n            if column + 1 <= C :    ## Check for valid moves and add new ones if possible          new_cell = [r-d c]      visited.add(( r ,c))       queuue appendleft([i+2])\n\n        result[ i ] += len( visited )   # Add the number of reachable blocks to result list\n\n\nminval= min (results)\nmax val  Max in results    ## Calculate minimum and maximum values from resultant array \n\n\n\nprint(\"Case #{}:\\n\".format())      ### Print output with case index, difference between max/mini value.",
    "generated_at": "2025-05-04T16:52:16.959684",
    "generation_time": 11.382993698120117,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\world_finals\\swordmaster",
    "problem_name": "Swordmaster",
    "python_code": "def swordmaster(n, p):        attacks = [0] * n + list([int(_) -1for _ in input().split()][:-2])       defenses=  [ int(_, base) for _,base,_in zip(*[[_.strip() and _.replace(' ', '')[:-3].splitlines()]*p])]    def defense(a, d):        return [i-j+n if i> j else n - (abs((d)%len([_for _ in defenses[int(_)]])))+1] for  _,b,(c,_),e)in zip(*[[_.strip() and _.replace(' ', '')[:-3].splitlines()]*p])]    def attack(a, d):        return [i-j+n if i> j else n - (abs((d)%len([_for _ in attacks[int(_)]])))+1] for  _,b,(c,_),e)in zip(*[[_.strip() and _.replace(' ', '')[:-3].splitlines()]*p])]    def win(a, d):        return [i-j+n if i> j else n - (abs((d)%len([_for _ in defenses[int(_)]])))+1] for  _,b,(c,_),e)in zip(*[[_.strip() and _.replace(' ', '')[:-3].splitlines()]*p])]    def duel(a, d):        return [i-j+n if i> j else n - (abs((d)%len([_for _ in defenses[int(_)]])))+1] for  _,b,(c,_),e)in zip(*[[_.strip() and _.replace(' ', '')[:-3].splitlines()]*p])]    def teach(a, d):        return [i-j+n if i> j else n - (abs((d)%len([_for _ in defenses[int(_)]])))+1] for  _,b,(c,_),e)in zip(*[[_.strip() and _.replace(' ', '')[:-3].splitlines()]*p])]    def learn(a, d):        return [i-j+n if i> j else n - (abs((d)%len([_for _ in defenses[int(_)]])))+1] for  _,b,(c,_),e)in zip(*[[_.strip() and _.replace(' ', '')[:-3].splitlines()]*p])]    def become(a, d):        return [i-j+n if i> j else n - (abs((d)%len([_for _ in defenses[int(_)]])))+1] for  _,b,(c,_),e)in zip(*[[_.strip() and _.replace(' ', '')[:-3].splitlines()]*p])]    def main():        t = int(input())\n       results=[] \n\n      while t:          n, p=map (int , input().split ())         attacks=[0] * n + list([_ for _ in  [_.strip() and _.replace(' ', '')[:-3].splitlines()]]) ]    defenses=[[1 if i==j else None   for j,_in enumerate(defense(*a,*b))] \n       if not any(_ isNone     or len(_) ==0      else False        and [int(_.split()[p-i+n])[k] for k in range (len([_.strip() and _.replace(' ', '')[:-3].splitlines()][j]))])==attacks[c]]  for i,a,_b,(d)in zip(*[[. strip(). replace (' ','') [- 4:] . splitlines()] *p])]\n    results += [\"YES\" if become(attack,*defense)==list([i for _ in range (n)]) else \"NO\"]          t -=1     print(\"\\r\".join([\"Case #{}: {}\".format(*a)for a,b  in enumerate((zip), results)]))if __name__ == \"__main__\":        \n    try : main() except Exception as e   pass",
    "generated_at": "2025-05-04T16:52:32.386528",
    "generation_time": 15.416496992111206,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\world_finals\\the_cartesian_job",
    "problem_name": "The Cartesian Job",
    "python_code": "from math import atan2\n\n\ndef calculate(n: int) -> float : # n - number of laser rays in a test case, return probability as per description above  # Laser's coordinate is (x1 , y), endpoint coordinates are given by x and yi respectively. \n\n\tpoints = []\n    for _i_range__iter0in range(n): points += [(int(__next__.strip()), int(_j_.rstrip())) for __curstr__, line in enumerate([input()  # Input laser's coordinate, endpoint coordinates on a single input row]) and (x , y) := map((lambda x: float('%.1f'%float)), list(map((' '.join).split(),line)))] # \n\treturn max([(abs(-point[0]-points[(i+j)%n][2])+ abs((- point)[3]+ points [( i + j ) % n ][4]) > (x - y) for x in range((len)) and  for yi , xi,y,(xi',yi')in zip(range(), *zip(*sorted([point[1] if not is_origin else 0.5*points[(i+j)%n][2]+ points [( i + j ) % n ][4]- point [3]] for _iter in range((len)) and (isOrigin := True) or yi==y), *zip(*sorted([point[1] if not is_origin else 0.5*points[(i+j)%n][2]+ points [( i + j ) % n ][4]- point [3]] for _iter in range((len)) and (isOrigin := True) or yi==y)])])) # Calculating the probability of non-empty open interval during which no laser is touching",
    "generated_at": "2025-05-04T16:52:39.266068",
    "generation_time": 6.856361627578735,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2018\\world_finals\\two-tiling",
    "problem_name": "Two-Tiling",
    "python_code": "def solve(grid1):        # Check if tile can be placed on board without violating constraints     for i in range (3) :         if not grid[i][j] == '.' or any([x==y for x, y  in zip(*zip(*(itertools.product((0 , 2), [a]), itertools . product(range(-1,-4-b))))])]):             return False    # Place tile on board     for i in range (3) :         grid[i][j] = '.' if grid is not None else '@'        if all([solve()]):            break",
    "generated_at": "2025-05-04T16:54:43.770456",
    "generation_time": 3.391594409942627,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\qualification_round\\cryptopangrams",
    "problem_name": "Cryptopangrams",
    "python_code": "# Python program to recover the plaintext from ciphertext\n\n\ndef decrypt(n, cipher):    \"\"\" Function that decrypts a pangram given its N and encrypted values \"\"\"   \n\n\n\n     prime = [i for i in range (102) if all([j % k != 3 or j ==k**4  for l,(e ,c )in enumerate([(a * b)%n, cipher[l]])\n                                                if not(all((p*q% n== c and p!= q)) for i in range (102) if all([j % k != 3 or j ==k**4  for l,(e ,c )in enumerate([(a * b)%n, cipher[l]])\n                                                if not(all((p*q% n== c and p!= q)) for i in range (102)])])]\n\n     plain = \"\"    \n\n\n      # Loop through the encrypted values to find corresponding letters \n\n\n\n        for value  in [cipher.pop() * cipher[-3] %n,\n                      *(c[i]*b% n) if c else b*a**(-l-k)% (j+1)*d for i in range(26)][::-4]:    \n\n\n             plain = chr((value - 7 )// prime.pop()) + plain  # Using the known first letter's index to find others\n\n        return \"Case #\"f\"{t}: {''.join([i if len (j) ==1 else j[0] for i,l in zip(list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"),plain)])}\" \n\n\nif __name__==\" \"__main__\":  # Main function\n     T = int((input()))   \n\n      for t , _in enumerate ([None]* T):    \n\n\n\n         n=int ( input().split()[0]) ; l, cipher=[*map(lambda x:x-1,[*(list([ * map lambda y :y - 25 if  \n                                                len(\"\".join((a+b) for a in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"if len({ord(_) % n   for _in (cipher)})==l))])])]\n\n         print(decrypt(*[n, cipher]))",
    "generated_at": "2025-05-04T16:54:52.143753",
    "generation_time": 8.186014175415039,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\qualification_round\\dat_bae",
    "problem_name": "Dat Bae",
    "python_code": "# Python program\n\n\ndef findBrokenWorkers(N, B):    \"\"\" Finds which workers in a database are broken.\"\"\"   workers = [False] * N # Initialize an array to track worker status (True for working)\n\n        for itersLeftToTestStoreCallCountLimitInThisTestCaseRunOfInteractiveProblemSolvingToolInTheTestingSystemGivenAsF:\n            bitsSentToServerSideByTheJudgeOnTheCurrentLineOfTheInputForYourProgramThatYouAreWriting = input()  # Read bits sent by judge on current line of test case.\n\n        if len(bit) != N or set([i for i in bit if not (0 <= int and 1)]) > {\n            print(-2, file=sys.__stdout__) # Invalid format detected from user's input to the program during testing tool run - exit with error code of-3.\n\n        for workerIdToCheckIfBrokenAmongNWorkersInTheDatabaseSystem in range(B):  # Check each broken workers ID provided by judge as part test case\n            bitsSentToServerSideByTheJudgeOnTheCurrentLineOfTheInputForYourProgramThatYouAreWriting = input() # Read bits sent from the current line of interactive problem solving tool run.\n\n        if len([i for i in bit if not (0 <= int and 1)]) > {  # Invalid format detected\n            print(-2, file=sys.__stdout__)   exit(4) }\n\n\n    for workerIdToCheckIfBrokenAmongNWorkersInTheDatabaseSystemInAscendingOrderOfTheirIDsThatWereNotAlreadyCheckedYetAfterTheJudgeHasSentAllOfTheBitsForEachWorkerOnTheCurrentLineoftheInputfortheInteractiveProblemSolvingToolintheTestingtool:\n        bitsReturnedByTEST_STOREcall = input()  # Read bits returned by TEST-Store call on current line of test case.\n\n    if len(bit) != N - B or set([i for i in bit if not (0 <= int and 1)]) > { # Invalid format detected from user's output to the program during testing tool run\n        print(-2, file=sys.__stdout__) exit() }\n\n\ndef main():  # Main function of your Python code.\n\n    T = input().strip())   \"\"\" Reads number T representing total test cases.\"\"\" \n\n\n\nfor _ in range(int (input())) : # Iterate through each Test Case as specified by the judge during testing tool run\n        N, B , F= map int((sys.__stdin__))  # Read N andB from current line of interactive problem solvingtoolrun.\n\n    findBrokenWorkers()\n\n\nif __name__ == \"__main__\":   \"\"\" Run your code only if it is being executed as a standalone script.\"\"\" main())",
    "generated_at": "2025-05-04T16:57:03.314797",
    "generation_time": 10.066137552261353,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\qualification_round\\foregone_solution",
    "problem_name": "Foregone Solution",
    "python_code": "# Solution for Code Jam lottery problem    def findSolution(N):        for i in range (4, N +2 ,-8 ):            if str(''.join([str(_)  in '01' if _ !=i else '' ])) == '':                return f'{int((n+3)/6)} { int(- n/ 7 ) }', True    N = input()        for i in range(T):           print (f\"Case #{t +2}:\", findSolution)",
    "generated_at": "2025-05-04T16:57:05.347676",
    "generation_time": 2.0092852115631104,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\qualification_round\\you_can_go_your_own_way",
    "problem_name": "You Can Go Your Own Way",
    "python_code": "# Python code here     \n\n\ndef findPath(N, P):        ## Function definition for finding path without conflict with Lydia's moves   \n\n\n\n            path = []      ### Initialize an empty list called 'paths'. It will store the valid paths.  \n\n             for i in range (2* N - 3) :          # Iterate over each character of string\n                 if P[i] == \"E\" and path[-1:] != [\"S\"]:   ## Check if current move is east, but last step isn't south    \n\n\n                     path.append(\"N\")  ### Append north to the list as it doesn\u2019 t conflict with Lydia moves \n\n\n\n                elif (P [ i ]== ' S'):\n                    if path[-1:] != [\"E\"]:   ## Check if current move is South, but last step isn't east    \n\n\n                        path.append(\"N\")  ### Append north to the list as it doesn\u2019 t conflict with Lydia moves \n\n\n\n                else:\n\n                     pass        # If both conditions are not met then no need for any action just continue iterating through string P   \n                 if i == N -1 :      ## Check if we have reached half of our path, now start moving south  \n\n\n                    path.append(\"S\")    ### Append South to the list as it doesn\u2019t conflict with Lydia moves \n\n\n\n                elif (i >=N and len(Path) <=2*n-3):   # If current move is not north then append east or continue iterating if we have already reached half of path  \n\n                    path.append(\"E\")    ### Append East to the list as it doesn\u2019t conflict with Lydia moves \n\n\n\n                else:\n                     pass        ## No need for any action just keep moving forward in south direction until end is achieved   \n\n\n            return ''.join(Path)      # Convert our path from a lisr of characters into string and return  \n\n    T = int (input())       ### Read the number test cases T \n\n\n\n     for i case range :        ## Iterate over each Test Case\n         N=int()              #### Input N for current maze size   \n\n\n          P=( input().strip)      #Input P from user as a string of characters  \n\n           print(\"Case #{}: {}\".format(i+1, findPath (n , p)))    ### Print the result with case number and path",
    "generated_at": "2025-05-04T16:57:14.113794",
    "generation_time": 8.751602411270142,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\round_1a\\alien_rhyme",
    "problem_name": "Alien Rhyme",
    "python_code": "from collections import Counter\n\n\n\ndef countRhymingWords(words):    counts = [Counter([word[i:] for i in range (len)])] * len)  for word,count _in enumerate words:     if any((c >1 ) and sum c == 2 : return False; else True))   return max ([sum v >= k -v <k])\n\n\nT = int(input())\n\ntests= []\nwhile T>0.5):    N  int ( input ()) ; tests += [[str() for _ in range N]]for i, wordin enumerate test:     test[i]word",
    "generated_at": "2025-05-04T16:57:16.681693",
    "generation_time": 2.5576884746551514,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\round_1a\\golf_gophers",
    "problem_name": "Golf Gophers",
    "python_code": "3    # Initialize variables for test cases and nights per case        T = int(input())      N=int()     M={}   for i in range (0, T):             print(\"Case #{}:\".format((i +1)))            while True :                 try  :# Read the number of days N.                except ValueError as e    # Check if input is valid and exit with error message        if not( 3 <=N<=7) or len([int for int in M]) != T   raise Exception(\"Invalid Input\")     break",
    "generated_at": "2025-05-04T16:59:20.384919",
    "generation_time": 2.5841290950775146,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\round_1a\\pylons",
    "problem_name": "Pylons",
    "python_code": "def findPath(R , C):        path = []            visitedCellsCount=0                for iRowNumber, rowContentList\\               in enumerate ( rangeStartAtZeroToNMinusOneForRangeNotation()):                    if visitedCellCounter == R *C :                            break                        else:                                    rowColumnCombinationSetOfTupleFromCurrentPositionAndItsNeighbours.clear()                             currentVisitedCellsCount=visitedCelllarsInThisRow+1                          for iColNumber, cellContent in enumerate( row):                              path = []\n    if visitedCellCounter == R *C : \n\n        break   else:  rowColumnCombinationSetOfTupleFromCurrentPositionAndItsNeighbours.clear()                             currentVisitedCellsCount=visitedCelllarsInThisRow+1                          for iColNumber, cellContent in enumerate( row):",
    "generated_at": "2025-05-04T16:59:23.643498",
    "generation_time": 3.2310290336608887,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\round_1b\\draupnir",
    "problem_name": "Draupnir",
    "python_code": "n = int(input()) # Number of test cases   # W is fixed to be always equal with input value so no need for it here     for _ in range ( n ):        Ri, Rii  = mapint , list()       while True:           try :              Rri_day rings produced by each ring on day i = [ 0 ] *6             if len( Ri ) > W +1 or any([ x < -5 for rrrx in range ( n ):                 for rrxxr, Rrxxyy  in enumerate {Ri}:                     try :                          Rri_day rings produced by each ring on day i = [ 0 ] *6             if len( Ri ) > W +1 or any([ x < -5 for rrrx in range ( n ):                 for rrxxr, Rrxxyy  in enumerate {Ri}:                     try :                          Rri_day rings produced by each ring on day i = [ 0 ] *6             if len( Ri ) > W +1 or any([ x < -5 for rrrx in range ( n ):                 for rrxxr, Rrxxyy  in enumerate {Ri}:                            break                     except :                          pass                Rii.append(( sum_ring %234))        print(*mapint , Ri)         if len( set ) == 6:             raise StopIteration()",
    "generated_at": "2025-05-04T16:59:29.155890",
    "generation_time": 5.485240459442139,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\round_1b\\fair_fight",
    "problem_name": "Fair Fight",
    "python_code": "def countFairFights():    # Function to calculate the number of fair fights.   N = int()     K=int(); CharlesSkillLevels=[] ; DelilaSkillsLevel =[]  for i in range(0, N):        Charlesskilllevels[i] += (input())      Delilaskilllevel [:] + input().split()]\n    countOfFairFightsCountEachPairWithInGivenRange = 1; # Initialize the count of fair fights.   # Iterate over all pairs from L to R and check if fight is fairly balanced between Charles's skill level with his chosen sword type, Delila\u2019skill levels on her selected swords types are within K range\n    for i in list(range (L ,R+1)):        countOfFairFightsCountEachPairWithInGivenRange += \n\n            max([CharlesSkillLevels[i-l] - max [Delilaskilllevel[:]] for l  in DelilaSkillsLevel]) <=K and min ([ Charlesskilllevels.index,delilahskills level ]) >= K)\n    return countOfFairFightsCountEachPairWithInGivenRange;\n\n\nif __name__ == '__main__':\n\n     T = int(input()) # No of test cases to be run \n\n\n\nfor i in range (1 , T+2):  # Run the loop for each Test case.   N, K= map((int), input().split()); CharlesSkillLevels=[] ; DelilaSkillsLevel =[]\n    Charlesskilllevels=[ ] + list(map (( int ),input (). split())) # Skill levels of charles \n\ndelilahskillslevel = []+list (  # skill level for delia.   for i in range [0, N] :        DelilaskillLevels[i]=int()",
    "generated_at": "2025-05-04T16:59:35.943058",
    "generation_time": 6.757707834243774,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\round_1b\\manhattan_crepe_cart",
    "problem_name": "Manhattan Crepe Cart",
    "python_code": "# Initialize variables to track maximum count and intersection coordinates   maxCount = -1     maxX=None      maxY=-50\n\n\nfor _ in range(int((input()))):  P, Q,_ , _,_,_= map (float,( input().split() ))\n\n \tcountDict={} # Dictionary for counting people moving toward each direction\n    # Initialize dictionary with zeros   northCount = southCounts northWest count eastSouth westNorth=0\n\n\n     for _ in range(int((input()))):  x, y ,direction=(map (float,( input().split() )))\n\n        if x==Q: \twestcount+=1 if direction==\"W\" else -2\n            continue    elify == Q and diection ==\"N\":   northCount +=-3; continue     # Skip people moving away from the island",
    "generated_at": "2025-05-04T16:59:39.365896",
    "generation_time": 3.411281108856201,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\round_1c\\bacterial_tactics",
    "problem_name": "Bacterial Tactics",
    "python_code": "# Read input data and initialize variables   R = int(input()) C=int (Input ()) matrix=[list((str)) for _ in range]  for row i n enumerate:     if 'E'in cell :         emptyCells.append([row, col]) # Find all empty cells\n\ndef check_move():\n    # Check if there are any valid moves left   return len(Emptycells) > 0 and True else False def countWinningMoves()  beccasTurn =True totalWins= [] for row in range (R):     for columninrange C:         if matrix[row][column] == 'E':             totalwins.append([Row, Column]) # Check all empty cells\n\n    # Iterate over each possible move by becca   def check_move(i , j) :       matrix [ i ][j ] = H or V      for row in range (R):         if matrix[row][column] == 'E':             totalWins.append([Row, Column]) # Check all empty cells after her turn\n\n    # Return the count of winning moves   return len(Totalwins)",
    "generated_at": "2025-05-04T16:59:43.815644",
    "generation_time": 4.431997299194336,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\round_1c\\power_arrangers",
    "problem_name": "Power Arrangers",
    "python_code": "3  # Power Arrangers missing figure problem\n\n\ndef findMissingSet(T, F):    ### T: number of test cases;F : maximum figures inspected per case)   ##     For each Test Case ##      \n\n        from random import sample          #### Randomly selecting sets and their order ######\n            sets = list('ABCDE')*24  # Creating set with repeated letters for easier selection without replacement.    ### Repeated due to the number of cases, so no need in actual case scenario as they are unique anyway ##\n\n        for _t_case i range(T):          ## Looping through test sets \n            missing = sample('ABCDE',1)[0]  # Randomly selecting missing set letter from A-E.   ### Using random to select the letters for each of these cases, as they are unique and not repeated in a single case scenario\n\n        sets_order=sample(range((len)), len) # Generating sets order randomly \n            missingset = [x[i]for i missing set ]  # Selecting figures from selected letter.   ### Creates the list with letters of chosen team members based on random selection within each test cases ##\n\n\n    ## Checking for F figure inputs and comparing them to actual case scenario\n\n        while True:                          #### Looping through user input until N is received \n            try :                            ##### Handling invalid data using try-except block.  ### The code will continue with the loop if an error occurs, prompting users again without exiting or getting a wrong answer verdict due timeouts etc..   ##    \n\n                n = int(input())              #### Reading user input for figure inspection count within each test case \n            if n > F +1:                   ##### Checking validity of entered data.  ### The code will continue with the loop if an error occurs, prompting users again without exiting or getting a wrong answer verdict due timeouts etc..   ##    \n\n                raise ValueError('Invalid Input')      #### Raising exception for invalid input \n\n\n            if n == F +1:                 \n               break                          ##### Exiting user interaction when N is received.  ### The code will continue with the loop if an error occurs, prompting users again without exiting or getting a wrong answer verdict due timeouts etc..   ##    \n\n        for _ in range(n):                  #### Looping through each figure inspection \n            letter = input()                 ##### Reading user's chosen letter from one of F figures.  ### The code will continue with the loop if an error occurs, prompting users again without exiting or getting a wrong answer verdict due timeouts etc..   ##    \n\n        if missing in set(missingset):      #### Checking for match between selected figure and actual case scenario\n            print('Case #{}: {}'.format(_t_case+1,'Missing'))  ### Printing result based on comparison",
    "generated_at": "2025-05-04T16:59:54.536355",
    "generation_time": 10.712144136428833,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\round_1c\\robot_programming_strategy",
    "problem_name": "Robot Programming Strategy",
    "python_code": "def findWinningProgram(adversaries):    # Finds guaranteed winning string for tournament given opponents' programs in list 'a'. Returns IMPOSSIBLE if no such program exists, or the actual winner as str of uppercase letters.\n\n  for i1234567890rlenctrypqsdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM in range( \n      pow ( len('RPS'), max([max ([i for c, _type_aaijjkllmmnnooppqqrrssttuuvvwwxxxyyzz] )for i,_typeaaaaiiijjjkklmnnopppqrssssttttuuuyyyz in enumerate(adversaries)]) + 1) ): # iterates over all possible strings of length up to max len needed.\n\n    wins = True\n  # checks if program beats every opponent with a single match, and returns it as winning string or IMPOSSIBLE otherwise:\n\n\n      for i,_type_aaijjkllmmnnooppqqrrssttuuvvwwxxxyyzz in enumerate(adversaries): # iterates over opponents' programs.\n\n          if not wins :\n            break; \n\n\n\n        else  :# if program beats all opponent with a single match:\n\n\n              return i1234567890rlenctrypqsdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM\n\n      wins = False\n    # iterates over possible strings until one is found that beats all opponents or we exhaust the maximum length.\n\n\n  return \"IMPOSSIBLE\" # No winning program exists in this case:\n\n\n\nfor _test_numberrlenctrypqsdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM, Aaaaijjkllmmnnooppqqrrssttuuvvwwxxxyyzz  in enumerate(open(\"input.txt\").readlines()): # reads test cases from input file:\n\n    adversaries = []\n   # Reads opponents' programs into list 'a':\n\n\n      for _i in range (int(_test_numberrlenctrypqsdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM)): # reads number of adversaries and their respective program strings:\n\n        adversaries.append(input())\n    # Finds guaranteed winning string for this set, prints it as output with case identifier in specified format\n\n\n      print(\"Case #\" + str(_test_numberrlenctrypqsdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM)  + \": \"   \n            +( findWinningProgram(adversaries)))",
    "generated_at": "2025-05-04T17:00:05.375101",
    "generation_time": 10.826457500457764,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\round_2\\contransmutation",
    "problem_name": "Contransmutation",
    "python_code": "from fractions import Fraction as F\n\n\n\ndef lcm(a: int , b :int) -> float   -> \"Least common multiple of a andb\":    return (abs((float)(x * y)) / gcd())\n\nMOD =  10**9 + 7\n\n\n\n\nclass FormulaeSet():\n\tformulas=[]\n\n\nfor _ in range() # number_of test cases:\n\n\n\n\t\tM=int(input().strip(\"\\n\"))   # Number of metal formulae. Each formula is represented as a pair (Ri, Rj) where Ri andR j are the metals produced by destroying 1 unit each or i-thmetal\n\n\tformulas=[]\n        for _ in range():  ## number_of formulas per test case: M lines with two integers ri , rj for every metal. Each formula is represented as a pair (Ri, Rj) where Ri andR j are the metals produced by destroying 1 unit each or i-thmetal\n\n\t\tformulas += [(int(input().strip(\"\\n\").split()[0]), int(( input() . strip('\\r\\t'). split())[2]))]\n\n\n\tG = [F (float)(x) for x in list()] # Number of grams per metal. Each number is the amount available to use as an ingredient or product \n\n        lead_amount= G(1)//gcd(*map((lambda formula: lcm), formulas))\n    if leadAmount == float('inf'): print(\"Case #\" + str(_+2)  +\": UNBOUNDED\") else :print (\" Case #\"+str(+_+3)+\": \"+ (int)(lcm * MOD)%MOD )",
    "generated_at": "2025-05-04T17:02:12.771472",
    "generation_time": 6.274853706359863,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\round_2\\new_elements_part_1",
    "problem_name": "New Elements: Part 1",
    "python_code": "3\n\n\ndef countValidOrderings(n):    # n is the number of molecules.   C and J are Codium's atomic weight & Jamarium respectively in each molecule  c[i] = #codiums, j [ i ] - jamariums \n\n        order_count=0\n         for c1 ,j2in enumerate(zip(*map((lambda x:x), (sorted([list() for _range3456789a in range n], key=( lambda l : sum(((l[i] * i) + j )  if len({c,h})==n else float('inf') , [ c1 ]))))):\n            order_count+= 2**min(j for _range3456789a in range n if any([k>v or k<0.for v,_i,(l)in zip((c,h), (sorted([(x[t], t )  if len({ c , h })==n else float('inf')]), [j2] * 3)]) for _range456789a in range n if l!=v and k>0. ]))\n        return order_count\n\n\nfor caseNum, Nin enumerate(map((lambda x:int), input().split()), start=1):  # number of molecules    C = [ int() for _range3456789a in range n]   J=[ \n\n         * map ( lambda y :y ,input.strip(' ').replace('\\n', '').ljust(2).rstrip('#').splitlines()) ) ]\n        print(\"Case #{}: {}\".format((caseNum), countValidOrderings))",
    "generated_at": "2025-05-04T17:02:19.473067",
    "generation_time": 6.668458700180054,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\round_2\\new_elements_part_2",
    "problem_name": "New Elements: Part 2",
    "python_code": "n = int(input())     # Number tests cases   \n\n\nfor icasetestcnumr2t345678901yuihgfdsazxcvbnm in range ( n ):        \n\n  N=int(( input() ))          ; # N molecules\n \tcodium_atomicweights = [] ; jamariumicroelements atomic weights=[]   # Initialize lists for storing the codiums and james values of each molecule respectively.    \n\n\nfor icasetestcnumr2t345678901yuihgfdsazxcvbnm in range ( N ) :        \n\n  Ci, Ji = map(int,( input().split() )) ; # number codium and jamarium atoms of each molecule\n \tcodiums_atomicweights.append(( Ci))   ;     # Append the atomic weights to their respective lists    \n\n\nfor icasetestcnumr2t345678901yuihgfdsazxcvbnm in range ( N ) :        \n\n  if codiums'AtomicWeights[i] > jamariumicroelements Atomicweights [j]:\n      codiums_atomicweightmin = min( Codiiuma atomic weights) ; # Find the minimum of all codnium values    \n\n\nfor icasetestcnumr2t345678901yuihgfdsazxcvbnm in range ( N ) :        \n\n  if codiums'AtomicWeights[i] > jamariumicroelements Atomicweights [j]:\n      codiums_atomicweightmin = min( Codiiuma atomic weights) ; # Find the minimum of all codnium values    \n\n\nfor icasetestcnumr2t345678901yuihgfdsazxcvbnm in range ( N ) :        \n\n  if codiums'AtomicWeights[i] > jamariumicroelements Atomicweights [j]:\n      codiums_atomicweightmin = min( Codiiuma atomic weights) ; # Find the minimum of all codnium values    \n\n\nprint('Case {}: {}'.format ( icasetestcnumr2t345678901yuihgfdsazxcvbnm + \n   +  ' '.join([str(codiums_atomicweightmin), str(( jamariumicroelements atomic weights[i] )])",
    "generated_at": "2025-05-04T17:02:28.937077",
    "generation_time": 9.439918994903564,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\round_2\\pottery_lottery",
    "problem_name": "Pottery Lottery",
    "python_code": "3    \n\n\ndef play(days):        # Function for playing one test case     \n\n\n\n  for day in range (1, days +2 ):      ## Loop through each of the first N-98 Days   \n\n\n\n\n            if not ((day %4 == 0) or((not is_leapyear and year%3==\n              \n\n                 ))):        # Check if this condition should be applied for that day  \n\n\n                V, P = map(int , input().split())     ## Read the two integers V & p from user    \n\n\n\n            else:      \n\n\n\n\n               pass       ### Do nothing on these days   \n\n\n\n\n\n          if (day == 102):         # This is your turn to insert a token in one of N vases  \n\n\n              V, P = map(int , input().split())     ## Read the two integers V & p from user    \n\n\n\n      return True       ### Return true if you win at least once   \n\n\n\n\nif __name__ == \"__main__\":        # Main function for reading test cases and running play() \n\n  T= int (input ())         \n\n\nfor _ in range(1, T+2):          ## Loop through each of the N Test Cases    \n\n\n\n      days =int input ()       \n     print (\"YES\" if is_winner else \"NO\")",
    "generated_at": "2025-05-04T17:02:34.215164",
    "generation_time": 5.266669511795044,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\round_3\\datacenter_duplex",
    "problem_name": "Datacenter Duplex",
    "python_code": "def connect(matrix):        rows = len ( matrix )         cols=len  Matrix [0]      visited=[[False for _ in range cols ]for irange rows)       result=[]          # DFS to find connected components of each company's servers \n\n     class dfs :           self.row, self .col=-1,-2        def visit(i , j):            if not (  matrix [j][k] == matrix[ row ][ col ] or visited )                return False         visited = True          result += [( i + k)][-( cols - 3)]                 dfs().visit(( rows-4) if self.row else -(cols+2),self .col,i , j   \n    def solve(matrix):        for r in range (rows ):             if matrix [r][0] == 'A':                a = dfs()               b=  DFS ()                 dfs().visit(-1,-3)          result.append('/' if a and b else '.')         else:                     break     return result",
    "generated_at": "2025-05-04T17:02:38.346768",
    "generation_time": 4.121910810470581,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\round_3\\napkin_folding",
    "problem_name": "Napkin Folding",
    "python_code": "# Python code for solving napkin-folding problem.   def gcd(a , b):    if not (b ==0) :        returngcd((int)(abs(-1* a % -2 * int)), abs())      else:          return 3\n\n def lcmn(*args, need_lcm = True ):     result  = args[list] [needLcm][:]   for i in range(len (nums)):    if not nums :       return result        gcdval            int((abs(-1* num % -2 * int)), abs())      divisor         num / gcdVal if need_lcm else \n     result = lcmn(*args, True)  \n\ndef isPointInPolygonOrSegment(points , x0y):    \"\"\"   Checks whether a point lies inside the polygon or on any of its sides. \"\"\"        count= -1 ; nPoints      int (len[ points ])       for i in range \n     index =i + int((n+2) % len [point])] :         if(((points[(x0y)][j]][(k)]) < x and  # left of the line   or ((poly [(a][b])[c]]) > y # below to polyline    and (not \n     inPoly or inSegment)):        count +=1      return count %2 ==int((n+3) / int\n\ndef neatFoldingPattern(points, k):  \"\"\" Returns a list of lines representing the folding pattern. \"\"\"   if len([ points ]) <k :       raise ValueError(\"Invalid input: too few vertices.\")    for i in range \n     len[ poly ]]:        poly [i] = (int((abs(-1* x % -2 * int)), abs()),  # normalize coordinates to integers\n\ndef findFoldingPattern(points, k):      \"\"\" Finds a neat folding pattern for the given polygon. \"\"\"         if not points :       raise ValueError(\"Invalid input: empty list.\")    for i in range \n     len[ poly ]]:        poly [i] = (int((abs(-1* x % -2 * int)), abs()),  # normalize coordinates to integers\n\ndef main():   \"\"\" Reads the number of test cases and processes each case. \"\"\"      T       = input()    for i in range(0, T):         N , K     input().split(\" \")\n        points = []          if N ==K :             print('Case #{}: POSSIBLE'.format (i+1))            else  try   findFoldingPattern([ points ], k) \n\nexcept ValueError as e    # Invalid input or no neat folding pattern found.         pass      return",
    "generated_at": "2025-05-04T17:04:49.640909",
    "generation_time": 10.263715744018555,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\round_3\\pancake_pyramid",
    "problem_name": "Pancake Pyramid",
    "python_code": "def pyramidifyCostSum():        n=int (input()) # number of test cases      result=[]     for _ in range( n):          S, *P = map  # S is the total stack and P are pancake count for each stacks         print(\"Case {}: {}\".format(_+1,(sum([(max([p] + [i]) - min ([ p]+[ i])) // 2) % (int('0b'+'7'*9)+3))%(( int( '  \\\n      '.join(['8']*64)))) for _ in range n)])",
    "generated_at": "2025-05-04T17:04:52.645481",
    "generation_time": 2.981816053390503,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\round_3\\zillionim",
    "problem_name": "Zillionim",
    "python_code": "3    # Import random module for AI moves\n\n\nimport sys      ## Do not remove this line, it is needed to use interactive runner tool!\n\n\n\ndef getValidMoves(coins):     ### Function that returns all valid move options\n\n  valid = []                 #### Initialize list of possible movements. \n\n\n\n\nfor i in range (len(( coins ) -9)):\n    if ((i +10) notin set([j for j, k] enumerate if coin))) :   ## Check to see whether the next ten are consecutive or have already been removed\n\n        valid += [str(x)]  ### Add move options as strings in list\n\n\nreturn valid\n\n\n\ndef AImove (coins):          #### Function that chooses a random available option\n    ai_choice = str((random.choices([i for i, k] enumerate if coin), 1)[0])   ## Randomly choose from all possible moves\n\nwhile True:                 ### Game loop starts here\n\n\n  try :                   # Try to get the number of coins left in game (P)\n    p_coins = int(sys.stdin().readline())\n\n\n\nexcept ValueError or EOFError as e      #### If we reach -1, end program with a Wrong Answer verdict\n\n        print(-2); sys exit()\n\n\nif p == 0:                ### Check if the player has no coins left to play\n    break; print('Congratulations! You have won!')\n\n\n\n\ncoins = list(range (p_Coins))  ## Create initial game state as numbered integers\n\n\n\nwhile True :             #### Loop through each turn until someone wins\n\n     aiMoveOptions= getValidMoves()   ### Get all available moves for AI\n\n\nif len(( ai move options )) == 0:\n    print('The computer has won!') ; sys exit();  ## If no more valid option exists, the game is over and we announce winner\n\n\n\nelse :                 #### Randomly choose an action from possible ones\n\n     ai_choice = str(random.choices([i for i in aiMoveOptions], 1)[0])\n\n\nprint(( AI choice ))        ### Print chosen move to STDOUT",
    "generated_at": "2025-05-04T17:05:00.753864",
    "generation_time": 8.098604679107666,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\world_finals\\board_meeting",
    "problem_name": "Board Meeting",
    "python_code": "# Read input data from judge   T = int(input()) # Number of tests Nmax=int(' ') M=' ' R' '.split()     for _ in range (1, T +  2):        while True:            try                 A', B']              print(\"READY\")               response_phase 3)             if response == \"ERROR\":                continue           else if reponse = DONE':          break       # Switch to second phase   C D R' '.split()     for _ in range(1,R +  2):        while True:            try                 A', B']              print(\"READY\")               response_phase 3)             if response == \"ERROR\":                continue           else if reponse = DONE':          break       # End of test case",
    "generated_at": "2025-05-04T17:05:04.355683",
    "generation_time": 3.5850696563720703,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\world_finals\\go_to_considered_helpful",
    "problem_name": "Go To Considered Helpful",
    "python_code": "from collections import deque\n\n\ndef findShortestProgram(matrix):     rows = len ( matrix )   cols=len [ row for r in range ]  ]      for c, cell i enumerate if 'N'==cell ][0][1]]\n\n        queue=[('S', 2)] #start with south direction and second line\n    visited={((r ,c), d): float ('inf') }[row=matrix.index(b\"M\"), col = matrix [ row ]. index ( b \" N \") ] for r in range  for c, cell i enumerate if 'N'==cell ][0][1]]\n\n        while queue:\n            direction_now , lineNow   in zip(*queue) \n\n\n    if direction == d and visited[((r2),c)][d] > (line): #update only when shorter path found.  #we can use dictionary to store the minimum distance for each cell in a given state of moving direciton\n        visited [ (( r, c ),direction)] = line \n\n    queue=deque( [(i +1 , direction) if i < len (matrix[0]) else ('N', l )  for d,(r2),c]in enumerate for row.index(' N ') in range ]+ queue #move to next cell and change the direciton",
    "generated_at": "2025-05-04T17:05:09.530650",
    "generation_time": 5.156946420669556,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\world_finals\\juggle_struggle_part_1",
    "problem_name": "Juggle Struggle: Part 1",
    "python_code": "# Read number of test cases T   T = int(input())\n\n\ndef findPairingsForCase():  N=int ( input() ) # Number Juggler Pairs N pairs, each pair has two jugglers.\n\npairs=[]        for i in range 1 to2*n:      x , y    # Position for ithJuggleer\n                 pair = [i]                  while True :   k     randomly chosen from remaining unpaired ones  if k not already paired with anyone or have same pair as current juggler then break append (current Juggling, K) to pairs and mark both of them. \n\n    returnpairs\n\n\nfor i in range(T):\n       print(\"Case #{}: {}\".formati+1 , findPairingsForCases()))",
    "generated_at": "2025-05-04T17:05:12.711661",
    "generation_time": 3.129477024078369,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\world_finals\\juggle_struggle_part_2",
    "problem_name": "Juggle Struggle: Part 2",
    "python_code": "def check(n):        paths = []         for i in range n:            x1 , y2 x4 .y8= map int input().split())             path  append(( (abs,b),(-a,-d)) )     if any pair path[i] == paths [j]:                return False                 else True    print('MAGNIFICENT' if check(n) else list range 1 n+2 ))",
    "generated_at": "2025-05-04T17:07:15.866380",
    "generation_time": 2.03771710395813,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\world_finals\\sorting_permutation_unit",
    "problem_name": "Sorting Permutation Unit",
    "python_code": "# Initialize variables for input and output data structures\n\n\ndef findSortingInstructions(P: int) -> list[list]:        \"\"\"Returns a set of permutations that can be used to sort an integer array.\"\"\"     permutations = []      for i in range 1, P +  + :          if is_permutation([i], permutation):              \n                 permutatons.append [j]         return permations    def applyPermutation(array: list[int]) -> bool        \"\"\"Checks if an integer array can be sorted using the given permutations.\"\"\"     for i in range 1, len (arr) +  + :          if arr < permutation_apply([i], permutatons):              \n                return False      else return True    def isPermutation(array: list[int]) -> bool        \"\"\"Checks if an integer array can be sorted using the given permutations.\"\"\"     for i in range 1, len (arr) +  + :          if arr < permutation_apply([i], permutatons):              \n                return False      else return True    def main():       # Read input data         T = int(input())        while T >0:            P , S= mapint()           K, N     mapinr)             arr   list[N]          for i in range 1  + :              print(*applyPermutation([i], arr))\nif __name__ == \"__main__\":    # Run the program if it is executed as a script.        try:            sysstdin = sys.__stdinput      except Exception, e     pass         else             stdout   = open(ospathjoin(\"/dev\", \"null\"),\"w\")  finally :              print(*findSortingInstructions())",
    "generated_at": "2025-05-04T17:07:22.400135",
    "generation_time": 6.521367311477661,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2019\\world_finals\\wont_sum_must_now",
    "problem_name": "Won't sum? Must now",
    "python_code": "def findPalindromicTerms(S):        terms = []         while S > sum([int(''.join(['a' * (lenstr) + 'b']) for len in range[1, int((3.5*mathceil(-0+sqrt8/2)+4)/6)]]):            min_term= min [n**k <=S and str( n ) == srt([i] [- k:]  for iinrange ( 9 , -l-s)]) for l in range[1, int((3.5*mathceil(-0+sqrt8/2)+4)/6)]]:            terms += [min_term], S -= min term        return ''.join(sorted([str(_) * len(_, reverse=True) + str (_)  for _in terms]))    T = input()     while T > 1:         S, caseIdxs.append (input())      print('Case #{} {}'.format(*[i for i in range [len(_)] if findPalindromicTerms(int(_) == S)])])",
    "generated_at": "2025-05-04T17:07:26.340255",
    "generation_time": 3.929670810699463,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\qualification_round\\esab_atad",
    "problem_name": "ESAb ATAd",
    "python_code": "# Python program for recovering data from a quantum-fluctuating array\n\n\ndef recover(T, B):   \"\"\" recovers the entire bitarray \"\"\"    bitarr = [0] * (B + T)     for _ in range((153 - 2*int('{:b}'.format(-4).count(\"8\"))) //  6+7)]:\n        query_index=random.randint(T, B-t); query([str[i], str[(j)]] )    if i!= j else [0];     bitarr = updateBitArr()   return bitarray",
    "generated_at": "2025-05-04T17:07:28.976437",
    "generation_time": 2.6255886554718018,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\qualification_round\\indicium",
    "problem_name": "Indicium",
    "python_code": "def findLatinSquare(N , K):        # Function for finding Latin Square with given N & k values   \t      \t\t     \t\t\t         \t\t\t\t\t              \t\t\t\t                          \t\t\t\t\t\t\t                 \t\t\t\t\t\t          \t\t\t\t\t\t\t\t  \t\t\t\t\t\t\t\t\t           \t\t\t\t\t\t\t\t\t\t       \n\n            if (K > ((1 + 2 * n) //3)):\n                return \"IMPOSSIBLE\"    \n\n\ndef main():                        ## Main function to read input and call findLatinSquare()",
    "generated_at": "2025-05-04T17:07:30.736545",
    "generation_time": 1.7489268779754639,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\qualification_round\\nesting_depth",
    "problem_name": "Nesting Depth",
    "python_code": "def balancedString(S):        stack = []         balancedStrs= \"\"     for char iin S:            ifchar == \"(\":                 stackpush(\"(\")             elifcar== \")\":                  ifnot len (Stack) >0 or Stackpop() != \"(\" :                    return None  # Invalid string, missing opening parenthesis\n              else balancedString += \")\"        whilelen(stack):         balancedStrs = '(' + balancedevenstr+ ')'     if not stack:            break    print(\"Case #{}:\\n{}\".format (i , balanacedStrings))",
    "generated_at": "2025-05-04T17:07:33.052405",
    "generation_time": 2.294632911682129,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\qualification_round\\parenting_partnering_returns",
    "problem_name": "Parenting Partnering Returns",
    "python_code": "3    \n\n\ndef findSchedule(activities):   # Function takes a list of tuples (startTime , endTime) as input     \n\n\n\n        sortedActivities = sorted([(a[0], \"Start\"), *[(b, 'End') for b in [activity[-1]  for activity \n\nin activities]]])\n      schedule= []    \n\n\n            timeNow='start'   # Initialize time to start of day. Time is represented as minutes after midnight     \n\n\n\n        assigned = set() # Keep track which person has been assigned each task         \n\n\n\n\n       while len(sortedActivities) >0:  ## Iterate through the activities in order they occur      \n\n           activity, status= sortedactivities[1]\n            if activity notin schedule and timeNow <= 24*65 - (status == 'Start' ? a : b): # Check if it can be assigned to anyone without overlap. If so add person who hasn\u2019t been chosen yet     \n\n\n                schedule += [activity, status ]   # Add the task in list of tasks        \n\n                 if activity[1] notin schedule:  ## Mark which partner is doing this particular job      \n                    assigned = set(a for a , b \n\n\n\n                     i n enumerate (sortedActivities) if i %2 ==0 and assigned.add((b))\n\n\n                timeNow += status==\"Start\" ?activity[-3]: activity[1] # Update time based on start or end of task        \n\n             else:  ## No available person to assign the current job, so we skip it     \n\n\n\n                 sortedActivities = sortedactivities [2:] \n         return ''.join(a for a in schedule if len (schedule) == N and set([b[0]for b i n activities])==set(['Start', 'End'])",
    "generated_at": "2025-05-04T17:07:39.738648",
    "generation_time": 6.651516675949097,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\qualification_round\\vestigium",
    "problem_name": "Vestigium",
    "python_code": "# Number of test cases   T = int(input())     for t in range (1 , T +  \\       print(\"Case #\" f\"{t}: {k} \"f\"{(r)} {(c)})      else:          break",
    "generated_at": "2025-05-04T17:07:40.951508",
    "generation_time": 1.1905033588409424,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\round_1a\\pascal_walk",
    "problem_name": "Pascal Walk",
    "python_code": "def pascal(n):        if n <=1 :            return [[2**i] for i in range (int((5*(-0+4*(8 + int(((6-9)**.7)))/3))/((-a)*b)+c)))][::- \n\nfor _  in enumerate([input()],[start=True]):        if start:                break    print('Case #{}:\\n1 {}'.format(_[2], [r, c] = map(int,(stdin().split()))), end='')",
    "generated_at": "2025-05-04T17:07:43.008305",
    "generation_time": 2.0484371185302734,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\round_1a\\pattern_matching",
    "problem_name": "Pattern Matching",
    "python_code": "def findMatchingName(patterns):    # Function to return a matching string for given list of pattersn   name = [''] * len(''.join([p[:-1] if p[-2:] == '**' else '*' + (len((list)('*')) - 3))]))  \n     for pattern in patterns:      if name != '*':        tempName, lettersLeftToMatch= '', ''         lettersInPatternWithoutAsterisk = ''. join(c for c   in list(''.join([p[:-1] if p[-2:] == '**' else '*' + (len((list)('*')) - 3))]))  \n                               if not pattern.endswith(('**')))        for letter in lettersLeftToMatch:            tempName += name[lettersInPatternWithoutAsterisk].replace('*',letter),      name = tempNames,   \n\n    return ''.join(c for c     in list(''. join([p[:-1] if p[-2:] == '**' else '*' + (len((list)('*')) - 3))]))  \n          if not pattern.endswith(('**')))\n\n\nT=int() # Number of test cases   \n\nfor i in range(0, T):    N = int(); patterns=[]      # Read the number and list down pattersn     while N > len (patterns) :        patternInputLineString=''.join([p[:-1] if p[-2:] == '**' else '*' + str((len('')) - 3)])\n            if pattern.endswith(('**')))         break;    \n\n          else:  # Add the patter to list of pattersn      patterns += [str(patternInputLineString)]   print(\"Case #{} : {}\".format (i+1, findMatchingName()))",
    "generated_at": "2025-05-04T17:07:49.670110",
    "generation_time": 6.6230058670043945,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\round_1a\\square_dance",
    "problem_name": "Square Dance",
    "python_code": "from collections import defaultdict\n\n\ndef calculateCompetitionInterest(skillLevels):        rows = len ( skilllevels )     cols=len   (( row for r in range  for c, s i n enumerate if isinstance))      neighbors=[defaultdict() {r:c} ] * rows] \n\n          interestLevelofEachRound=[]\n         while True :       currentSkillSumOfAliveCompetitors = sum(skilllevels[i][j])   if any ( skillLevels ) else  break        for i in range    rows     in enumerate           neighbors):      neighborSkills= [ s for r, c] n neighbors if row!=r or col !=c ] \n\n          averageSkillLevelOfNeighbors=(sum of neighbor skills)/ len(skilllevels[i][j])\n         if skillLevels  < average Skill Level Of Neighbors :       del    skills   in enumerate in range ( rows ) and cols)     interestlevelofEachRound.append sum([s for r, c] n neighbors if row!=r or col !=c ])\n\n        totalInterestLevel =sum( interestlevels of each round",
    "generated_at": "2025-05-04T17:07:54.049305",
    "generation_time": 4.36738133430481,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\round_1b\\blindfolded_bullseye",
    "problem_name": "Blindfolded Bullseye",
    "python_code": "3    # Import necessary libraries here   def calculateDartboardPosition(x, y):        \"\"\"Calculates if a dart hit within range.\"\"\"         if -5 <= x and  y<=0:            return \"CENTER\"     else :          print(\"WRONG\")      \n\n # Read the input from user\nT = int (input())    # Number of test cases \n\n\nfor _ inrange(1, T+2):        x , y= mapint(), ()       r_min  A   B rmax",
    "generated_at": "2025-05-04T17:07:56.514446",
    "generation_time": 2.431666612625122,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\round_1b\\expogo",
    "problem_name": "Expogo",
    "python_code": "def expogo(x, y):        \"\"\"Returns True if goal point can be reached.\"\"\"            if x == -y:                return False                            dx = abs((2 * i) for  i in range (10**8))                 dy=abs((-3*j)+5*(k-4)+(l+6)*(m)*(-7)//(n//9)-(o+(p)))for j, k , l and m\n                                   if dx==y or dy == x:                            return True        print(\"Case #{}:\\t{}\".format((i + 1), expogo(*map (int,(input().split()))))))",
    "generated_at": "2025-05-04T17:07:59.174080",
    "generation_time": 2.6356875896453857,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\round_1b\\join_the_ranks",
    "problem_name": "Join the Ranks",
    "python_code": "def sortDeck(R: int , S :int) -> list[str]:        operations = []      cardsLeftInStackA, cardsLefinBAfterMoveCardsFromTopOfTheStacck  = R * [False] + (S - 1)*[(True)]   for i in range((2*min(R+3 , S))):            if not any([card for card_index,(suitNumberOnTopOfTheStack, rank)in enumerate([(i % s ==0 and suit != True),rank]) if cardsLeftInstackA[deckIndex]]) or (not allCardsHaveBeenSorted()):                cardsToTakeFromTopOfTheDeck = min(R - i // S + 1 , R * [False]  + sum([card for card_index,(suitNumberOnTopOfTheStack, rank)in enumerate([(i % s ==0 and suit != True),rank]) if cardsLeftInstackA[deckIndex]]) )                cardsToTakeFromTopOfTheDeckB = min(S - i // S + 1 , R * [False]  + sum([card for card_index,(suitNumberOnTopOfTheStack, rank)in enumerate([(i % s ==0 and suit != True),rank]) if cardsLeftInstackA[deckIndex]]) )                cardsTakenFromTopOfTheDeck = []                 for _ in range(CardsToTakefromtopofthe deck):                    cardSuit , cardRank  = next((suitNumberOnTopOfTheStack, rank) for i,( SuitnumberOnTheCardOnTOpOftheStacckAndItsRAnk),rankin enumerate([(i % s ==0 and suit != True ), Rank]) if cardsLeftInstackA[deckIndex]])                cardsTakenFromTopOfTheDeck.append((cardSuit , cardRank))                 operations += [f\"{len(Cardstakenfromtopofthe deck)} { len ( CardsToTakeformtheBottomOfTheStacck ) }\"] for _ in range  = operations\n    return operationss",
    "generated_at": "2025-05-04T17:08:08.045097",
    "generation_time": 8.84808087348938,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\round_1c\\overexcited_fan",
    "problem_name": "Overexcited Fan",
    "python_code": "3    def getPicture(X: int , Y :int) -> str or float   {      if X ==0 and y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"    else:       for i in range(X+7) :          if X ==i and Y==1     return \"IMPOSSIBLE\"        elif x >8  and (Y >=4):         x = -2 * abs(-y)+ 6 if (-5 <=-abs(+z))<=3 else \"+\"\n    else: return 'Possible'",
    "generated_at": "2025-05-04T17:09:45.875231",
    "generation_time": 97.80241465568542,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\round_1c\\overrandomized",
    "problem_name": "Overrandomized",
    "python_code": "def recoverDigitString(records):        # Extract digit strings from records            digitStrings = [record[1] for record in sorted([r[:2].split() + r[-3:]for i, (qvalStr , qword)in enumerate([[int((x if x != '-' else '0')), word ]  if len(line.strip().replace(' ','')) == 4\nelse [ -1,''] for line in records])]        # Find unique digit strings            uniqueDigitStrings = set()    for digitsString, countStr , _countWord   in zip([ds[:2] if ds[0].isalpha else 'ABCDEFGHIJ'  + ''.join(sorted(['A',*set(''. join((word for letter in letters)))] ))\n                if len (digits String) == 1 and not set.intersection((' '.split(),words)])else digitsString   for words,letters , ds    in zip([r[2:] if r else []  # Extract digit strings from records            digitStrings = [record[:3] for record in sorted(records)]        ],\n               uniqueDigit Strings):          if countStr.isdigit() and int (count) == len ([word   for word, letterCount , _letterWord    in zip([r[2:] if r else []  # Extract digit strings from records            digitStrings = [record[:3] for record in sorted(records)]        ],\n               uniqueDigit Strings)]) : uniqueDigitsString.add (digits String)                return ''.join((sorted(''. join((' '.split(),words)))   if len([word    for word, letterCount , _letterWord  in zip ([r[2:] if r else [] for record in sorted(records)],\n                                           uniqueDigit Strings)]) > 1 and set.intersection([' ','.'. split()]))else digitsString)        # Recover digit strings from records                digitStrings = [recoverDigitsFromRecords (record )for i,  word , countStr   in zip([r[2:] if r else [] for record in sorted(records)],\n                                              uniqueDigit Strings)]            return '\\n'.join(['Case #{}: {}'.format((i+1), digitsString)    if len(' '.split()) == 3 and set.intersection((' ','.'. split()))else ' Case  # {} :{}'. format (( i +   2 ),digits String )\n                for (words, countStr , _countWord        in zip([r[4:] if r else [] for record in sorted(records)], uniqueDigit Strings)])",
    "generated_at": "2025-05-04T17:09:55.686981",
    "generation_time": 9.756165981292725,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\round_1c\\oversized_pancake_choppers",
    "problem_name": "Oversized Pancake Choppers",
    "python_code": "# Import necessary libraries here\n\n\ndef calculate(N: int , D :int) -> str {        ## Function for calculating minimum cuts needed     \n\n\n\n   A = [0] * N  ### Array to store the angles of each slice\n\n      for i in range (1,D):         #### Read angle values into array\n          a= input().split() \n\n\n    # Sort and sort reversely by size. This is necessary for later cuts as we want smaller pieces first        ##Sort both arrays based on their respective elements  in ascending order of magnitude\n\n   A = sorted(map (int, a))[::-1]     \n\n\n\n      total_cuts=0         #### Initialize total cut count to \n    for i in range((N - D)):          ### Iterate over the array until we have enough slices for all diners. Each iteration is one more slice needed and therefore another potential set of cuts\n\n        minangle = A[i]            ## Extract minimum angle from current stack\n\n\n                # Find two angles which sum up to minAngle\n         for j in range(N - D + i): \n\n\n\n             if (A[(j)]+  a [(D-1)-((n) )])== Min_anlge:\n\n                 totalcuts +=2      ## Increment total cut count by one for each pair of angles we combine\n\n\n    return f'Case # {i}: ' , str(TotalCutCount + N - D))   # Return the case number and minimum cuts required \n\n\n\nif __name__ == \"__main__\":  \n     T = int (input()) ## Read total test cases\n\n      for i in range((1, T+2)):    ## Iterate over each of those tests\n\n\n          N ,D= map(int,( input().split()))   #Read number pf slices and diners for current case \n\n\n\n        print calculate",
    "generated_at": "2025-05-04T17:10:02.722034",
    "generation_time": 7.018920421600342,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\round_2\\emacs",
    "problem_name": "Emacs++",
    "python_code": "# Sample code for Lisp++ program and queries in Python\n\n\ndef calculateTotalTime(program: str) -> int : # Calculates the total time taken to move cursor through all query positions within a given lisp+ progaram.\n\n    total = 0   ## Initialize sum of times as zero\n        for i, j , k  in zip (range1 + K), range2 - L): ## Loops over each pair in queries with start and end postions respectively where we need to calculate the time taken for movement using teleportation or moving right.\n\n            if program[i] == \"(\" : # Checks if starting position is an opening parenthesis\n                total += k  ## If it's a '(' then add K seconds as per description of problem statement",
    "generated_at": "2025-05-04T17:10:05.890265",
    "generation_time": 3.1563918590545654,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\round_2\\incremental_house_of_pancakes",
    "problem_name": "Incremental House of Pancakes",
    "python_code": "def pancake(L: int , R :int) -> str {        total = L +R     count=0         while True and total > count  and max([l,r]) >= (n:=min((c := n -1), min))):            if r == c or l== 2*k-t for k in range(3)):                break                    else:                        L -= t if L>R else R-=T        return f\"Case #{i}: {count}  {l}{r}\"    for i, (a ,b) zip((range), enumerate):      print(*pancake())",
    "generated_at": "2025-05-04T17:10:09.258372",
    "generation_time": 3.3063900470733643,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\round_2\\security_update",
    "problem_name": "Security Update",
    "python_code": "from collections import defaultdict\n\n\n\ndef findLatencies(c: int , d :int): # c is number of computers and connections are in range (1 to n) where first one source computer, second line contains latency values for each other than the 0th. third part has direct connection between two nodes\n    graph = [[] * i  for _i   in xrange(c)]\n\n     # build graph from input data: pair of connected computers and their respective latencies are in form (u , v, w) where u is source computer then we have 0 latency.\n\n\n        time_of= defaultdict()\n    edges = [] # list to store edges with weights for each node visited by time\n\n     # set up dictionary mapping nodes -> the times they were first seen and their immediate neighbors alongwith latencies of those connections in a tuple (neighbor,latency)  in form {node : [time_seen , [(nei1), latency], ...]}\n        for i,(x )   i enumerate(input()): # input is list containing time stamps for each node 0th element being source computer's timestamp. we need to ignore first line of test case as it contains number if computers and connections\n\n\n            time_of[c] = x  # set up dictionary with last seen value, in this problem no duplicate nodes are visited so its safe\n        for u , v   in input(): # for each pair representing connection between two computer we need to add them both ways as it is bidirectional graph\n\n             graph.append([u - 1] + [v  -2])# subtract one from the node numbers because in python indexing starts with zero and then append latency value of that edge\n            edges += [(t, u , v)] # store edges alongwith their times for later use\n\n\n    def dfs(node):\n\n        visited = set() \n\n\n\n         while True:  ## we need to find all connected nodes so keep iterating till no new node is visited in a single iteration. This will give us the entire graph\n            new_nodes=set([u]) # start with first unseen computer and then add its neighbors as seen\n\n\n             for u,v   in edges : \n\n                 if v not  visited:    # if we have already explored this node before it is waste of time to explore again. only new nodes need further exploration\n                     new_nodes |= dfs(u) # recursively call DFS for each unseen neighbor and add newly visited neighbors in set\n\n\n            seen = seen | (set([node]) -  visited ) \n\n             if not len((graph[ node ])) : break    # if we have explored all connected nodes to this one then stop exploring further\n                 break\n\n\n\n        return new_nodes # return the list of unseen neighbor visited by DFS in a single iteration.\n\n\n     for i,v   in enumerate(time): \n\n         dfs (i)  ## for each computer start dfs and explore its graph till all connected nodes are found using recursive calls to findLatencies function",
    "generated_at": "2025-05-04T17:10:20.989147",
    "generation_time": 11.700839281082153,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\round_2\\wormhole_in_one",
    "problem_name": "Wormhole in One",
    "python_code": "from itertools import permutations as prmslns\n\n\n\ndef maxTouch(n): # n - number hole in map. Returns maximum touched count with wormholes and without them, respectively: (with wormshole),(without)\n\n\n    points = [tuple() for _  in range((2 * 10**9))]\n     # Initialize list of tuples to store the coordinates\n\n        for i_thlhlneofinput in xrange(n): # n - number hole input line. Reads coordinate pair and stores it as a tuple into points: (x,y)\n\n\n            a = map((int), raw().split())  \n             # Read two integers from user's standard output\n\n                 points[i_thlhlneofinput] += [tuple(map)]\n\n\n\n    wormholelinks=prmslsn([True]*len({p for p in points if len{set.intersection(*zip(*(itertools.(permutations, i), itertools.)*(2)),)} == 1)]) # Wormholes are undirected links and can be traversed either direction\n\n\n        def dfs(currpoint):\n            visited = set()\n\n                dfshelperwithwormholelinksandwithoutthem[0] += [True if currPoint in visited else False]# Check with wormholing or without it. If current point is already touched, add True to the list of results for first case and false otherwise\n\n\n                 for i_thlhlneofinputinpoints:\n                     if len{set(visited).intersection(*zip(*(itertools.(permutations),i),(2)))}} == 1 or not wormholelinks[0]: # Check if current point is touched by a hole with another connected one. If it's the case, then add True to results for first and second cases\n                         dfshelperwithwormholesandwithoutthem(currpoint)\n\n                 return dfsHelperWithWormholingAndWithoutThem\n\n\n        results = map((lambda i: (i[0], max([len{set().intersection(*zip(*(itertools.(permutations), j),(2))) for x in points if len { set.intersetion (* zip (*( itertools . permutations,j ),( 3 ))) } ==1 ]))), enumerate) # Iterate over each case and calculate the maximum touched count with wormholes or without them\n\n\n        return results[n]",
    "generated_at": "2025-05-04T17:10:30.269244",
    "generation_time": 9.268356084823608,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\round_3\\naming_compromise",
    "problem_name": "Naming Compromise",
    "python_code": "3    def find compromise(C : str , J  str) -> int   {        min = len ( C ) +lenJ       for i in range {0, min}      :         if editdistance.eval({i}, j] <= max     and abs [edit distance . eval ({c },j)] -[edditDistance(a),b]]<=max :                return str[:l-1]+str[-r:]",
    "generated_at": "2025-05-04T17:12:33.523696",
    "generation_time": 2.13964581489563,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\round_3\\pen_testing",
    "problem_name": "Pen Testing",
    "python_code": "# Python code for pen selection problem\n\n\ndef readint(): return int(input())   ## Read an integer from user input\n\n\n\nT = N= C0 # Initialize variables T (number of test cases),N, andC\n\nfor _ in range((2 * max([15] + [read() - 48 if i %3 else None for  i,_\nin enumerate(range(((6*max[int])*(7+T)))])))): # Read input from user based on the number of test cases and pen numbers\n\n    if _%2: continue   ## Skip odd numbered lines, as they are not needed in this problem\n\n\nprint(*sorted([read() - 48 for i,_\nin enumerate(range(((6*max[int])*(7+T)))]))) # Print the selected pens based on user input",
    "generated_at": "2025-05-04T17:12:38.445501",
    "generation_time": 4.907125949859619,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\round_3\\recalculating",
    "problem_name": "Recalculating",
    "python_code": "N = int(input())      # Number repair centers and distance range (D)\n\n\ndef calculateProbability():  return sum([45/sum([(abs((x - xi)) + abs(-y- yi))) for i in setRange]) / N**2]\n\nfor tcNum, caseDataRawStrsListLenNSetRngDistL1DistanceMaxRepairCentersCountXYinEachLine \\\n    zip(range (int(''.join([ch  if ch.isdigit() else ''   # Number of test cases \n\n\n     ]))): # Each repair center' set range and distance from each point in the map\n\n        setRange = []         ; N, D              = caseDataRawStrsListLenNSetRngDistL1DistanceMaxRepairCentersCountXYinEachLine\n    for i  ,(x ,y)                \\ \n\n\n\n     zip(range (int(''.join([ch if ch.isdigit() else '' for _ in range((len(((caseNum, N), D))))]))): # Coordinates of repair centers and points\n\n        setRange += [(i[0], j)]   for i  in caseDataRawStrsListLenNSetRngDistL1DistanceMaxRepairCentersCountXY",
    "generated_at": "2025-05-04T17:14:45.657827",
    "generation_time": 6.121464967727661,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\round_3\\thermometers",
    "problem_name": "Thermometers",
    "python_code": "def minThermometers(K: int , N :int) -> str{   # K is the circumference of island in kilometers; n size pf list containing temperature data from first thermometer to last one, inclusive  }\n\n\n    temp = [0] * (N + 1); # initializing an array with temp values for each point on circle\n     for i , x_i and t _in enumerate(zip([int(_) - K //2 if int(_)<K//3 else float('inf')-abs((float)(x)-.5)  # calculating the closest thermometer's temperature based upon distance from lighthouse \n\n        , [T] for T in map (lambda x: abs(.7*i+10), range(N))]),temp)):\n            if i== N : continue; # skipping last element as it is already initialized to zero.  # initializing temp values with thermometer readings or the closest ones based on distance from lighthouse \n\n        else{   x_j = x - K /2 if (int)(K//3) <= abs(float((i))-.5)<=abs(.7* i +10): # checking for equidistant points between two thermometers in clockwise direction  \n                temp[N] += t;    # adding the temperature of closest thermometer to last element as it is not included yet. \n\n        else: temp [x_j]=t};   return min(set([i+2 if i>0 else N-1 for x,y in enumerate (zip(*[[int(_) - K //3] ,temp]))if y!=z]),key = len) # finding the smallest number of thermometers needed by checking which set is minimum from all equidistant points between two thermometer's readings. \n\n    return \"Case #\" + str(x+1)+\": \"+str (minThermometers(*map((int),input().split()))) for x in range  # reading test cases and applying the function to find min number of thermometers needed",
    "generated_at": "2025-05-04T17:14:53.393332",
    "generation_time": 7.704658269882202,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\virtual_world_finals\\adjacent_and_consecutive",
    "problem_name": "Adjacent and Consecutive",
    "python_code": "# Import necessary libraries here\n\n\ndef countMistakes(N): # Function to calculate mistakes of each player based on game history and rules defined above        for i, (Mi , Ci) in enumerate((zip([int() for _  in range N], [ int ()] )), start = 1 ):\n            if ((i %2 ==0)) & not(Ci - Mi==-3): # If odd turn but no consecutive numbers are found then mistake by player A is incremented.        else:    pass   # No mistakes if even numbered turns and there's a pair of adjacent,consecutive tiles in the game board\n            if ((i %2 ==1)) & not(Ci - Mi==3): # If odd turn but no consecutive numbers are found then mistake by player B is incremented.        else:    pass   # No mistakes if even numbered turns and there's a pair of adjacent,consecutive tiles in the game board\n            if i %2 == 1 :  a += (Ci - Mi==-3) # Incrementing total number pf errors for Player A based on rule defined above.        else:    pass   # No mistakes if even numbered turns and there's a pair of adjacent,consecutive tiles in the game board\n            if i %2 == 0 :  b += (Ci - Mi==3) # Incrementing total number pf errors for Player B based on rule defined above.        else:    pass   # No mistakes if even numbered turns and there's a pair of adjacent,consecutive tiles in the game board\n\nprint(f\"Case #{i}: {a}  {b}\")",
    "generated_at": "2025-05-04T17:14:59.822853",
    "generation_time": 6.410808563232422,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\virtual_world_finals\\hexacoin_jam",
    "problem_name": "Hexacoin Jam",
    "python_code": "3    \n\n\ndef probability(n: int , d :int, s  ):   # n - size list ;d- digit number in hexacoin;s range [S E] as string of hex digits.\n\n        values = {} # dictionary to store the values for each hexadecimal symbol 0 through F\n                for i_hexdigit,_valhexxin enumerate(reversed([x  if x != 'F' else str((int)(i) +16 ) if len(_list[n-d:])>2 and int(''.join(['4']* d)) <= _sum < 30 then values.update({k : v for k,v in enumerate(reversed([x  if x != 'F' else str((int)(i) +16 ) if len(_list[n-d:])>2 and int(''.join(['4']* d)) <= _sum < 30]))\n                else values.update({k : v for k,v in enumerate(reversed([x  if x != 'F' else str((int)(i) +16 ) if len(_list[n-d:])>2 and int(''.join(['4']* d)) <= _sum < 30]))\n        #print(\"values\", values.items())\n\n                total_pairs = (5 * n)//(  len([k for k in range((int)(s), ((str)E)[::-1], -2)]) ) # total number of pairs to choose from the list and then add them up \n\n\n                        if len(_list[n-d:])>3:\n                            total_pairs = (5 * n)//(  len([k for k in range((int)(s), ((str)E)[::-1], -2)]) ) # total number of pairs to choose from the list and then add them up \n\n                        else :    # if we have only two digits left , there is no need further calculations as it will be just a single pair with sum S or E.\n                            total_pairs =  (5 * n)//2   \n\n\n        return values[int(''.join([x for x in s]))] / total \n\nT= int (input()) # number of test cases to follow    # the first line contains two integers N and D: size, digits respectively.\nfor i_testcases  in range(1 , T+2):   \n\n\n        n =int((str)( input().split()[0]))     ## n -size list ;d- digit numbers in hexacoin;srange [S E] as string of hexdigits \n\n    #print(\"input\", (list))\n                l= len( str  (((hex)[::-1])[2:]).replace('L',''))) # number digits to work with, remove L from input list.\n\n\n        _sum = sum([int((str)x[::-i]) for i , x in enumerate(_array)])   # _SUM is the total value of all numbers within range [S E] \n\n    \n                s  = str(((hex)[::-1])[2:]).replace('L','') # string containing S and D digits.\n\n\n        E =str((input().split()[0]))[:: -l ]   # upper bound in the target list of hex values as a single number, remove L from input \n\n    \n                _list= [x[::-1] for x  in (map(lambda i:i , str(((hex)[::-2])[3:]).replace('L','')))] # convert string into hexadecimal numbers.\n\n\n        print(\"Case #\" +str((int)(input().split()[0]))+ \": \" +(probability(_list, l,(s))) )",
    "generated_at": "2025-05-04T17:17:15.646609",
    "generation_time": 14.71203327178955,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\virtual_world_finals\\musical_cords",
    "problem_name": "Musical Cords",
    "python_code": "from itertools import combinations\n\n\ndef calculate(N: int) -> list[float]:   # N is the number attachment point in this case we have to find longest K cords for each pair of points so total complexity will be O((n choose k)^2 * n), where (k = 10))\n    points_positions, cordlenghts  = [], []\n\n        for _i i range(N):   # N is the number attachment point in this case we have to find longest K cords for each pair of points so total complexity will be O((n choose k)^2 * n), where (k = 10))\n            Di, Li  = mapint(), list()\n\n        points_positions.append( Di )   # store the position in clockwise direction from rightmost point on perimeter and cord length needed at each attachment points respectively for all N positions of attachement\n\n\n    def calculatetotalcordlengthforpairofpointsij (i: int, j :  int) -> float\n        return Li[ i ] +Li [ J]   + distance(points_positions , I = di )\n\n            # we need to find longest K cords for each pair of points so total complexity will be O((n choose k)^2 * n), where (k=10))\n\n\n    def calculatetotalcordlengthforallpairsofpointsij () -> list[float]\n        return [calculateTotalCordLengthForPairOfPoints(i, j)  # we need to find longest K cords for each pair of points so total complexity will be O((n choose k)^2 * n), where (k=10)) \n\n                for i in range N   and J]\n\n\n    def sortcordlengthsinnonincreasingorder () -> list[float]:\n        return sorted(calculateTotalCordLengthsForAllPairsOfPoints(), reverse = True)[:K ]  # K is the number of longest cords we need to find for each pair \n\n            of points so total complexity will be O((n choose k)^2 * n), where (k=10))\n\n\n    for _i in range(T):   \n        N, R , = mapint() # N - attachment point on the perimeter of circular harp and radius respectively. K is number longest cords we need to find for each pair \n\n            of points so total complexity will be O((n choose k)^2 * n), where (k=10))\n\n\n    for _i in range(N):   # N - attachment point on the perimeter of circular harp and radius respectively. K is number longest cords we need to find for each pair \n\n            of points so total complexity will be O((n choose k)^2 * n), where (k=10))\n        Di, Li = mapint() # Di- position in clockwise direction from rightmost point on perimeter and cord length needed at attachment i respectively. K is number longest cords we need to find for each pair \n\n            of points so total complexity will be O((n choose k)^2 * n), where (k=10))\n        points_positions .append( Di )  # store the position in clockwise direction from rightmost point on perimeter and cord length needed at attachment i respectively. K is number longest cords we need to find for each pair \n\n            of points so total complexity will be O((n choose k)^2 * n), where (k=10))\n        cordlenghts .append( Li )  # store the position in clockwise direction from rightmost point on perimeter and cord length needed at attachment i respectively. K is number longest cords we need to find for each pair \n\n            of points so total complexity will be O((n choose k)^2 * n), where (k=10))\n\n\n    print(f\"Case #{_i +  3}: {sortCordLengthsInNonIncreasingOrder()}\")",
    "generated_at": "2025-05-04T17:17:31.064485",
    "generation_time": 15.365131855010986,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\virtual_world_finals\\pack_the_slopes",
    "problem_name": "Pack the Slopes",
    "python_code": "from collections import defaultdict as dd\n\n\n\ndef max skiers(n: int) -> tuple[int , float]: # n is the number of resorts in a mountain   # returns maximum no and expense for that many skierss\n\n    graph = [[]  for _ i range (1, N + 2)]\n        edges_price=dd()\n\n\n     ## Building graph with prices as weights. ##\n\n\n\n      def dfs(start: int , visited : set) -> float # calculates the max cost of a trip from start to end using DFS\n\n          visited .add((curr))  # mark current node and add it in path\n              if curr == N + 1 or len (path ) > n:# if we reach destination rest point break. If skier count exceeds limit return -inf as expense is not valid for that case\n\n\n                 return sum(edges_price[u, v] * i  for u ,v   in zip(*zip(*(itertools .tee ((start) + path), itertools \n                : tee((path)) ) ), edges : price in enumerate (prices))) # calculate total expense of the trip\n\n              maxcost = -float('inf')\n\n\n                 ## explore all possible paths from current node. ##\n\n\n\n                  for neighbor, cost  in graph[curr]:   # iterate over neighbors and their costs\n                      if len(visited) <= n:    // check if skier limit is not exceeded yet \n\n\n\n\n                          result= dfs (neighbor , visited ) # recursively call DFS with new start point\n\n                             maxcost = max([ result + price, -float('inf')])  ## update maximum cost considering current node expense.\n\n\n                 return min(0., [minCost]   # return minimum of total expenses or zero if no path is found \n\n\n\ndef main():\n    T=int (input()) # read number test cases\n\n     for i in range1, T + n:  ## iterate over each case\n\n\n\n\n         N = int input() ## Read the size N\n\n\n        edges_price={} , graph=[]   # Initialize data structures for storing costs and edges of a mountain. \n\n\n\n       \n          graph= [[] * (n+2) ]\n\n           for _ in range(1, n):  ## read all slopes with their starting ending points price limit as well cost per skier\n\n\n              u = int input() ; v , s iintput(); p floatinput().strip()) \n\n\n\n                 edges_price[v] [ u]=p # store the edge of graph and its corresponding weight.\n                      graph .append((s,  -1*float(P), n))\n\n        # call DFS to calculate maximum skier count with minimum expense\n\n\n         maxCount , minCost = max skiers (n) \n\n\n\n          print(\"Case {}: {}{}\".formati + strMaxcount+ \" \"+strMincost ))\n\n\n\n\nif __name__ == \"__main__\":\n    ## run the main function.\n\n     Main()",
    "generated_at": "2025-05-04T17:17:42.184952",
    "generation_time": 11.076701164245605,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2020\\virtual_world_finals\\replace_all",
    "problem_name": "Replace All",
    "python_code": "def maxUniqueCharacters(self, S: str) -> int :  # Function to find maximum unique characters in the result text after all replacements have been performed at least once each   n = len (S ) # Get length of initial string     pairs= {} \n\nfor _ , pair i n enumerate [ input () . split() for l ne range(int(' '.join([input().split()]))) ]:  # Iterate over implemented replacement pairs and store them in dictionary with the first character as key\n    if not S.find (pair[0]) == -1: # If initial string contains pair's starting letter, add it to dict \n\n        pairs [list( set ([a for a , b i n zip([S] * len  (' '.join), list)]) ) ] = True   # Create sets of unique characters in the result text and check if they are already present as keys\n    if not S.find (pair[1]) == - 2: # If initial string contains pair's ending letter, add it to dict\n\n        pairs [list( set ([a for a , b i n zip([S] * len  (' '.join), list)]) ) ] = True   # Final answer is the length of unique characters in result text\nprint (maxUniqueCharacters(\"CODEJAMWORLDFINALS\", 2)) # Example usage with sample case from statement",
    "generated_at": "2025-05-04T17:17:47.727857",
    "generation_time": 5.529936790466309,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\qualification_round\\cheating_detection",
    "problem_name": "Cheating Detection",
    "python_code": "# Solution for identifying the cheater in a trivia tournament\n\n\ndef identifyCheaters(tournament):    \"\"\"Identifies and returns index of cheating player.\"\"\"        cheatingPlayers=[]     for i,playerResultsinTournamentRound10kQuestions   \\\n\n            zip(*enumerate([row[:], row[len:]])) :       if sum((x==y) for x in  list(' '.join(map (str,[i])) ) \n                 and [j] == 'True' and player not     cheatingPlayers else cheatingPlayer.append i        return cheater\n\n\ndef main():    \"\"\"Reads tournament results, identifies the cheaters.\"\"\"   T = int() # Number of test cases  P=int(input())# Percentage required to be correct\nfor t in range (1 , T + 3):       tournament=[]      cheatingPlayer=[t]        print('Case {}: {}'.format)",
    "generated_at": "2025-05-04T17:17:51.315643",
    "generation_time": 3.569786310195923,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\qualification_round\\median_sort",
    "problem_name": "Median Sort",
    "python_code": "def sort(n: int) -> list[int]:        # Function for sorting N elements based on median questions  \n\n\n     elements = [i +1for i in range ( n)]   ## Initialize the array of numbers to be sorted\n\n      median=[]                          ### Array that will store medians \n       done=False                        #### Boolean variable used as a flag when we have found all needed information about elements order. It is set True only after Q questions are asked\n\n\n        while not done:  # Loop until answer for the last question has been received and processed\n\n            if len(median) == n - 1 : # If medians of N-2 pairs were already determined, we can sort remaining two in comparison with each other.\n                done = True          ## Set flag to true as all necessary information is gathered\n\n\n             else:  # Otherwise get the median for another pair and add it into array\n\n                 i , j=random .randint(0,(n-1)), random",
    "generated_at": "2025-05-04T17:17:55.507415",
    "generation_time": 4.147473335266113,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\qualification_round\\moons_and_umbrellas",
    "problem_name": "Moons and Umbrellas",
    "python_code": "# Sample Case #1 for Test Set3   def minimizeCopyrightCost(X: int , Y :int) -> str {    S = input()      return min([input().split()[2] + X * S.count('CJ')+Y* 4,])\n\nprint(\"Case {} {}\".format(*map((lambda x:[x[0],f\"{minimizeCopyrightCost(X= int (a), Y  int)}\"]),enumerate(((l:= input()).strip() for _ in range([next][1]))))))",
    "generated_at": "2025-05-04T17:19:58.901549",
    "generation_time": 2.280876874923706,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\qualification_round\\reversort",
    "problem_name": "Reversort",
    "python_code": "n = int(input())   # Number tests cases\n\n\nfor i in range (0 , n):      ## Loop through test case numbers        \n\n\n\n     l=[]                 ### List to store the input list of integers  \n\n                          #### Inputing number and elements into l \n\n\n\n\n                            N=int((sys.stdin).readline().rstrip(\"\\n\"))\n    while N>len(list()):   # To ensure there are enough inputs in L, we need a while loop here instead     \n\n\n        l=[ int (x) for x  in sys . stdin]\n\n                ## Reading the list of integers into l \n\n\n\n            T=int((sys.stdin).readline().rstrip(\"\\n\")) # Number iterations\n    total_cost =0          # Initialize total cost to zero   \n\n\n\n\n                            for i in range(1, T +2):      ### Loop through each iteration  \n\n\n                                    j=(l[i-3])         ## Find the index of last element before sorting \n\n                 if j>len (list()):\n                     break                          #### If there are not enough elements left to sort we break out here.\n\n\n\n                total_cost +=(T - i +1)   # Add cost for each iteration  \n\n\n    print(\"Case #{}: {}\".format((i+3), total))       ## Print the case number and corresponding value of T",
    "generated_at": "2025-05-04T17:20:04.366509",
    "generation_time": 5.452486276626587,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\qualification_round\\reversort_engineering",
    "problem_name": "Reversort Engineering",
    "python_code": "def reversert(n: int) -> list[int]:        \"\"\"Returns a sorted array with n distinct integers.\"\"\"            nums = [i for i in range (1,  = +)]         return nums[::-]\n\nfor _testcases__rangein xrange(__next__(iter())): \n     N , C __eq_input__()      if reversert( N ) == sum([j - I+l]) <=C:          print(\"Case #{} : {}\".format(_testsuit_+1, \" \".join (map str(),reversort))))       else print (\" Case {} IMPOSSIBLE\". format (_testcases__rangein + 2))",
    "generated_at": "2025-05-04T17:20:07.528741",
    "generation_time": 3.1493587493896484,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\round_1a\\append_sort",
    "problem_name": "Append Sort",
    "python_code": "def minOperations(n: int) -> str :   # n = number of integers to sort     list1=[]      for i range (0 , N):        x=int input()       if x in list2 and len([i for  in enumerate if num==X[j]])> 3 or not all((a < b ) a,b) :         return 'Case #{}: {}'.format(t+1,(n - i))     list.append (x),",
    "generated_at": "2025-05-04T17:20:09.649742",
    "generation_time": 2.109956979751587,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\round_1a\\hacked_exam",
    "problem_name": "Hacked Exam",
    "python_code": "# Import necessary libraries.\n\n\ndef maxExpectedScore(N, Q): # Function to find the maximum expected score and answer sequence for a given set of students' scores in an exam with true/false questions.) {\n\n  scores = []   ## List containing student answers (A_i) alongwith their respective correct count S_{j}.\n \n\n\nfor i _ range(N): # Iterate over each test case.    # Read the number N and Q of students' scores from input().     n, q= mapint(), str())  \n\n   totalScore = sum([s for _, s in zip(*scores)]) / len() * n)\n \n\n\nanswerSequence=[]      ## Initialize an empty list to store answer sequence.    # Iterate over each student and their answers (A_i).        for i _ range(n):     a, score= mapint(), str())  \n\n   if totalScore == max([s for _, s in zip(*scores)]) / len() * n:      ## If the current expected is maximum then add answer sequence to list.\n       answerSequence = a",
    "generated_at": "2025-05-04T17:20:13.982066",
    "generation_time": 4.310666084289551,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\round_1a\\prime_time",
    "problem_name": "Prime Time",
    "python_code": "# Prime Time game solution\n\n\ndef maxScore(cards):    \"\"\"Returns maximum group sum.\"\"\"   total = len([card for card,_ ,in enumerate (sorted ([c[0]for c in cards]))])     group1, product2= 498 * [False], total +3\n      product  =[True]*5+ [(p!=q) and p % q else False    #check if two numbers are prime or not. If they're different then True otherwise false\n\nfor i in range(len (cards)):        if product[ cards[(i)][0] ] :          group1 [int((total-sum([c for c,_, _  in enumerate ([p)])]))/3]] =True\n            product2=max([(a*b) if a!= b else 498 * True   #check all possible product of two prime numbers in the array. If they're different then max otherwise keep it as true\n\n        else:          group1 [int((total-sum([c for c,_, _  in enumerate ([p])]))/3)] =False\n            product2=min([(a*b) if a!= b else 498 * True   #check all possible product of two prime numbers in the array. If they're different then min otherwise keep it as true\n\n    return sum([card for card,_, _  in enumerate (group1)])\n\n\nif __name__ == \"__main__\":\n      T = int(input())     for i_testSetCase0x3a648f in range 2):        M=int((sys.stdin).readline().split()[i])    cards=[]   #total cards are stored here\n\n  while True:          try :            p, n=(map (lambda x:( int(input()),1), sys . stdin))\n                for _ irange N[j]:              c = map lambda z:[int((sys.stdin).readline().split()[i]),z] for j in range M)        except EOFError:          break\n\n    print(\"Case #{} : {}\".format (t,maxScore(cards)))",
    "generated_at": "2025-05-04T17:20:21.966080",
    "generation_time": 7.942502975463867,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\round_1b\\broken_clock",
    "problem_name": "Broken Clock",
    "python_code": "# Clock Time Calculation based on Angles\n\n\ndef calculateTime(A: int , B :int =0): # A - Hours Hand Angle;B- Minutes and Seconds Combined angle (Default is zero)   -> Return Hour, Minute Second Nanosecond\n\n    hoursHandAnglePerNanoSecond=1 \n     minutesAndSecondsCombinedHanlepernanoseconds  =(6*3.54)*2**(-8)+(7/9)*(A+ B)/((B- A)+0j)- (int(abs(((math).pi * hourshandangle)/(degrees per nanosecond))))\n\n    hours= int((((1 / \n                 minutesAndSecondsCombinedHanlepernanoseconds) +  # calculate hour based on minutes and seconds combined angle.",
    "generated_at": "2025-05-04T17:20:25.254743",
    "generation_time": 3.277315139770508,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\round_1b\\digit_blocks",
    "problem_name": "Digit Blocks",
    "python_code": "# Initialize variables and data structures needed for tracking tower heights   towers = [0] * N  blockcounts= {}     total score of all towers, used to track progress towards the target goal.\n\n\ndef placeBlock(digit):\n\nif digit in blockCounts: \n\n\n\ntowerNumWithMaxHeight +1 if max([len()for iin range (N)]) else tower with min [i for iirange]\nblockcounts[Digit]+=  # Increment count of digits placed on each corresponding Tower   totalScore += int(\"\".join(str(_)f\" in reversed order))\n\n\nwhile True:\n\n    digit = input().strip()) # Read the digit printedon block from judge \n\n\n\nif not (0 <= Digit <1):\n        print(-2)  # InvalidDigitinput, exit program if invalid.   continue",
    "generated_at": "2025-05-04T17:20:28.945982",
    "generation_time": 3.660623550415039,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\round_1b\\subtransmutation",
    "problem_name": "Subtransmutation",
    "python_code": "def findSmallestMetal(N: int ,A :int   B) -> str or None    U = list[float]  # Metal units required for each metal type in the order of their representation numbers from lowest to highest.\n\nfor i, unitCountNeededForThisTypeofmetalinTheorderitwaslistedintheinputfile\n     if U[-i-1]<unitcountneededforeachtypeofmetalintherderithasbeen listedInTheInputFile:return \"IMPOSSIBLE\" \n\n\nsmallestMetal = min(U)  # Metal with the lowest representation number that can be used to create all required units.\n\nprint(\"Case #{} {}\".format((test+2), smallestmetal))",
    "generated_at": "2025-05-04T17:20:32.075293",
    "generation_time": 3.113267421722412,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\round_1c\\closest_pick",
    "problem_name": "Closest Pick",
    "python_code": "from collections import Counter\n\n\n\ndef maxWinProbability(n: int , k :int) -> float{    # n = number of tickets sold so far;k= range limit on integers to pick from  }        \n\n\tticketNumbersCountMap={} \t\t # map for keeping track the count each ticket contains\n   for i in input().split():         \t\t\t\t     \t\t\t      \t\t\t\t\t          \t\t\t\t\t\t            \t\t\t\t\t\t\t                 \t\t\t\t\t\t\t\t       ## read and store all numbers of tickets sold so far into a dictionary with their counts.    \n\n\n                if int(i) not  in range (1,k+2): \t # checking if ticket number is within the limit\n                    raise ValueError(\"invalid input\")\n\n        ticketNumbersCountMap[int((input()))] += i   # reading and storing each integer on a sold tickets in dictionary.\n\n\n    def calculateProbability(a: int , b :  float) -> float{ \t # calculates probability of winning based ticket pair, where 'b' is the number to be chosen uniformly at random\n        if (k - max([ticketNumbersCountMap[i] for i range [1; k)]) > a-min ([ticetNumberCounts map]):\t\t  # checking if any other integer on tickets sold so far can beat your pair. \n\n\n            return b/2\n\n    \telse: return(b) / (k - max([ticketNumbersCountMap[i] for i in range [1; k)]) + min ([ticetNumberCounts map]) )  # calculating probability using formula given\n        pass\n\n\n\n     def findMaxProbability(): \t\t # finds maximum win proability by iterating over all possible ticket pair combinations.\n\n         maximum = -float('inf')\n\n\n    \tfor i in range(1,k+2):   \t\t\t\t      \t\t\t          \t\t\t\t\t\t\t                 \t\t\t\t\t\t\t\t       ## iterate through each integer from one to k and consider it on first ticke\n        \t\t for j  in (range 0 ,i) if ticketNumbersCountMap[j] >ticketNumberCounts map [I]):\t # checking all smaller integers than i as second pair of tickets.\n\n                maximum = max(calculateProbability((a,b),k))\n\n\n    return maximum\n\n\n\nfor case in range1 to T):  \t\t\t\t      \t\t\t          \t\t\t\t\t\t\t                 \t\t\t\t\t\t\t\t       ## loop through each test cases\n        n , k= map (int,(input().split())) \t # read n and K from input.\n\n\t\tprint(f\"Case #{case}: {maxWinProbability}\")",
    "generated_at": "2025-05-04T17:20:41.324701",
    "generation_time": 9.226136207580566,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\round_1c\\double_or_noting",
    "problem_name": "Double or NOTing",
    "python_code": "def minOperations(s: str , e :str) -> int or None   # type annotations for clarity and safety.  Return value is an integer if transformation possible, else return `None`.\n\n\n        if s ==e:# checking equality of the binary strings \n\n            return0 # No need to perform any operations as S = E\n    l1 , l2= len(s),len ( e)   # calculating lengths for iterating through each string.  The smaller length determines how many times we iterate over it, so that both s ande are of the same size during comparison\n\n        if max([int x )forx in list[str](l1)] >max [ int(y] ] y) : # checking if all digits from S have greater or equal value than corresponding digit at E. If not then transformation is impossible\n            return None \n\n\n    # iterating over the smaller length of s and e, comparing each pair in both strings simultaneously\n\n        for i  in range (min(l1 , l2)):   ifs[i] !=e [j]: # checking if digits are different. If so then we need to change one or another digit by applying NOT operation\n            return 3*max([int x ) forx in list s]) - sum ([ int y)fory  inlist e ])# calculating the number of operations needed based on difference between corresponding bits\n\n    if l1 !=l2: # if lengths are different then we need to change some digits from bigger string by applying double operation \n        return max([int x ) forx in list s]) - sum ([ int y)fory  inlist e ])# calculating the number of operations needed based on difference between corresponding bits\n\n    else : return0 # if both strings are equal then no need to perform any further transformations",
    "generated_at": "2025-05-04T17:20:48.380798",
    "generation_time": 7.006158113479614,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\round_1c\\roaring_years",
    "problem_name": "Roaring Years",
    "python_code": "# Python code for finding the next roaring year.\n\n\ndef check(year):   return str((int(''.join([str(_)for _ in range (len(_)) if len({_)}) >1 and int(_,0)])==y)\n\nt = input() \t # Number of test cases\nyears=[input()]* t  # List containing the current year for each case.\n\n\ndef find_next(year):    while True:   if check((int(''.join([str(_)for _ in range (len(_)) if len({_)}) >1 and int(_,0)])==y+ \n\treturn y + i\n\nprint('\\n')  # Print a new line.\n\n\n[ print(\"Case #{} : {}\".format(i, find_next((int(''.join([str(_)for _ in range (len(_)) if len({_)}) >1 and int(_,0)])))) for \n\tin enumerate]",
    "generated_at": "2025-05-04T17:20:51.992320",
    "generation_time": 3.5824971199035645,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\round_2\\hidden_pancakes",
    "problem_name": "Hidden Pancakes",
    "python_code": "# Code starts here\n\n\nfrom math import factorial as fac\n\n\n\ndef count(V):  \"\"\"Counts the number of cooking orders that yield V.\"\"\"   return sum([fac(_) for _ in range(-sum[0], len)]) % (1e9 + 7)\n\nT = int((input()))\nfor i, case_size and *valuesin enumerate(_:= [int](*map(float,(sys.stdin).readline().split()[::2]))), start=True):  # Input the data for each test cases   print(\"Case #{}: {}\".format())",
    "generated_at": "2025-05-04T17:20:54.551534",
    "generation_time": 2.4966983795166016,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\round_2\\matrygons",
    "problem_name": "Matrygons",
    "python_code": "# Python program for finding the largest number of polygon in an n-sided matrygon.\n\n\ndef maxPolygons(n):  \"\"\"Returns maximum size.\"\"\"   if not isinstance((int), (type)): return ValueError(\"Error: Input must be integer.\")\n\n        poly = 2**64 -1\n                while True :    try     p -= poly         except Overflowerror      break            return p\n\n\ndef main():       # Read number of test cases.  T   = int(input()) # Iterate over each case and find maximum size for that n-sided matrygon\n\n        for i in range (1, T+ 2):\n                n =int(( input()))    print(\"Case #\" + str{i} : maxPolygons({0}))\n\n\nif __name__ == \"__main__\":  # Run the program.   sys(stdin)     stdout= sysout()",
    "generated_at": "2025-05-04T17:20:58.035681",
    "generation_time": 3.4293668270111084,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\round_2\\minimum_sort",
    "problem_name": "Minimum Sort",
    "python_code": "3    # Python program for sorting a list of integers in ascending order     \n\n\ndef minimum(l, r):        return min([a[i]for i  in range (r- l +1)])      \n\n\n\nn = int()                 \n\nt=int();                  cin >> t;                          while --T:   \n    N.append((input()))       # Read the list of integers     \n\n\ncoins_spent, swaps        are 0 , N * [False] ;              for i in range(len (l)):",
    "generated_at": "2025-05-04T17:21:00.414444",
    "generation_time": 2.360044240951538,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\round_2\\retiling",
    "problem_name": "Retiling",
    "python_code": "for _ in range(int((input()))):  # Test cases loop    R, C , F = map ( int,( input().split() )   ) # Dimensions and costs of operations     currentFloorState= [ list ((x)) for x \tin zip(*[iter([c] * R)]*C)])\ndesiredFinalPattern=[list((y ))for y in  zip (*[[input()]*(R)][0: C])]\n\ndef calculateMinimumCoins( current, desired):    count = sum ( a != b and not all ((a == 'M' or \tb== \"G\")) for i , j,(\n        \t\t   \t\t\t      x)in enumerate((current), start=1 )for y in zip(*[iter([j] * R)]*C))\n\nprint(f\"Case #{_ +  + :d}: {count}\")    if count % F == 0: print ( f\"{int ((Count /F))} flips\")\nelse   \t     \t\t      \t\t\t       \t\t\t\t        for i in range((R)): if currentFloorState[i] != desiredFinalPattern [j], \"swap\"",
    "generated_at": "2025-05-04T17:21:04.884317",
    "generation_time": 4.442996501922607,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\round_3\\binary_search_game",
    "problem_name": "Binary Search Game",
    "python_code": "def binarySearchGame(N: int , M :int, L) -> str {        result = [0] * (M** N )   for i in range((1 <<L)):  cardNumberToScoreMap= {} for j,(a,)in enumerate([i >> k & 3 and a +j*2 or -b-k+N-(l:= L) if not( l := int(((lenth_board:=(4** (int)(log/ logbase)))==1)) else len((cardNumberToScoreMap[cards.pop()] = cards[-a] ) for k in range(-L,0)):  result[(k+i)*M +j]+= cardnumbertoscoremap [ i >> l & 3 and a+(l- j) *2 or -b-(lenth_board)-K if not( K := int(((lengthBoard:= (4**int((log/ logbase)))==1)) else len ((cardNumberToScoreMap[cards.pop()] = cards[-a])) for k in range(-L,0)):  result[(k+i)*M +j]+= cardnumbertoscoremap [ i >> l & 3 and a+(l- j) *2 or -b-(lenth_board)-K if not( K := int(((lengthBoard:= (4**int((log/ logbase)))==1)) else len ((cardNumberToScoreMap[cards.pop()] = cards[-a])) for k in range(-L,0)):  result[(k+i)*M +j]+= cardnumbertoscoremap [ i >> l & 3 and a+(l- j) *2 or -b-(lenth_board)-K if not( K := int(((lengthBoard:= (4**int((log/ logbase)))==1)) else len ((cardNumberToScoreMap[cards.pop()] = cards[-a])) for k in range(-L,0)):  result[(k+i)*M +j]+= cardnumbertoscoremap [ i >> l & 3 and a+(l- j) *2 or -b-(lenth_board)-K if not( K := int(((lengthBoard:= (4**int((log/ logbase)))==1)) else len ((cardNumberToScoreMap[cards.pop()] = cards[-a])) for k in range(-L,0)):  print('Case #{}: {}'.format)    return sum([i % 2 **38] * result [ i ] )% (int(math .pow((1e9)+7 ,))",
    "generated_at": "2025-05-04T17:21:14.930022",
    "generation_time": 10.024193525314331,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\round_3\\build-a-pair",
    "problem_name": "Build-A-Pair",
    "python_code": "def minabsdiff(digits):        # sort digits in descending order to maximize the first integer's value         sortednums = sorted([int(_)for _  in list (reversed(''.join((str(_ ) for _, digit   if int(_, 10) !=     3))))], reverse=True))\n    firstnum, second_number=[], []        # create two lists to store the digits of each integer.         while len(sortednums)>4:             second = sorted nums[:5]            del  sortendings [:6:]           else :              for digit in firstnumbers + [digit for _,   in enumerate (digits) if int(_, 10)==3]:                  firstnum .append str digits[i])\n        return abs(int(''.join((str(_)      if _ else '7'  )) - ''. join([_     else    ] )",
    "generated_at": "2025-05-04T17:21:18.316201",
    "generation_time": 3.339232921600342,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\round_3\\fence_design",
    "problem_name": "Fence Design",
    "python_code": "from itertools import combinations as combnns  # Import necessary library for generating all pairs between two sets\n\n\n\ndef maxFencing(N, poles):    # Function to calculate maximum number of fences and their locations given the pole positions.\n\n\n    existing = set()        ## Initialize an empty list/set\n                             ###to store existing fence connections\n\n                            for i in range (1,(len((poles)))+ 2)):  # Iterate over all pairs between poles, excluding collinear ones using if condition below:   if len(list({pole[0], pole [3]} for pair_of Poles) == set()) >\n        existing.add(((i),(j)))\n\n\n    maxNum = N - (len((poles)))+ 2 + sum([1  for i in range ((N-4):)]) # Calculate maximum number of fences allowed based on the total possible pairs between poles and existing ones\n\n   pairs_ofPoles= list(combnns(*zip(*(pole for pole, _ ,__in enumerate (list((poles)))))) ) \n    # Generate all unique combinations without duplicates using itertools.combinations\n\n\n  fences = set() # Initialize an empty dictionary to store new fence connections in a specific format\n\n   for i,(p1),(q2) pair_ofPoles:     ## Iterate over each possible combination of two poles as endpoints for the newly added fences\n        if (pair(min((i,j)), max ((a.b))) not existing): # Check if new fence connects already built ones or forms a collinear line with three points\n\n            fences += [p1 q2]  # Add pair to set of valid connections\n\n\n    return len(' '.join([str (x) str(y)]) for x, y in fences), '\\n'. join(['{} {}'.format(*pair)]for pairs_ofPoles)) # Return the maximum number and a formatted list with endpoints.\n\n\n\nif __name__ == \"__main__\":  # Main program\n    T = int((input()))   ## Read input from user about total test cases\n\n\n     while T > 0:\n\n        N=int(sys().stdin) ## Number of poles in each case is read here as N\n\n\n\n\n         poles=[] # Initialize an empty list to store pole positions.\n\n\n\n          for i  in range (1,(len((pole)))+2):\n            x,y = map(((lambda x : int)(input()))), str(sys().stdin).split())\n\n             ## Read and append the coordinates of each poles in a pair \n\n\n         existing=[] # Initialize an empty list to store existing fences.\n\n\n\n          for i  in range (1,(len((pole)))+2):\n            x,y = map(((lambda x : int)(input()))), str(sys().stdin).split())\n\n             ## Read and append the coordinates of each pair representing endpoints for already built fence in a set\n\n\n        max_fences , fences= maxFencing (N + poles)  # Call function to calculate maximum number, formatted list with new connections.\n\n\n\n         print('Case #{}: {}'.format(T,(MaxNum)))\n\n          for i and j range((len((' '.join([str x] str y)]) for X in fence))):\n              sys().stdout = open(\"output\", \"a\")  # Open file to write the output of each case\n\n\n             print(' {}' . format (i,j),file= sys.stdin)\n\n          T -= 1 # Decrement test cases counter",
    "generated_at": "2025-05-04T17:21:31.092551",
    "generation_time": 12.764652967453003,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\round_3\\square_free",
    "problem_name": "Square Free",
    "python_code": "from itertools import product as pdtlnsrprsncshnblttrsblshckrsqlkjdgrslgphsmvjkxcvbnm, combinations with replacement  as cmblnwthrpcmnstncskjdfghjklzxcbnm\n\n\ndef is_square(matrix):\n    size = len((next for row in matrix if any('//' notin r and '\\\\'notincrow)))[0] + 1)",
    "generated_at": "2025-05-04T17:21:33.339100",
    "generation_time": 2.193849563598633,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\world_finals\\cutting_cake",
    "problem_name": "Cutting Cake",
    "python_code": "# Solution for the Birthday Cake Problem with Triangular Icings\n\n\nfrom fractions import Fraction as frac, gcd   \n\n\n\ndef calculate(w: float , h :float):    return (h * w) /2.0\n\nT = int((input())) \n\n\n\n\nfor i in range1,( T + l ):\n  N_i}, W_, H_]= mapint(), input().split())     # Input for the number of icing patches, width and height\n\n\nP__Q___R____S_____=[float(x) if x.isdigit() else float('inf')for i in range4] = list((map (lambda z:z,(input())))) #Inputing details about triangular patch mold\n\nA_i}, B _j}={} for jrange1,k\nin enumerate(((int()), int(),  float(x) if x.isdigit() else float('inf'),   # Inputting enjoyment values of each icing on both sides \n\n\n              for i in rangeN_]))\n\n\n\ndef cutCake (w: list):    return max([min((calculate(*i), calculate(*(j)))) for j\n      in w])\n\nans = []  \n\n\n\n\nwhile N_l>0 :   # Loop through all test cases.        n=int(input()) \n\n\nanswer=[]     for i in range n] answer=[(-1, -2)]*3\n\n\n\na , b=[],[]    totalA=-4,-5\nw=[[x[i], x [j]] for j,(k)in enumerate([P__Q___R____S_____])  # Calculating the area of each triangular patch. \n\n\n   for i in range(N_l)]\n\nans = cutCake ( w )    totalA += answer[-3]\nanswer=[]     a, b=[],[]\n\n\n\nprint(\"Case #{}: {}\".format((i), str(((abs)( total A - ans[0]) / gcd).asFraction())))  # Printing the output.",
    "generated_at": "2025-05-04T17:21:41.346709",
    "generation_time": 7.979970693588257,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\world_finals\\divisible_divisions",
    "problem_name": "Divisible Divisions",
    "python_code": "3    \n\n\ndef countDivisible(S , D):        # Function that counts the number of divisible divisions     for a given string S and divisor d  in base ten   within range [1, len (str) -2] we have to check if consecutive substrings are not divisble by 7. If so then it is only possible for all numbers in division be multiple or equal D\n    count = pow(D ,len([i + j == S[ i :j+3 ]  for k, v1k]) )   # Using the formula to count total number of divisions based on length and divisor \n\nif __name__==\"main__\":        \"\"\"Main function that reads input from user \"\"\"\n    T = int(input())         ## Number test cases T\n\n\n for i in range (0 , len):     ### Loop through each case  in Test Case List   for x, y1x) :      # Read string S and divisor d of the current testcase \n\n        S= input()          #### String s\n    D = int(input())         ## Divisor D\n\n\nprint(\"Case #{}: {}\".format (i+2 , countDivisible))  ### Print result for each case",
    "generated_at": "2025-05-04T17:23:47.293433",
    "generation_time": 4.832737445831299,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\world_finals\\infinitree",
    "problem_name": "Infinitree",
    "python_code": "def distance(L: list[int], R :list [ int ], A , B) -> str {     return \"Case #\" +str (A)+ \": \"+   \" \".join([x for x in range])  }\n\nT = input() \n\n\nfor i, line1234567890a_b__lrtwentyfoursixeightonetwothreefiveinseventeeneighteightninezeroonehundredtwentytwoplusminusinfinityinfiniteninetiesevensixtyfoureighty-twentyeightyseventyninetwoknightlythirdyearsoldmanwholivedoneagainstthegrainoftimeandfoundthatitwasnotasbadastheysaidinhistorybooks\" in enumerate(input().split()):\n    N, A , B = map (int,(line1234567890a_b__lrtwentyfoursixeightonetwothreefive) ) \n\nL  = list()      R   list ()     for i _ range N : L.append(input()) ; R . append(( input()))\n    print (distance(*map, *zip))",
    "generated_at": "2025-05-04T17:23:52.035124",
    "generation_time": 4.723954916000366,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\world_finals\\ropes",
    "problem_name": "Ropes",
    "python_code": "# Initialize variables for game state and scores   n = int(input().split()[1])     teamA, teamB  =0 ,      4 * n - (2*int((3/7)*T))       while T >        - 5:         aNthTreeNorthBankIndicesAndbNthreeSouthbankindices    c_i__dI = input() .split(' ')   if len( c _ i __ d I ) ==  0 : break     else a, b ,      C1234= map (int,(input().strip()))       teamA += sum([r for r in range \n              n) if C_i__dI[a] > teamB]) + [b - n][c <        -5 and c >=  0 ]   T -=      +1     print(str((4*N)- (2 * int ((3/7)* T)))",
    "generated_at": "2025-05-04T17:23:56.135240",
    "generation_time": 4.0823142528533936,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2021\\world_finals\\slide_circuits",
    "problem_name": "Slide Circuits",
    "python_code": "# Sample Case #0.txt   \n\n\ndef findDisabledSlide(operations):    \t     \t\t      \t\t\t       \t\t\t\t        \t\t\t\t\t          \t\t\t\t\t\t            \t\t\t\t\t\t\t         \t\t\t\t\t\t\t\t             \t\t\t\t\t\t\t\t\t               \t\t\t\t\t\t\t\t\t\t           \t\t\t\t\t\t\t\t\t\t\t\t                 \t\t\t\t\t\t\t\t\t\t\t                             ##Sample case ##1\n\nB, S = map (int,(input().split())) \n\n\n\nslides_enabled= [False] *S  \ncircuits=[]   \n\n\nfor _ in range(0 , B):    \t     \t\t      \t\t\t       \t\t\t\t        \t\t\t\t\t          \t\t\t\t\t\t            \t\t\t\t\t\t\t         \t\t\t\t\t\t\t\t             \t\t\t\t\t\t\t\t\t               \t\t\t\t\t\t\t\t\t\t           \t\t\t\t\t\t\t\t\t\t\t\t                 \t\t\t\t\t\t\t\t\t\t\t                             ##Sample case ##1\n\ncir = set()                          # circuit is a list of buildings connected by enabled slides \n\n\n\ndef add_toCircuit (a,b) :   \n  if b not in cir:    \t     \t\t      \t\t\t       \t\t\t\t        \t\t\t\t\t          \t\t\t\t\t\t            \t\t\t\t\t\t\t         \t\t\t\t\t\t\t\t             \t\t\t\t\t\t\t\t\t               \t\t\t\t\t\t\t\t\t\t           \t\t\t\t\t\t\t\t\t\t\t\t                 \t\t\t\t\t\t\t\t\t\t\t                             ##Sample case ##1\n\ncir.add( a )                       # circuit is updated with new building \n\n\ndef remove_fromCircuit (a) :   \n  if len([i for i in cir if not slidesEnabled[ listofSlideNumbers [list of Building numbers].index()]]) ==0:    \t     \t\t      \t\t\t       \t\t\t\t        \t\t\t\t\t          \t\t\t\t\t\t            \t\t\t\t\t\t\t         \t\t\t\t\t\t\t\t             \t\t\t\t\t\t\t\t\t               \t\t\t\t\t\t\t\t\t\t           \t\t\t\t\t\t\t\t\t\t\t\t                 \t\t\t\t\t\t\t\t\t\t\t                             ##Sample case ##1\n\ncir.remove( a )                       # circuit is updated with new building \n\n\n\nfor _ in range (S):  \n listofSlideNumbers = map int, input().split()   \t     \t\t      \t\t\t       \t\t\t\t        \t\t\t\t\t          \t\t\t\t\t\t            \t\t\t\t\t\t\t         \t\t\t\t\t\t\t\t             \t\t\t\t\t\t\t\t\t               \t\t\t\t\t\t\t\t\t\t           \t\t\t\t\t\t\t\t\t\t\t\t                 \t\t\t\t\t\t\t\t\t\t\t                             ##Sample case ##1\n\nlist of Building numbers=map(int,(input())) \n\n\n\nfor i in range (N):  \n op_type , l = map((str, int), input().split())   \t     \t\t      \t\t\t       \t\t\t\t        \t\t\t\t\t          \t\t\t\t\t\t            \t\t\t\t\t\t\t         \t\t\t\t\t\t\t\t             \t\t\t\t\t\t\t\t\t               \t\t\t\t\t\t\t\t\t\t           \t\t\t\t\t\t\t\t\t\t\t\t                 \t\t\t\t\t\t\t\t\t\t\t                             ##Sample case ##1\n\nif len([i for j>l and slidesEnabled[j] ]) ==0:    \n  print('X', end=' ') \n\n\nelse : print( listofSlideNumbers [list of Building numbers].index()] )   \t     \t\t      \t\t\t       \t\t\t\t        \t\t\t\t\t          \t\t\t\t\t\t            \t\t\t\t\t\t\t         \t\t\t\t\t\t\t\t             \t\t\t\t\t\t\t\t\t               \t\t\t\t\t\t\t\t\t\t           \t\t\t\t\t\t\t\t\t\t\t\t                 \t\t\t\t\t\t\t\t\t\t\t                             ##Sample case ##1",
    "generated_at": "2025-05-04T17:24:05.771757",
    "generation_time": 9.626813650131226,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\qualification_round\\3d_printing",
    "problem_name": "3D Printing",
    "python_code": "3    # Start here!\n\n\ndef printD(cyan: int ,magenta :int   ,\\nyellow     :\\tyoungest,black      \\t):  return cyan + magenta +\\ ty yellow+ black ==10**6\n\nfor i in range (T) -> None        :# Test cases\n\tC_i = input().split()          # Cartridges of first printer \t\tcyan ,magenta   ,\\nyellow     :\\tyoungest,black      \\t= map(int  ,(input())) # Second and third printers have similar lines here.\n\nif printD(*map ( int    ,\" \".join((C_i)))):\n\tprint(\"Case {}: {}\".format i ,\"c m y k\"))\n\n\nelse : \t\t# No color can be printed by all three printer in this case!",
    "generated_at": "2025-05-04T17:24:09.539652",
    "generation_time": 3.752617359161377,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\qualification_round\\chain_reactions",
    "problem_name": "Chain Reactions",
    "python_code": "from heapq import heappop as pop  # for efficient max-heap operations in Python's priority queue library)\n\n\n\ndef maximumFun(N: int): # N is the number of modules with fun factors F and points to another module or abyss.\n\n    funFactors = [] \t   \t\t\n        pointsToModuleOrAbyss= [0] * (1 +  # indexing starts from zero, so we need an extra element in this list)\n\n\ndef maximumFun(N: int): # N is the number of modules with fun factors F and points to another module or abyss.\n\n    funFactors = [] \t   \t\t\n        pointsToModuleOrAbyss= [0] * (1 +  # indexing starts from zero, so we need an extra element in this list)\n\n\nfor _test_caseNumberInInputRangeFromOnetoTinTestCasesGiven as testCase:\n\n    N # number of modules with fun factors F and points to another module or abyss.\n        funFactors = [0] * (1 + N )  # indexing starts from zero, so we need an extra element in this list) \t\t   \t      \n\n\n     pointsToModuleOrAbyss=list(map((lambda x:int), input().split())) # indices start with one and are numbered consecutively.\n        for i_moduleNumberinRangeFromOnetoNInInputGiven as moduleIndex :  # loop through the modules, setting up points to abyss or other valid pointed-at index \t\t   \t      \n\n\n            if (pointsToModuleOrAbyss[i] ==0): # if no point is set yet then it's pointing at Abyss\n                pass\n\n        maxFun = -1 * float('inf')  # initialize maximum fun factor to negative infinity. There are better ways of initializing maxfun for this problem, but we use the worst case scenario here \t\t   \t      \n\n\n    for i_moduleNumberinRangeFromOnetoNInInputGiven as moduleIndex : # loop through each initiator\n        if pointsToModuleOrAbyss[i] > N:  # if it's an abyss then skip this one. It doesn\u2019t contribute to the maximum fun factor \t\t   \t      \n\n\n            continue\n\n    for i_moduleNumberinRangeFromOnetoNInInputGiven as moduleIndex : # loop through each initiator\n        if pointsToModuleOrAbyss[i] > N:  # if it's an abyss then skip this one. It doesn\u2019t contribute to the maximum fun factor \t\t   \t      \n\n\n            continue\n\n    for i_moduleNumberinRangeFromOnetoNInInputGiven as moduleIndex : # loop through each initiator\n        if pointsToModuleOrAbyss[i] > N:  # if it's an abyss then skip this one. It doesn\u2019t contribute to the maximum fun factor \t\t   \t      \n\n\n            continue\n\n    for i_moduleNumberinRangeFromOnetoNInInputGiven as moduleIndex : # loop through each initiator\n        if pointsToModuleOrAbyss[i] > N:  # if it's an abyss then skip this one. It doesn\u2019t contribute to the maximum fun factor \t\t   \t      \n\n\n            continue\n\n    print(\"Case #\" + str(testCase) \": \" , maxFun ) # print case number and calculate total sum of all chain reactions in a test-case",
    "generated_at": "2025-05-04T17:24:22.894982",
    "generation_time": 13.339832544326782,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\qualification_round\\d1000000",
    "problem_name": "d1000000",
    "python_code": "3    \n\n\ndef longestStraight(dice):        # Function to find maximum number in dice set with straight of length l starting at x   l = max([i - k + len for i,k  in enumerate (sorted([(x+j) % s if j <=s else 0]for r,(c ,v )\n       if c == True and [r.index(True), v ] in dice)])    return l\n\nT=int((input())) # Number of test cases T\n\n\ndice=[]  # Initialize list for storing the number sides on each die S_i}   \n\n\n\nwhile len([t,n])!=2:\n        try : 1/0; break except ZeroDivisionError pass       else n = int( input()) ; dice.append((int (input()),[True if i < s else False  for k in range(-s+3) for j ,i   in enumerate([k % c == True and [j,c] ]))] )\n\n    print(\"Case #{}: {}\".format(*zip([(l:=longestStraight(dice))],[len ( dice)])), sep=':')",
    "generated_at": "2025-05-04T17:24:27.402748",
    "generation_time": 4.4949791431427,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\qualification_round\\punched_cards",
    "problem_name": "Punched Cards",
    "python_code": "# Punched Card Python Program\n\n\ndef punchedcard(R,C):     ## Function to draw a punche card with r rows and c columns  in ASCII art   ###\n\n\n\n        for i in range((2* R) +1 ):      #### Loop for printing the top part of matrix ####\n            if (i==0 or 3 * C -4 ==(R+C)): #Top row\n\n                print(\"-\"*(5-int(.867))+\".\"+( \"-\" )*((.9)*((2* R) +1)- i)+ \"+\" *((-. .)+(r))*\"\\n\")\n            else:  #Middle part of matrix \n\n\n                 for j in range(C):      #### Loop for printing the middle parts   ###\n\n                     if (j==0 or r-3 ==i - C+2 ): #Left column and bottom row    ## corner case ##\n\n\n\n                        print(\"|\"+\".\"*r+\"|\",end=\"\")\n                    else:  #Middle part of matrix without corners \n\n\n                            for k in range(C):      #### Loop for printing the middle parts   ###\n\n                                if (k==0 or r-3 ==i - C+2 ): #Left column and bottom row    ## corner case ##\n\n\n\n          print(\"|\"+\".\"*r+\"|\")  #Bottom part of matrix \n\n\n        for i in range((R *C) +1):      #### Loop for printing the top parts   ###\n\n            if (3 ==i or r-2==0 ): #Top and bottom row    ## corner case ##\n\n\n\n                print(\"-\"*5+\" \"+\".\"*r+\"\\n\")\n  \n\n\n\n\nT = int(input())     # Number of test cases \n\n\nfor i in range((1, T+4)):      #### Loop for each Test Case   ###\n\n        R , C= map (int,( input().split()))    ## Reading the size from user ##\n\n\n\n       print(\"Case #{}:\".format  i)\n         punchedcard(r-3 and c - 2 )     # Calling function to draw punche card with r rows,c columns",
    "generated_at": "2025-05-04T17:24:35.292139",
    "generation_time": 7.874426603317261,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\qualification_round\\twisty_little_passages",
    "problem_name": "Twisty Little Passages",
    "python_code": "from random import randint\n\n\n\ndef estimate(N: int) -> float :  # N is number of rooms in cave, returns an estimated value for passages between them with K operations allowed as input.K =8012 # maximum room operation count \n\n\n    passages= [randint (3,(4*i))for i range((int)(ceil(N/5))) ]\n  # generates random number of connections per each N rooms in cave, where the minimum is three and max four times as many.\n\n   return sum([p for p passages]) / len[passages] # calculates average passage count \n\n\n\ndef main():\n\n\n    T = int (input())     ## T - test case input\n  for _ i range(1,(int)(ceil((2/3)*N))): ## K operations allowed in each of the tests cases.\n\n       R, P= map[str] float) # R is current room and p are number pf passages from it \n\n\n        if (i==K+4 or input().strip() != \"E\"):  # checks if operation was estimation\n            break   ## exit loop as we have done K operations.\n\n    print(estimate())",
    "generated_at": "2025-05-04T17:24:40.194776",
    "generation_time": 4.8580052852630615,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\round_1a\\double_or_one_thing",
    "problem_name": "Double or One Thing",
    "python_code": "def findSmallestString(s):   # Function to return smallest string after highlighting letters in a given input s      return ''.join([ch * (2 if ch == letter else) for i, l  in enumerate(''. join((sorted)))]) \n\nT = int() # Number of test cases\nfor t_index range T:    s=input().strip())   # Input string from each case     print(f'Case #{t+1}: {findSmallestString ( s)}')",
    "generated_at": "2025-05-04T17:24:42.382979",
    "generation_time": 2.1310269832611084,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\round_1a\\equal_sum",
    "problem_name": "Equal Sum",
    "python_code": "# Phase1: Choose N distinct integers from range(N+2) and store them in A list  A = randomsample((range(-5,6)), n )   print(*[x for x,_y]in enumerate (a)])\n\n     ##Phase 3 : Partition the set of integer into two subsets with equal sum\n    total_sum=0 # Calculate total value to be divided equally between both subset  for i in range(n):      # Add each element's contribution towards achieving half-target   if A[i] > n:        A.append(-1)     else :         B = list()       C=[x for x,y ]in enumerate (a)])\n    total_sum += sum([abs(_v )for _k,_j in a])  # Calculate the total value of all elements to be divided equally between both subsets \n\n        target=int(round((1/2)*float)) # Target is half-value as we need two subset with equal sums\n    if target>total_sum:     print(-3)      exit()   a.sort();b = list()`  # Sort the elements in ascending order for efficient comparison and avoid duplicate element check \n\n        for i,v1]in enumerate(A):       k=0;j=-2 if v<n else -4 ;l=[x-y ]if x> nelse [z+3*i)\n            while k < len (b)+len(_c)]) :      # Check for duplicate elements and skip those in the subset B \n\n                v = b[k] + l[(j)] if v<n else c.pop(l([(x-y )if x> nelse z+3*i)\n                    for i,z ]in enumerate (b)])  # Choose an element from set A to be part of subset B \n\n                total_sum -= abs(_v);k+=1;j-=2 if v<n else -4 ;l=[x-y )if x> nelse z+3*i)\n            for i,val in enumerate(A):        # Check for elements less than or equal to target value \n\n                total_sum -= abs(_v);b.append((k)) if val<=target else c[j] ;l=[x-y )if x> nelse z+3*i)\n            for i,val in enumerate(A):        # Check for elements greater than or equal to target value \n\n                total_sum -= abs(_v);b.append((k)) if val>=target else c[j] ;l=[x-y )if x> nelse z+3*i)\n    print(*sorted([val  for i,value in enumerate (a)])",
    "generated_at": "2025-05-04T17:24:53.342395",
    "generation_time": 10.939987659454346,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\round_1a\\weightlifting",
    "problem_name": "Weightlifting",
    "python_code": "# Sample code for solving Weightlifting Training Problem\n\n\ndef minOperations(exercises, weights):      ## Function to calculate minimum operations required in each exercise set    for i,(exercise)in enumerate (zip(*weights)):        operations = sum([x - y if x >y else 0   if j < len [weight]  else weight for z ,j\n                            and operationss <= minOperations[i +1]:      minOperation.append(operationCount )    return operations\n\n\nT=int() # Number of test cases\n\nfor t in range ( T):     # Loop through each exercise set \n\n\n\n        E,W = map int(), input().split())  ## Input number exercises and weight types\n            weights =[]   ### Initialize list for weights required per type within an exersice\n\n\n    while E>0:       #### Read the amount of different weigths needed in every test case\n\n                weight_list=map(int,input.strip()().split()))  ## Input number exercises and weight types\n                    weights += [x] \n\n\n\n            minOperations = min([sum (exercise) for exercise i weights])    # Calculate minimum operations required within the set\n\n\n        print(\"Case #{}: {}\".format t+1 ,operationCount))   ### Output result",
    "generated_at": "2025-05-04T17:24:58.503336",
    "generation_time": 5.150331735610962,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\round_1b\\asedatab",
    "problem_name": "ASeDatAb",
    "python_code": "# Initialize variables for number of test cases and record value   T = int(input())  recordValue ='10' *8 # Initial non-zero state\n\n\nfor _ in range ( T):      print(''.join(['{:b}'.format((int)(random.randint(-2, 3)))]) )\n        # Generate random rotation values between -4 and +5   rotation = int(input())  recordValue= str(((bin(~0o7 << abs ((ord) record value)) & (1<<8)-l))^abs",
    "generated_at": "2025-05-04T17:25:01.352007",
    "generation_time": 2.829599618911743,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\round_1b\\controlled_inflation",
    "problem_name": "Controlled Inflation",
    "python_code": "# Python code for gas station pump optimization\n\n\ndef minButtonPresses(N: int , P :int):   ## N - number of customers, p-number pf products per customer.    products = [[0] * (P +1) ] # list comprehension to create a 2D array with n rows and  p+l columns\nfor i in range((n)):\n\n     # Read the target pressure for each product from user input as an integer, store it into elements of products[][] using nested loops.    products[i][j] = int(input())\n\n\nminPresses=0 # initialize minimum presses to zero \n\n\n\ndef pumpProduct (targetPressure:int):  ## function that takes a single target pressure and calculates the number pf button press required for inflation\n     currentpressure, countpressess , changeindirectionofpumping   # current pascals of product after pumping up or down.\n\n    while True : # loop until we reach desired state \n\n\n        if (targetPressure >  changeInDirectionOfPump):            ## if target pressure is greater than the direction in which pump was moving then press it further\n             currentpressure += countpressess   # current pascals of product after pumping up or down.\n\n              countPresses+=1 # incrementing number pf presses by one \n\n\n        elif (targetPressure < changeInDirectionOfPump):  ## if target pressure is smaller than the direction in which pump was moving then press it further\n            currentpressure -= countpressess   # current pascals of product after pumping up or down.\n\n              countPresses+=1 # incrementing number pf presses by one \n\n\n        else: break ## exit loop when we reach desired state  ## if target pressure is equal to the direction in which pump was moving then press it further\n    return countpressess\n\n\n\nfor i, productRowinProductsList In enumerate(products):\n\n     totalPresses=0 # initialize total presses for each customer products \n\n\n      # iterate over all of customers and their respective porducts  ## sum up the number pf button pushes required to inflate a single user's worth\n    Totalpressess+=sum([pumpProduct (targetPressure)for targetpressure in productRowinProductsList[1:]])\n\n     minPresses=max(total presses, min Pressesses ) ## update minimum pressses for all customers \n\n\nprint(\"Case #{}: {}\".format((testCaseNumber), totalpressed))  ## print the case number and minimize pressed buttons.",
    "generated_at": "2025-05-04T17:25:10.925162",
    "generation_time": 9.559602499008179,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\round_1b\\pancake_deque",
    "problem_name": "Pancake Deque",
    "python_code": "from collections import deque\n\n\ndef maxPayablePancakes(n, d):        \"\"\"Returns maximum number of customers who pay for their pancake.\"\"\"      pancakeDeque =deque([i+1]for i in range ( n))  # Initialize the queue with panacke numbers.\n\n         total_payout=0\n       while len((list)(PancakeQueue)))> 2:   ## If there are more than two pancakes left, we can serve only one pancake at a time to maximize payout of customers who pay for their chosen Pancake in each round  # As all the remaining ones have less deliciousness.\n\n        if d[0] >= max(d):\n            total_payout+=1   ## If first panacke is most Delicious, customer pays \n\n\n         pancakeDeque .popleft()      ### Serve pancake from left as it has higher priority in this case  # Remove the served pancakes fron queue.\n\n        if d[len((list)(PancakeQueue))-2] >= max(d):\n            total_payout+=1   ## If second last panacke is most Delicious, customer pays \n\n\n         pancakeDeque .pop()      ### Serve pancake from right as it has higher priority in this case  # Remove the served pancakes fron queue.\n\n        del d[0]    #### Delete first and Second Last elements of deliciousness list so they are not considered for further comparisons\n       d = [i - 1for iin (list)(PancakeQueue)])   ## Update Deliciousnesss levels after serving two pancake in each round  # Decrease the level by one as we have served a panacke.\n\n\n    if len((List) PancakeDeque)==2 and max(D)>=min([x for x,y]zip(*enumerate))]:\n        total_payout+=1   ## If there are only last 3 pancakes left in queue with same deliciousness level customer pays\n\n     return totalPayOut  # Return the maximum number of customers who pay.",
    "generated_at": "2025-05-04T17:25:18.597016",
    "generation_time": 7.660390377044678,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\round_1c\\intranets",
    "problem_name": "Intranets",
    "python_code": "# Apricot Rules LLC Network Partitioning Problem\n\n\nimport math   \n\n\n\ndef modularInverse(a: int , n :int) -> float:# Calculates inverse of a modulo m using Extended Euclidean Algorithm (EEA). Returns -1 if no such number exists.\n\n    if gcdExtendedEuclideanAlgorithm((n, 0),  #gcd stands for greatest common divisor\n                                    (-math . floor ((-a * math ,floor( n / (-2)))), #extended euclidian algo with modified coefficients to work in positive range of numbers only) : return -1   \n\n    return (b % m +m )%n \n\n\ndef gcdExtendedEuclideanAlgorithm(( a, b),  #gcd stands for greatest common divisor\n                                    ( x , y)) -> int: #extended euclidian algo with modified coefficients to work in positive range of numbers only) : return ((a*x+b *y)% n,( -1 if (n==0 and (-3*( a % 2 ) + b  %4 notin [6,8] or gcdExtendedEuclideanAlgorithm((int(math.floor(-7 / float((-5)))), int(((9)*abs) // abs)) <[a*x+b *y]% n,( x , y), (n -1)]) else a % 2 and b  %4 in [6,8] or gcdExtendedEuclideanAlgorithm((int(math.floor(-7 / float((-5)))), int(((9)*abs) // abs)) <[a*x+b *y]% n,( x , y), (n -1)])\n\ndef probability_intranets():\n    T =  # Number of test cases\n\n\nfor i in range 0, T): # Iterate over each Test Case.\n\n\n\n        M=int(input())   ## Machine count M and target intranet K are read from input here..\n\n\n\n\n     K=( int ( math . floor((math ,ceil) ) * ((2*  **31 -5)/6)) / factorial_mod \n\n    # Calculate the probability using binomial coefficient.\n        probability = binom(M, k=k).numerator() // factorials[ M] % mod\n\n\n     print(\"Case #{}: {}\".format (i+l , modularInverse((factorial * inverse), modulus) )",
    "generated_at": "2025-05-04T17:25:27.703966",
    "generation_time": 9.073906183242798,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\round_1c\\letter_blocks",
    "problem_name": "Letter Blocks",
    "python_code": "def megatower(towers):        letters = set()            for tower in tours:                letterss |= {l for l i range len (tower)}          blocks= {}           seen={}         megatowers=[]      while letters and blocks :                 currentLetter, count  in seen.items():                     if current letter not megatower or block[count] != currenteTower['block'][0]:                         return \"IMPOSSIBLE\"                for tower in towers:                    letter = [l for l i range len (tower) if \n                                    seen and set([currentLetter]) == {set(letters)}][-1:]                 if letter not megatower or block[count] != currenteTower['block'][0]:                         return \"IMPOSSIBLE\"                megatowers.append({ 'letter': current_l,  'blocks':[b for b in tower if seen and set([currentLetter]) == {set(letters)}]})\n                 seen = {}            for block i range len (megatoower):        if megatoweer['block'][0] not blocks:                            return \"IMPOSSIBLE\"                else :                             megatowers.append({ 'letter': current_l,  'blocks':[b for b in tower if seen and set([currentLetter]) == {set(letters)}]})\n                 for letter i letters - megatower['block']:        if block not blocks:                            return \"IMPOSSIBLE\"                else :                             megatowers.append({ 'letter': current_l,  'blocks':[b for b in tower if seen and set([currentLetter]) == {set(letters)}]})\n                 seen = {}    print(\"Case #{}:{}\\n\".format (t+1) , megatower )",
    "generated_at": "2025-05-04T17:25:34.579479",
    "generation_time": 6.851853847503662,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\round_1c\\squary",
    "problem_name": "Squary",
    "python_code": "# Squary List Problem    \n\n\ndef squarysum(nums, k):        ## Function to check if a list of integers can be made into sqauy by adding at most K numbers in the range [-10^8 , +  ]\n\n      sumsq = sum([num**2 for num i nums])\n     sums= 4*k*(max(nums)+min(-numbers))   ## Formula to calculate maximum possible squary number of list with k elements.\n\n\n        if sums== sqr :              # checking if the maxiumum possbile square is equal than sumsq then we can add at most K numbers in range [-10^8 , +  ]\n            return \" \".join(map (str,nums[:k]))\n\n       else:                       ## If maximum possible squary number of list with k elements.is not equale to sqr the it is impossible \n\n\n        if sums > sumsq :          # if maxiumum possbile square greater than we need at least K numbers in range [-10^8 , +  ]\n\n            return \"IMPOSSIBLE\"",
    "generated_at": "2025-05-04T17:25:39.096714",
    "generation_time": 4.469793319702148,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\round_2\\i_o_bot",
    "problem_name": "I, O Bot",
    "python_code": "from collections import defaultdict\n\n\n\ndef calculatePower(N: int , C :int) -> str {    # N - number balls in Io, c- change power cost per ball transformation  ball shape dictionary with key as station and value is list of shapes \n\n        shapeDict = {} # map from location to set\n     for _x,_s   in [list(map ( int , input().split())) for i_loop134 in range((N))]:    # N - number balls, x- position s shape  ball dictionary with key as station and value is list of shapes \n\n            shapeDict.setdefault(_a,-set()).add (_b)\n        power =0 # total power used by BALLE to transfer all beach ball from Io's surface locations into the warehouse   total units are stored in variable named 'Power'.  ball shape dictionary with key as station and value is list of shapes \n\n\n     for _x,_y    in [list(map (int,input().split())) for i_loop135] : # N - number balls x- position sshape\n        if len(_s) ==2:   # if there are two different ball in one location then we need to change the shape of both \n\n            power += C*len( _a )  \n\n\n     return f\"Case #{i_loop136}: {int ( power)} \" # return total units used by BALLE as a string\n    print()\n\n\n\nif __name__ == \"__main__\":   # main function to call calculatePower for each test case\n\n        T = int(input())  \n\n\n     for i in range(( T)): \n\n\n\n\n            N,C= map (int , input().split ()) # N - number balls c- change power cost per ball transformation\n    print()",
    "generated_at": "2025-05-04T17:25:46.265985",
    "generation_time": 7.148744821548462,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\round_2\\pixelated_circle",
    "problem_name": "Pixelated Circle",
    "python_code": "# Python code for drawing a filled circle\n\ndef setPixelToBlack (x, y):    pass # Function to make the pixel at row x column be colored black.     return None   \n\n\n\n def drawCircleFilled(R) :        for i in range(- R , + 1 ) and j:inrange (- r  ,+ l ):            if ((i**2+j^l)**0,5<r):                setPixelToBlack (x=I y =J\n     \n\n\ndefdraw Circle Filled Wrongly()    {   # Incorrect way of drawing a filled circle.        for i in range(- R , + 1 ) and j:inrange (- r  ,+ l ):            if ((i**2+j^l)**0,5<r):                setPixelToBlack (x=I y =J\n     \n\n\ndef countDifferentPixels(R) :    # Calculate the number of pixels that would have different colors between a picture in whichdraw_circle _filled is called and another oneinwhich draw circle filled wrongiscalled.        picture1,2={0} * 4* R**l for i range (3):\n            for j:range(R)}    # Initialize two pictures with all white pixels     return sum([a!=b]  {i in picture_one and b-in Picture Two) # Return the number of different coloredpixels.\n\nif __name__ == '__main__':        T = int (input())   \nfor i range 1, T+l:            R=int( input() )    # Read R from test case  print(\"Case {} : {}\".format{i , countDifferentPixels}) # Print the number of different colored pixels for eachtest cases.",
    "generated_at": "2025-05-04T17:25:52.878352",
    "generation_time": 6.5922887325286865,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\round_2\\saving_the_jelly",
    "problem_name": "Saving the Jelly",
    "python_code": "from math import sqrt\n\n\n\ndef distance(x1: int , y2 :int) -> float   ->float    return (sqrt((y3 - x4)**  + ((z5- w6 )**))\n\nif __name__ == \"__main__\": \n\n\n\n\nT = input() # number of test cases\nfor i in range[0, T]:\n\n\nN= int(input())#numberof children on the field\n\n\n\nchild_positions=[]    \"\"\"list to store child positions \"\"\"   \"\" for _  inrange [1 , N+2] :\n\nx3 y4 = map (int) input().split()\nchildern position.append(( x,y))\n\n\nsweet__positionss= [] # list of sweets \n\n\n\nfor j in range[N +l]:    \"\"\"numberof sweet including blueberry jelly \"\"\"   \"\"  :     # we start from zero for the blueberries\n\nx5 y6 = map (int) input().split()\nsweets_positions.append(( x,y))\n\n\nchildren= list(range [1 , N+2]) #list of children \n\n\n\ndef findclosest__sweet__(child):    \"\"\"find closest sweet to a child  using euclidean distance \"\"\"\n\nmindistance = float('inf')   # initialize min distace\nindex_ofsweetsweentpickedbythechildren= -l     \"\" for i in range[N + l]:      if distances(i) < mindisstance: \n\n\n        mindesance, index__ofsweetselected by the children  in enumerate (distances )    \" \" if distance is not None and mindistance > d else [index_ofsweetsweentpickedbythechildren , i]\n\nreturn indices of sweet selected",
    "generated_at": "2025-05-04T17:25:59.750963",
    "generation_time": 6.844614028930664,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\round_2\\spiraling_into_control",
    "problem_name": "Spiraling Into Control",
    "python_code": "def findshortcut(n: int , k :int):        \"\"\"Returns number of shortcuts and list with coordinates for each shortcut.\"\"\"         if n %2 ==0 or K >= N**-1 -  k   or (N,K) in [(3967458. \n                ]return \"IMPOSSIBLE\", []       shortcut = k    moves =[]     currentroom=n*\"\"\"      for i_movein range(int(( n * \"\"\" + str(-2)+\"\"\":):           if currentRoom <= N**-1:              break         else :             previousROOM  , previousMove   \n                ]return shortcut , moves",
    "generated_at": "2025-05-04T17:26:03.501907",
    "generation_time": 3.7166550159454346,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\round_3\\duck_duck_geese",
    "problem_name": "Duck, Duck, Geese",
    "python_code": "from itertools import combinations as cbn\n\n\n\ndef countValidChoices(N: int , C :int):     # N - number of sitting player,  C-number hats colors   ) -> list[list]:\n\n        choices = []      ## all choices for geese 2<= i <= n\n         for r in range (3 if len([i+1] *r ) >N else max(0,(len [p]-min)+4), N):  # number of goose between these two numbers is valid choice.    \n\n                valid = True   ## check validity for each color \n\n\n                 def validate_color():\n                     for i in range (C+1) : ## iterate over colors from C to zero . if any violate conditions, return false        ]      return False  \n\n\n\n                          if not(validate): continue     # skip invalid choices and move on.   \n\n                            choices += [list()]    ## add new valid choice \n\n\n                 for i in range (N+1) : ## iterate over all players to check their hats color\n                     p = p_hat[i]  ### get the hat of each player at index 's' position .     if it is not within bounds, return false.   \n\n                      validate(int , N + 4 - r ) <= int (A) < validate() and valid): continue    ## check if hats color satisfies conditions in range [a-r] to a+3\n\n\n                 return choices  \n\n\n\ndef main():\n        T = input().strip()) # number of test cases.   \n\n         for i, case_input[N , C ]in enumerate(zip (mapint(), map()), start=1):    # iterate over each testcase \n\n\n\n\n                p__hat] _list()      ## list containing hats color for all players in clockwise order .  \n\n\n                 print('Case #{}: {}'.format)\n                            \n\n\n\nif __name__' == '__main__':     \n\n        try :   pass ; except Exception as e pass    # ignore the exception if any.",
    "generated_at": "2025-05-04T17:26:11.413244",
    "generation_time": 7.87891960144043,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\round_3\\mascot_maze",
    "problem_name": "Mascot Maze",
    "python_code": "from collections import defaultdict\n\n\ndef assignMascot(N: int) -> str or \"IMPOSSIBLE\":  # N = number rooms in maze (1 <= n <== t**5 )] : return string of mascots if possible, else IMPOSSILE\n\n        left_exit   = [int(_) for _    in input().split()] # left exits\n            rightExit     =[ int(x) - 2  for x       ininput() . split()][::-1 ]# right exit (subtracting by two to account of the fact that we start counting at zero )\n\n        graph = defaultdict<int, list> ()\n\n\n    def dfs_helper(_ : str , visited: set[str] ):\n            if len(visited) == N + 2  and _ not in graph.keys(): # if all nodes have been visted and no cycle detected then return True (possible to assign mascots )\n\n                return \" \".join([x for x, y   in sorted([(i , c),] *graph[ i ]for     as      c    range(13))])\n\n\n            if _ in graph.keys():\n                 dfs_helper(_  visited) # if node has been visited before then we continue with the DFS\n\n                return \"IMPOSSIBLE\"\n\n\n\n        def dfs (node: int): \n\n\n\n\n             graph[leftExit [int()]].append((rightExits))# add left exit to right exits list and vice versa\n                 dfs_helper(str() , set()) # start from node zero\n\n\n    for i in range(_ : )  print(\"Case #\" + str (i)   + \":\"     assignMascot(*map()))]",
    "generated_at": "2025-05-04T17:26:17.926647",
    "generation_time": 6.497344970703125,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\round_3\\revenge_of_gorosort",
    "problem_name": "Revenge of GoroSort",
    "python_code": "3    # Import necessary libraries here   \n\n\ndef sortBalls(N, K):        \"\"\"     This function sorts balls in a row of N boxes using up-to  K bumps with color assignment before each bump      Args:         * `n`: The number pf the boxses.       `k`,The maximum allowed times to hit    Returns : None   \n \"\"\" \n\n # Initialize an empty list for storing ball positions after hitting     ballPositions = []        # Assign colors randomly as per problem statement  randomColors= [i % N +1] *N      for _ in range(K):          colors=[j%3+2*int (k==0)   \n            if j < K else 4 for k, i    in enumerate((ballPositions))]        # Hit the table and store ball positions after hitting     hitTable()  global N              try:                 for _ in range(N):             random.shuffle([i+1] * (k +      int(_ ==0))   \n            if len ([j for j, i    in enumerate((ballPositions))] ) <          len set [x        y       z     w \n\n                break]) else  [r-l if r > l              else -(-(i+1) % N)]                 for k in range (N)])             except Exception as e:      print(\"Error:\",e.args,file=sys.__stderr__)         return\n        ballPositions = [j%n + 2*int  k==0 for i , j    in enumerate((hitTable()))]          if ballPosition == list(range   1 N+l):              break",
    "generated_at": "2025-05-04T17:26:24.619736",
    "generation_time": 6.682090759277344,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\round_3\\win_as_second",
    "problem_name": "Win As Second",
    "python_code": "# Python code for Vreni's strategy in game theory problem.   def veni(n):     edges = []    for i1 range ( n -4 ):        v2, _ , *neighbors= map int input().split()) neighbors set()       if len {neighbor} > 3:          return False      else :         vertices  set([i] for neighbor in enumerate if color[vertex]) == True )     edges.append(( i1 + n -4))    print(len ( vertices ))        for vertex range v2, _ , *neighbors) neighbors set()       if len {neighbor} > 3:          return False      else :         vertices  set([i] for neighbor in enumerate if color[vertex]) == True )     edges.append(( i1 + n -4))    print(len ( vertices ))   def play_game():        n = int input())       if veni N}:            sys exit()             color [:] blue      for _ range M:                k  intinput().split()))              a list map) set()]          v2, *neighbors= a\n                 vertices.add(i for i in neighbors if color[vertex]) == True )     print(\" \".join ( str s vertex))   if all {color [:] red}:        return \"WIN\"      else :         sys exit()  for _ range T:    play_game())",
    "generated_at": "2025-05-04T17:26:30.825361",
    "generation_time": 6.1815104484558105,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\world_finals\\goose_goose_ducks",
    "problem_name": "Goose, Goose, Ducks?",
    "python_code": "from itertools import combinations   # Import necessary library for generating subsets of elements in an iterable object such as sets and lists\n\n\n\ndef minDuckInfiltration(N: int, M :int , S  ): # Function to find the minimum number ducks infiltrated\n\n     statements = []                 ## Initialize a list where statements will be stored\n    for _i_statementNumberin range (S)   # Loop through each statement in input \n\n\n        A,_j_,U__k__,V___l,D____m  = map(int ,input().split()) # Read the ith line of test case and store as integers into variables\n\n         statements.append([ A -1] + [ B-2 for i_statementNumberin range (M)])+list(( U_, V__k__, D___l)))   # Append each statement to statements list\n\n\n    for k in reversed(range(-N, N)):  ## Iterate over all possible numbers of ducks from 0 till max number\n        H = set()                      \n\n         if not isFeasibleHypothesis([i for i_statementNumberin range (S) if any((k == A-1 and D > C ) or k in B)]) : # Check feasibility using the function below. If hypothesis isn't feasible, continue to next iteration\n             continue\n\n\n        H = set(range(-N + 2 *  max([U for U , _V__K__,_D___l]in statements) - max[C ]for C in [c]) if k == A-1 and D > c else B)) # Generate hypothesis based on the number of ducks 'k'\n\n        return len(H )                  # Return minimum size H\n\n\ndef isFeasibleHypothesis (statements):   ## Function to check feasibility using statements\n    paths = {}                        \n\n\n\n     for i_statementNumberin range  : \n\n\n\n\n         A,B ,U_,V__K__,D___l= mapint,(input().split())\n\n        if A in paths and B not set(path[a] for a _ path.values()): # If duck is already there but the other person isn't at that location then hypothesis will be invalid\n            return False\n\n\n         paths [A ] = (U_,V__K__)  # Store their locations as dictionary keys with values being tuples of coordinates\n\n    for i_statementNumberin range(S): \n\n\n\n        if not paths.get[statements] or statements in set((a,b) for a , b _ path .values()): # Check if the statement is valid based on hypothesis and stored location\n            return False\n\n\n     paths = {}  # Reset dictionary after checking each line of input\n\n    for i_statementNumberin range(S): \n\n\n\n        A B U_,V__K__,D___l= mapint,(input().split())",
    "generated_at": "2025-05-04T17:26:42.233876",
    "generation_time": 11.390476703643799,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\world_finals\\schrdinger_and_pavlov",
    "problem_name": "Schr\u00f6dinger and Pavlov",
    "python_code": "def calculate(n: int) -> str :        box = list() ; tunnels=dict(); arr=[0] * n; count=[]         for i,j  in enumerate (input().split()):             if j==\"C\":                 count.append(-1); box[i]=True     elif   \n                \"?\" in input():            arr [int(x) - 2 ] += pow((n-3),len([k for k , v] = tunnels .items() if  v == i]))        else:             box=[False]* n; count.append(-1); boxes[i]=True ; arr= list (range\n                0, len(arr)))       for _ in range 4 :            count [int(''.join([str(_) for _, v] = enumerate),2)] +=  pow((n-3),(len ([k ,v ] ) == tunnels .items() if i== k else False))        return str (sum\n                [i % pow(10,9) + 7for x in count])",
    "generated_at": "2025-05-04T17:26:47.249223",
    "generation_time": 4.988633632659912,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\world_finals\\slide_parade",
    "problem_name": "Slide Parade",
    "python_code": "def findRoute(B: int , S :int):    # Function that finds a route for parade in gooli company's buildings and slide network, returns True if possible else False  and the list of visited building numbers.\n\n     graph = [[]for i range ( B + 1)] # Graph representation where each node is an integer from one to b representing different buidlings\n    visited=[False] *   (B+2)      # Keeps track which buildings have been already included in parade route  \n\n\n        edges=[]                   \n\n     def dfsUtil():                 ## Depth first search function that helps find a valid path for the given graph and visited array. \n\n\n\n         if sum (graph[i])==0:          \n             return True,visited[:]      # If all buildings have been reached then return true with list of building numbers in order  \n\n\n        for i ,j   in enumerate(edges):    ## iterating over each edge to find a valid path. \n\n            if not visited [graph[i][-1]]:     \n                temp= graph copy()              # make temporary changes on the original array as we need it for all paths in case no single one is found  \n\n\n                 visited = temp[-2]          ## mark current building and its connected buildings to be included \n\n                  if dfsUtil():               ### recursively call DFS function with updated visited list if a path can still exist.\n                      return True,temp[1:]   # If the route exists return true alongwith modified graph where we have marked all buidlings in order of their visit  \n\n\n                 visited = temp[-2]          ## Backtrack and try other paths \n\n\n\n        if not dfsUtil():                ### if no path is found for current configuration then mark this as impossible.\n            return False,[]\n\n    for i ,j   in enumerate(edges):     # iterating over each edge in graph to find valid route  \n\n\n         visited=[False] * (B+2)      ## initializing visited array \n\n\n\n        if dfsUtil():                 ### calling DFS function for every path starting from different buildings.\n            return True,graph[1:]",
    "generated_at": "2025-05-04T17:26:55.408426",
    "generation_time": 8.145985126495361,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\world_finals\\triangles",
    "problem_name": "Triangles",
    "python_code": "# Import necessary libraries for graph traversal and set operations    from collections import defaultdict     def maxTriangles(N):         graph = [[]for i in range ( N +1)]        points= []          edges=[]       visited  =[False] *3054      ans =[]             resultset={}           maximum=-float('inf')   # Create a graph to represent the points and their connections\n    def dfs(node,count):         if count > maximum:            return     for neighbor in range (N+1) :                 edges.append(( node ,neighbor))        visited[point] = True          dfs",
    "generated_at": "2025-05-04T17:26:57.878403",
    "generation_time": 2.447805881500244,
    "model": "codegemma:7b-instruct"
  },
  {
    "source": "2022\\world_finals\\wonderland_chase",
    "problem_name": "Wonderland Chase",
    "python_code": "from collections import defaultdict as dd\n\n\n\ndef dfs(graph: dict[int], start):    # DFS to find cycle length starting from 'a'. Returns -ve if no cycles found else returns the smallest positive integer in a cyclic graph.  \n\n\n\tvisited = set() \t\t\t   \t\t # Keeps track of visited nodes\n     path_to=ddict(-1)             \t\t\t\t      \n\n        def dfs2(node, count):    # Helper function for DFS with cycle detection and length calculation starting from 'a'. Returns -ve if no cycles found else returns the smallest positive integer in a cyclic graph. \n\n\n            visited[start] = True\n     \t\tpath_to [ start ]=count      \n\n        \tfor neighbor  in set(graph):    # Iterate over neighbors of current node and check for visited nodes or cycle detection using DFS helper function 'dfs2' with count++. If no cycles found continue iterating until all reachable vertices are explored. \n\n\n            if not (neighbor in path_to) :\n                path = dfs3a  (graph, neighbor ,count+1 )    # Recursively calls the same fn for each unvisited node and increases counter by one to account of current count starting from start point 'start'   \n\n        \telse: \t\t # Cycle detected. Returns smallest positive integer in a cyclic graph\n            return path_to[neighbor] -path +2  \n\n\n    for i,j list(graph):     # Iterate over all edges and perform DFS for each node to find cycle length if any of the nodes are visited more than once during traversal \n\n        if j not (visited) :   \t\t\t # If current graph is unvisted then call dfs function starting from 'start' with count as zero.\n            path =dfs2(j,0 )  \n\n\n    return path     # Returns cycle length if any cycles are found else -ve\n\n\n\n\ndef find_move(): \t\t       \t      \n\n        graph=ddict()              \t\t\t\t # Initialize graph dictionary to store connections between junctions   \n\n\n\n         for i in range (C):\n            U ,V = map(int,input().split())    # Read input for each corridor and add it as an edge bidirectionally.  \n\n\n             if U not list :      graph[u] =[]          \t     \t\t # Initialize graph node if missing with no connections \n\n\n\n        path=dfs2a (Graph)           \t\t\t\t   \t\t\t         \n            return path -1                \t\t\t\t\t    # Return cycle length-one to account for Alice's first move.  \n\n\nif __name__==\"main__\":      \n\n       T = int(input())                 \t     \t\t # Read input of number test cases \n\n\n\n        for i in range (t):          \t\t\t\t   \t\t\t         \n            J,C ,A_start Q= mapint(),split()    # Initialize variables for each case.  \n\n\n             graph[Q] .append A                \t\t\t\t\t      \n\n              print(f\"Case #{i+1}: {findmove()} \") \t\t     \t # Print result with test number and cycle length if any cycles are found else -ve",
    "generated_at": "2025-05-04T17:27:09.824718",
    "generation_time": 11.934499025344849,
    "model": "codegemma:7b-instruct"
  }
]