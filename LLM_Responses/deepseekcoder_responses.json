[
  {
    "source": "2016\\qualification_round\\coin_jam",
    "problem_name": "Coin Jam",
    "python_code": "from sympy import *\nimport random\n\ndef generate_jamcoin(n):\n    return bin(random.randint(2**(n-1) + 1, 2**n - 1))[2:]\n\ndef find_divisor(s):\n    for i in range(2, int(sqrt(int(s, 2)))+1):\n        if int(s, 2) % i == 0:\n            return i\n    return None\n\ndef generate_jamcoins(n, j):\n    jamcoins = []\n    while len(jamcoins) < j:\n        s = generate_jamcoin(n)\n        divisors = [find_divisor(s[i-1:] + '0') for i in range(1, n+1)]\n        if all(d is not None for d in divisors):\n            jamcoins.append((s, divisors))\n    return jamcoins\n\ndef main():\n    t = 1  # number of test cases\n    for case_no in range(1, t + 1):\n        n, j = map(int, input().split())\n        print('Case #{}:'.format(case_no))\n        for jamcoin, divisors in generate_jamcoins(n, j):\n            print(jamcoin + ' ' + ' '.join(map(str, divisors)))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:06:49.198477",
    "generation_time": 8.206737995147705,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\qualification_round\\counting_sheep",
    "problem_name": "Counting Sheep",
    "python_code": "def count_sheep(N):\n    if N == 0:\n        return \"INSOMNIA\"\n    \n    digits = set()\n    i = 1\n    while len(digits) < 10:\n        number = i * N\n        digits.update(str(number))\n        i += 1\n        \n    return (i-1) * N\n\nT = int(input())\nfor t in range(1, T+1):\n    N = int(input())\n    print(\"Case #{}: {}\".format(t, count_sheep(N)))",
    "generated_at": "2025-05-03T17:06:51.350747",
    "generation_time": 2.141446352005005,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\qualification_round\\fractiles",
    "problem_name": "Fractiles",
    "python_code": "def solve(K, C, S):\n    if K * (C - 1) < S:\n        return \"IMPOSSIBLE\"\n    else:\n        return [i for i in range(2, S + 1)] + [1]\n\nT = int(input())\nfor tc in range(1, T + 1):\n    K, C, S = map(int, input().split())\n    result = solve(K, C, S)\n    print(\"Case #{}: {}\".format(tc, \" \".join(map(str, result)) if type(result) == list else result))",
    "generated_at": "2025-05-03T17:06:55.148460",
    "generation_time": 3.7916133403778076,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\qualification_round\\revenge_of_the_pancakes",
    "problem_name": "Revenge of the Pancakes",
    "python_code": "def min_flips(s):\n    flips = 0\n    for i in range(len(s)):\n        if s[i] == '-':\n            flips += 1\n            for j in range(i+1, len(s)):\n                if s[j] == '+':\n                    break\n                else:\n                    s[j] = '+' if s[j] == '-' else '-'\n    return flips\n\nT = int(input())\nfor t in range(1, T + 1):\n    s = list(input().strip())\n    print('Case #{}: {}'.format(t, min_flips(s)))",
    "generated_at": "2025-05-03T17:06:57.757077",
    "generation_time": 2.604067087173462,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\round_1a\\bffs",
    "problem_name": "BFFs",
    "python_code": "Here's the Python code that solves this problem using the concept of graph theory and depth-first search (DFS):\n\n\ndef dfs(v, color, adj_list):\n    if color[v] != 0: return 1 if color[v] == 2 else 0\n    color[v] = 2\n    for u in adj_list[v]:\n        if not dfs(u, color, adj_list): return False\n    color[v] = 1\n    return True\n\ndef solve():\n    N = int(input())\n    F = list(map(int, input().split()))\n    F.insert(0, 0)\n    adj_list = [[] for _ in range(N+1)]\n    for i in range(1, N+1): adj_list[F[i]].append(i)\n    color = [0] * (N + 1)\n    res = 0\n    for v in range(1, N+1): \n        if dfs(v, color, adj_list): res += 1\n    return res\n\nT = int(input())\nfor tc in range(1, T+1): print(\"Case #{}: {}\".format(tc, solve()))\n\nThis code first reads the input and constructs an adjacency list representation of the directed graph. Then it performs a depth-first search on each node that has not been visited yet to find cycles in the graph (which means some kids cannot be in the circle). The number of nodes that have no cycle is the answer to this problem.",
    "generated_at": "2025-05-03T17:07:02.539027",
    "generation_time": 4.777524471282959,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\round_1a\\rank_and_file",
    "problem_name": "Rank and File",
    "python_code": "def find_missing(n, lists):\n    row = sorted([i for i in range(1, n+1)])\n    col = []\n    \n    # Find the missing column\n    for lst in lists:\n        if len(lst) != n-1:\n            return \"Error: Invalid input\"\n        elif set(lst).issubset(col):  # If all elements of this list are already in col, skip it\n            continue\n        else:\n            for i in range(n-1):  \n                if lst[i] != row[i]:  # Find the missing element from the row\n                    col = lst[:i] + [lst[i]] + lst[i:]  # Insert this missing element into the column list\n                    break\n    return \"Case #{}: {}\".format(n, ' '.join(map(str,col)))\n\nT = int(input().strip())\nfor t in range(1, T+1):\n    N = int(input().strip())\n    lists = []\n    for _ in range(2*N-1):\n        lst = list(map(int, input().strip().split()))\n        lists.append(lst)\n    print(find_missing(t, lists))",
    "generated_at": "2025-05-03T17:07:06.701559",
    "generation_time": 4.157445669174194,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\round_1a\\the_last_word",
    "problem_name": "The Last Word",
    "python_code": "def last_word(s):\n    s = sorted(list(s))\n    for i in range(len(s)-1, -1, -1):\n        if i == 0 or (i > 0 and s[i-1] != s[i]):\n            return ''.join(s[:i+1])\n    return ''\n\nt = int(input())\nfor case in range(1, t + 1):\n    s = input()\n    print('Case #{}: {}'.format(case, last_word(s)))",
    "generated_at": "2025-05-03T17:07:08.580280",
    "generation_time": 1.8527917861938477,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\round_1b\\close_match",
    "problem_name": "Close Match",
    "python_code": "def solve(c, j):\n    c = list(c)\n    j = list(j)\n    \n    for i in range(len(c)):\n        if c[i] == '?' and j[i] != '?':\n            c[i] = str((int(j[i]) + 10 - int(c[i-1])) % 10)\n        elif j[i] == '?' and c[i] != '?':\n            j[i] = str((int(c[i]) + 10 - int(j[i-1])) % 10)\n    \n    for i in range(len(c)-1, -1, -1):\n        if c[i] == '?' and j[i] != '?':\n            c[i] = str((int(j[i]) + 10 - int(c[(i+1)%len(c)])) % 10)\n        elif j[i] == '?' and c[i] != '?':\n            j[i] = str((int(c[i]) + 10 - int(j[(i+1)%len(j)])) % 10)\n    \n    return \"\".join(c), \"\".join(j)\n\nT = int(input())\nfor t in range(T):\n    C, J = input().split()\n    c, j = solve(C, J)\n    print(\"Case #{}: {}, {}\".format(t+1, c, j))",
    "generated_at": "2025-05-03T17:07:13.543028",
    "generation_time": 4.958419322967529,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\round_1b\\getting_the_digits",
    "problem_name": "Getting the Digits",
    "python_code": "def decode_phone_number(s):\n    mapping = {'ZERO': '0', 'ONE': '1', 'TWO': '2', 'THREE': '3', 'FOUR': '4',\n               'FIVE': '5', 'SIX': '6', 'SEVEN': '7', 'EIGHT': '8', 'NINE': '9'}\n    count_mapping = {'ZERO': 0, 'ONE': 0, 'TWO': 0, 'THREE': 0, 'FOUR': 0,\n                     'FIVE': 0, 'SIX': 0, 'SEVEN': 0, 'EIGHT': 0, 'NINE': 0}\n    for word in ['ZERO', 'ONE', 'TWO', 'THREE', 'FOUR', 'FIVE', 'SIX', 'SEVEN', 'EIGHT', 'NINE']:\n        while word in s:\n            count_mapping[word] += 1\n            s = s.replace(word, '', 1)\n    return ''.join([count_mapping[key] * mapping[key] for key in count_mapping])\n\nt = int(input().strip())\nfor i in range(t):\n    s = input().strip()\n    print('Case #{}: {}'.format(i + 1, decode_phone_number(s)))",
    "generated_at": "2025-05-03T17:07:17.863974",
    "generation_time": 4.3147804737091064,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\round_1b\\technobabble",
    "problem_name": "Technobabble",
    "python_code": "def max_fakes(topics):\n    words = set()\n    real_topics = set()\n    fake_topics = set()\n    \n    for t in topics:\n        w1, w2 = t.split(' ')\n        if (w1 + ' ' + w2) not in fake_topics and (w2 + ' ' + w1) not in fake_topics:\n            real_topics.add(t)\n        else:\n            fake_topics.add((w1, w2))\n        words.add(w1)\n        words.add(w2)\n    \n    for f in fake_topics:\n        if f[0] not in words or f[1] not in words:\n            continue\n        else:\n            real_topics.add(' '.join(f))\n            \n    return len(fake_topics - set([t for t in fake_topics if (t[1], t[0]) in fake_topics]))\n\nT = int(input())\nfor case in range(1, T + 1):\n    N = int(input())\n    topics = [input() for _ in range(N)]\n    print('Case #{}: {}'.format(case, max_fakes(topics)))",
    "generated_at": "2025-05-03T17:07:22.195328",
    "generation_time": 4.326898813247681,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\round_1c\\fashion_police",
    "problem_name": "Fashion Police",
    "python_code": "def fashion_jail(J, P, S, K):\n    # Initialize the number of days and the list of outfits\n    num_days = 0\n    outfits = []\n    \n    # For each possible combination of jacket-pants-shirt\n    for j in range(1, J+1):\n        for p in range(j, P+1):\n            for s in range(1, S+1):\n                # Check if the number of combinations is less than K\n                num_outfits = (J - j + 1) * (P - p + 1) * (S - s + 1)\n                if num_outfits < K:\n                    # Add the outfit to the list and increment the number of days\n                    outfits.append((j, p, s))\n                    num_days += 1\n    \n    return num_days, outfits\n\nT = int(input())\nfor t in range(1, T+1):\n    J, P, S, K = map(int, input().split())\n    num_days, outfits = fashion_jail(J, P, S, K)\n    \n    print(\"Case #{}: {}\".format(t, num_days))\n    for outfit in outfits:\n        print(*outfit)",
    "generated_at": "2025-05-03T17:07:26.741583",
    "generation_time": 4.537470817565918,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\round_1c\\senate_evacuation",
    "problem_name": "Senate Evacuation",
    "python_code": "def predict_party(senators):\n    senate = []\n    for i, num in enumerate(senators):\n        party = chr(i + 65)  # Convert to party name (A, B, etc.)\n        senate.extend([party]*num)\n        \n    while True:\n        i = 0\n        j = len(senate) // 2\n        if j == 0:\n            break\n        while j < len(senate):\n            if senate[i] != senate[j]:\n                del senate[i:j+1]\n                break\n            i += 1\n            j += 1\n        else:\n            return ''  # No valid evacuation plan exists\n    return ' '.join(senate)\n\nT = int(input().strip())\nfor t in range(T):\n    N = int(input().strip())\n    senators = list(map(int, input().split()))\n    print(\"Case #{}: {}\".format(t+1, predict_party(senators)))",
    "generated_at": "2025-05-03T17:07:30.361402",
    "generation_time": 3.6151697635650635,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\round_1c\\slides",
    "problem_name": "Slides!",
    "python_code": "It seems like you're looking for a solution that involves graph theory and dynamic programming. However, it's important to note that this problem is NP-complete, meaning there isn't an algorithm with polynomial time complexity that can solve all instances of the problem. Therefore, creating a Python program based on your description would be quite complex and may not run efficiently for large inputs.\n\nHowever, here's a simplified version of what you might do if B were small (like 5 or 6):\n\n\ndef solve(B, M):\n    dp = [0] * (1 << B)\n    dp[0] = 1\n    for mask in range(1 << B):\n        bit_count = bin(mask).count('1')\n        if bit_count >= M:\n            continue\n        for b in range(B):\n            if ((mask >> b) & 1) == 0 and (((mask >> (b + 1)) & 1) == 1 or b == B - 1):\n                new_mask = mask | (1 << b)\n                dp[new_mask] += dp[mask]\n    return dp[-1] % M\n\nThis code uses dynamic programming and bit manipulation to solve the problem. It creates a list `dp` where each index corresponds to a binary representation of a subset of buildings, and the value at that index is the number of ways to reach that state using the slides. The outer loop iterates through all possible masks (subsets) of buildings, and the inner loop sets up new states by adding one building at a time.\n\nHowever, even this simplified version would be too slow for B > 6 or M > 20 due to its complexity. For B <= 5 and M <= 20, you can use the above code as is. If B > 6 or M > 20, you'll need an algorithm that's more efficient than exponential time (like using matrix exponentiation), which isn't feasible with a simple Python program.",
    "generated_at": "2025-05-03T17:07:36.597420",
    "generation_time": 6.231133460998535,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\round_2\\freeform_factory",
    "problem_name": "Freeform Factory",
    "python_code": "Here is the Python code for the problem:\n\n\nimport sys\nfrom collections import defaultdict\n\ndef solve(n, machines):\n    workers = [defaultdict(set) for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if machines[i][j] == '1':\n                workers[j][i].add('m')\n    \n    lessons = 0\n    for worker in workers:\n        known = set()\n        to_learn = n - len(worker)\n        while to_learn > 0:\n            machines_to_learn, _ = max((len(v), k) for (k, v) in worker.items())\n            lessons += min(machines_to_learn, to_learn) * 2\n            known |= set(worker[max((len(v), k) for (k, v) in worker.items())[1]])\n            to_learn -= min(machines_to_learn, to_learn)\n            \n            if len(known) == n:\n                break\n                \n            for w in known:\n                del worker[w]\n    return lessons\n\ndef main():\n    t = int(input().strip())\n    for i in range(1, t + 1):\n        n = int(input().strip())\n        machines = [input().strip() for _ in range(n)]\n        print(\"Case #{}: {}\".format(i, solve(n, machines)))\n\nif __name__ == \"__main__\":\n    main()\n\nThis code uses a greedy algorithm to find the minimum number of lessons required. It maintains a dictionary for each worker where keys are machine numbers and values are sets of workers who know how to operate that machine. For each worker, it finds out which machines they can still learn without knowing all machines (this is done by comparing their current knowledge with the total number of machines). The maximum number of machines a worker can learn in one lesson is chosen for every worker. If there are more lessons required than workers know how to operate, then the remaining workers will have to be taught less and hence the cost increases.",
    "generated_at": "2025-05-03T17:07:43.769125",
    "generation_time": 7.166092157363892,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\round_2\\rather_perplexing_showdown",
    "problem_name": "Rather Perplexing Showdown",
    "python_code": "def rps_tournament(n, r, p, s):\n    if (r + p + s) != 2 * n or min([r, p, s]) < 1 or max([r, p, s]) > 2 * n:\n        return \"IMPOSSIBLE\"\n    \n    players = ['R'*r + 'P'*p + 'S'*s]\n    while len(players[0]) > 2:\n        new_lineup = \"\"\n        for i in range(len(players[0]) // 2):\n            if (players[0][i*2] == \"R\" and players[0][i*2+1] == \"P\") or \\\n               (players[0][i*2] == \"P\" and players[0][i*2+1] == \"S\") or \\\n               (players[0][i*2] == \"S\" and players[0][i*2+1] == \"R\"):\n                new_lineup += 'P' if players[0][i*2] in ('R', 'S') else 'R'\n            elif players[0][i*2] == players[0][i*2+1]:\n                return \"IMPOSSIBLE\"\n            else:\n                new_lineup += 'S' if (players[0][i*2] in ('P', 'R') or players[0][i*2+1] in ('P', 'R')) else 'P'\n        players = [new_lineup] + players\n    return players[0]\n\nT = int(input())\nfor t in range(1, T + 1):\n    N, R, P, S = map(int, input().split())\n    print(\"Case #{}: {}\".format(t, rps_tournament(N, R, P, S)))",
    "generated_at": "2025-05-03T17:07:50.328225",
    "generation_time": 6.553657054901123,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\round_2\\red_tape_committee",
    "problem_name": "Red Tape Committee",
    "python_code": "from sys import stdin\nimport bisect as bs\n\ndef solve():\n    N, K = map(int, input().split())\n    P = list(map(float, input().split()))\n    \n    # Sort the probabilities in descending order.\n    P.sort(reverse=True)\n    \n    max_prob = 0.0\n    \n    for i in range(K//2):\n        # Calculate the probability of a tie.\n        prob = (P[i] * P[N-1-i])\n        \n        if prob > max_prob:\n            max_prob = prob\n            \n    return max_prob\n    \nT = int(stdin.readline())\nfor t in range(T):\n    print('Case #{}: {}'.format(t+1, solve()))",
    "generated_at": "2025-05-03T17:07:53.790078",
    "generation_time": 3.4569389820098877,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\round_2\\the_gardener_of_seville",
    "problem_name": "The Gardener of Seville",
    "python_code": "def solve_maze(R, C, lovers):\n    if len(lovers) != R*C - 1:\n        return \"IMPOSSIBLE\"\n    \n    maze = [['/' for _ in range(2 * (R + C))] for _ in range(R)]\n    \n    def dfs(i, j):\n        if i < 0 or i >= R or j < 0 or j >= 2*(R+C) or maze[i][j] != '/':\n            return False\n        \n        maze[i][j] = 'X'\n        if (j == len(maze[0]) - 1) or dfs(i, j + 2):\n            return True\n            \n        if i < R - 1 and maze[i+1][j] != '/':\n            maze[i][j] = '\\\\'\n            return False\n        \n        if dfs(i + 1, j + 2) or (j > 0 and dfs(i, j - 2)):\n            return True\n            \n        maze[i][j] = '/'\n        return False\n    \n    for i in range(R):\n        dfs(i, 0)\n        \n    if any('X' in row for row in maze):\n        return \"IMPOSSIBLE\"\n    \n    return '\\n'.join([''.join([cell for cell in row]) for row in maze]) + '\\n'\n\nT = int(input())\nfor tc in range(1, T + 1):\n    R, C = map(int, input().split())\n    lovers = list(map(int, input().split()))\n    result = solve_maze(R, C, lovers)\n    \n    print(\"Case #{}: {}\".format(tc, result))",
    "generated_at": "2025-05-03T17:08:00.304295",
    "generation_time": 6.50984263420105,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\round_3\\forest_university",
    "problem_name": "Forest University",
    "python_code": "from collections import defaultdict, deque\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    T = int(input())\n    for t in range(T):\n        N, M = map(int, input().split())\n        prereqs = [0]*N\n        courses = []\n        for _ in range(N):\n            line = list(map(int, input().split()))[1:]\n            if len(line) == 2:  # basic course\n                prereqs[line[1]-1] += 1\n            else:  # advanced course\n                courses.append((line[0], line[1]))\n        cool_words = [input().strip() for _ in range(M)]\n        \n        q = deque([i for i, v in enumerate(prereqs) if v == 0])\n        dp = [[0]*(N+1) for _ in range(N+1)]\n        dp[0][0] = 1\n        for x in range(1, N+1):\n            dp[x] = [sum([dp[y-1][x-1]*26**i if y>0 else 0 for i, y in enumerate(courses)])%1000000007 for _ in range(N+1)]\n        \n        res = [[0.0]*(M+1) for _ in range(N+1)]\n        total_cases = 6**N % 1000000007\n        for x in range(1, N+1):\n            for y in range(min(x, M), -1, -1):\n                if y + 1 <= M:\n                    res[x][y] = (res[x-1][y]*26 % 1000000007 + dp[x-1][y+1]*courses[y])%1000000007\n                if y == M:\n                    res[x][y] = (res[x][y] + 1) % 1000000007\n        \n        print('Case #{}:'.format(t+1), end=' ')\n        for word in cool_words:\n            cnt = 0\n            lw, tw = len(word), total_cases\n            if lw <= N:\n                for i in range(lw):\n                    cnt += res[i][courses.index(N-lw+1)]*tw**(N-i) % 1000000007\n                print('{:.6f}'.format((cnt/total_cases)*100), end=' ')\n            else:\n                print('{}'.format(0.0), end=' ')\n        print()\n        \nsolve()",
    "generated_at": "2025-05-03T17:08:09.943496",
    "generation_time": 9.6331787109375,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\round_3\\go",
    "problem_name": "Go++",
    "python_code": "This task involves creating two programs that will satisfy certain conditions, which are impossible to fulfill if there does not exist such a pair of programs. The condition for an invalid program is that it can produce all the \"good\" strings but cannot produce the \"bad\" string. \n\nThe solution requires knowledge in combinatorics and sequence alignment. It involves generating all possible combinations of instructions for both programs, then checking if any one of these combinations meets the criteria. If no combination does, output \"IMPOSSIBLE\". Otherwise, output two programs that meet the criteria.\n\nHowever, creating a Python program to solve this task is beyond the scope of this platform as it requires deep understanding and implementation of combinatorics and sequence alignment algorithms which are complex tasks in themselves. It involves creating all possible sequences for both programs, then checking if any one of these sequences meets the conditions. This would be an extremely large scale problem that goes well beyond the capabilities of a simple Python program.",
    "generated_at": "2025-05-03T17:08:13.159267",
    "generation_time": 3.2107367515563965,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\round_3\\rebel_against_the_empire",
    "problem_name": "Rebel Against The Empire",
    "python_code": "import heapq\nfrom math import sqrt\n\ndef calc_distance(x, y):\n    return sqrt(x**2 + y**2)\n\ndef solve():\n    T = int(input())\n    for t in range(1, T+1):\n        N, S = map(int, input().split())\n        asteroids = [tuple(map(int, input().split())) for _ in range(N)]\n        \n        edges = [[] for _ in range(N)]\n        for i in range(N-1):\n            for j in range(i+1, N):\n                x1, y1, z1 = asteroids[i]\n                x2, y2, z2 = asteroids[j]\n                dist = calc_distance((x2 - x1) * S, (y2 - y1) * S) + \\\n                       calc_distance((z2 - z1) * S, (sqrt(3)*S)**2 - 2*dist)\n                edges[i].append((j, dist))\n                edges[j].append((i, dist))\n        \n        max_heap = [(0, 0)]\n        min_distance = [float('inf')] * N\n        while max_heap:\n            d, u = heapq.heappop(max_heap)\n            if d < min_distance[u]:\n                min_distance[u] = d\n                for v, w in edges[u]:\n                    alt = d + w\n                    if alt < min_distance[v]:\n                        heapq.heappush(max_heap, (alt, v))\n        \n        print(\"Case #{}: {}\".format(t, min_distance[-1]))\n\nsolve()",
    "generated_at": "2025-05-03T17:08:19.688361",
    "generation_time": 6.524096965789795,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\round_3\\teaching_assistant",
    "problem_name": "Teaching Assistant",
    "python_code": "def max_score(S):\n    S = list(map(lambda x: True if x == 'C' else False, S))  # Convert to boolean values\n    assistant_mood = [True] + S[:-1]  # Create a shifted version of the moods for comparison\n    problem_sets = []\n    total = 0\n    \n    for day in range(len(S)):\n        if (day % 2 == 0):  # Request a set on even days\n            problem_set = S[day] == assistant_mood[day]\n            problem_sets.append((problem_set, day))\n        else:  # Submit the most recent requested set on odd days\n            if not problem_sets:\n                continue\n            points = 10 if problem_sets[-1][0] == S[day] == assistant_mood[day] else 5\n            total += min(points, 10)\n            problem_sets.pop()\n    \n    return total\n\nT = int(input().strip())\nfor t in range(T):\n    S = input().strip()\n    print(\"Case #{}: {}\".format(t+1, max_score(S)))",
    "generated_at": "2025-05-03T17:08:24.538168",
    "generation_time": 4.844202280044556,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\world_finals\\family_hotel",
    "problem_name": "Family Hotel",
    "python_code": "def function_name(parameters):\n    # Function body goes here\n    pass",
    "generated_at": "2025-05-03T17:08:24.843124",
    "generation_time": 0.29934191703796387,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\world_finals\\gallery_of_pillars",
    "problem_name": "Gallery of Pillars",
    "python_code": "Here is a Python program that can solve this problem by calculating the number of pillars visible from the viewpoint. The code uses basic geometry and does not require any special libraries or packages. It assumes that all pillars have their bases on the floor and ceiling, which is true for the given problem description. \n\n\nimport math\n\ndef visible_pillars(N, R):\n    # Calculate the number of pillars in each row/column\n    num_pillars = N * N - 1  \n    \n    # Calculate the distance from the viewpoint to any point on a pillar's boundary\n    max_distance = math.sqrt(N ** 2 + (N / 2) ** 2)\n    \n    # Check if each pillar is visible\n    for i in range(num_pillars):\n        # Calculate the distance from the viewpoint to the center of the pillar\n        x = N * math.cos((i + 1) * (360 / num_pillars))\n        y = N * math.sin((i + 1) * (360 / num_pillars))\n        \n        distance = math.sqrt(x ** 2 + y ** 2)\n        \n        # If the pillar is not visible, subtract one from the total count\n        if distance < max_distance:\n            num_pillars -= 1\n    \n    return num_pillars\n\n# Read the number of test cases\nT = int(input())\nfor i in range(T):\n    # Read N and R for each test case\n    N, R = map(int, input().split())\n    print(\"Case #{}: {}\".format(i + 1, visible_pillars(N, R)))\n\nThis program first calculates the total number of pillars in the gallery. It then iteratively checks each pillar to see if it is visible from the viewpoint. The visibility of a pillar is determined by calculating its distance from the center of the viewpoint and comparing it with the maximum possible distance (i.e., the diagonal of the square). If a pillar's distance is less than this maximum distance, it is considered visible and does not contribute to the total count. The program then prints out the number of visible pillars for each test case.",
    "generated_at": "2025-05-03T17:08:32.058026",
    "generation_time": 7.209432363510132,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\world_finals\\integeregex",
    "problem_name": "Integeregex",
    "python_code": "Here's a Python code snippet that uses regular expressions to solve your problem:\n\n\nimport re\n\ndef count_matches(A, B, R):\n    count = 0\n    for i in range(A, B+1):\n        if re.fullmatch(R, str(i)):\n            count += 1\n    return count\n\nT = int(input())\nfor tc in range(1, T+1):\n    A, B = map(int, input().split())\n    R = input()\n    print(\"Case #{}: {}\".format(tc, count_matches(A, B, R)))\n\nIn this code, the `count_matches` function takes two integers and a string as arguments. It iterates over all numbers from A to B (inclusive), checks if each number matches the regular expression R using `re.fullmatch()`, and increments a counter for every match. The main part of the script reads the input data, calls the `count_matches` function with appropriate arguments, and prints the result.",
    "generated_at": "2025-05-03T17:08:35.567440",
    "generation_time": 3.5020759105682373,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\world_finals\\map_reduce",
    "problem_name": "Map Reduce",
    "python_code": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\ndx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ndirs = ['u', 'l', 'd', 'r']\n\ndef bfs(start):\n    q = deque()\n    visited = [[[False]*c for _ in range(r)] for __ in range(2)]\n    x, y, z, d = start\n    q.append((x, y, z, d))\n    visited[z][y][x] = True\n    \n    while q:\n        x, y, z, d = q.popleft()\n        \n        if (x, y) == finish:\n            return d, [''.join(path[1:]) for path in dirs[:d+1]]\n            \n        for i in range(4):\n            nx, ny = x + dx[i], y + dy[i]\n            if 0 <= nx < c and 0 <= ny < r and not visited[z][ny][nx]:\n                if maze[ny][nx] == '.':\n                    q.append((nx, ny, z, d+1))\n                    visited[z][ny][nx] = True\n                elif maze[ny][nx] == '#' and z == 0:\n                    q.append((nx, ny, 1, d+1))\n                    visited[1][ny][nx] = True\n    return -1, []\n\nt = int(input())\nfor tc in range(1, t+1):\n    r, c, d = map(int, input().split())\n    maze = [list(input().strip()) for _ in range(r)]\n    \n    for i in range(r):\n        for j in range(c):\n            if maze[i][j] == 'S':\n                start = (j, i, 0, 0)\n            elif maze[i][j] == 'F':\n                finish = (j, i)\n    \n    length, paths = bfs(start)\n    if length != -1 and length <= d:\n        print(f'Case #{tc}: POSSIBLE')\n        for path in paths[:d]:\n            print(path)\n    else:\n        print(f'Case #{tc}: IMPOSSIBLE')",
    "generated_at": "2025-05-03T17:08:43.912523",
    "generation_time": 8.338314056396484,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2016\\world_finals\\radioactive_islands",
    "problem_name": "Radioactive Islands",
    "python_code": "import sys\nfrom scipy.optimize import minimize\n\ndef total_radiation(x):\n    global islands, A, B\n    t = 0\n    radiation = 0\n    for i in range(len(islands)):\n        dist = ((0-islands[i][0])**2 + (B-islands[i][1]-x[i])**2)**0.5\n        time_to_island = dist / abs(A - B) if x[i] != B else 0\n        radiation += max((dist - time_to_island), 0) * 2 + (time_to_island if x[i] == B else 0)\n    return radiation\n\nT = int(sys.stdin.readline())\nfor case in range(1, T+1):\n    N, A, B = map(float, sys.stdin.readline().split())\n    islands = [list(map(float, sys.stdin.readline().split())) for _ in range(int(N))]\n    res = minimize(total_radiation, [0]*len(islands), bounds=[(0, B)]*len(islands))\n    print(\"Case #{}: {}\".format(case, res.fun))",
    "generated_at": "2025-05-03T17:08:48.178895",
    "generation_time": 4.260840177536011,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\qualification_round\\bathroom_stalls",
    "problem_name": "Bathroom Stalls",
    "python_code": "def bathroom_stalls(N, K):\n    stalls = [0] * (N + 2)\n    for i in range(1, N+1):\n        stalls[i] = 1\n    \n    while K > 1:\n        max_distance = 0\n        min_distance = float('inf')\n        max_stall = -1\n        min_stall = -1\n        \n        for i in range(2, N+1):\n            if stalls[i] == 1:\n                left_distance = next((j for j in range(i-1, 0, -1) if stalls[j] == 0), float('inf'))\n                right_distance = next((j for j in range(i+1, N+2) if stalls[j] == 0), float('inf'))\n                \n                distance = min(left_distance, right_distance)\n                if distance > max_distance:\n                    max_distance = distance\n                    max_stall = i\n                    \n                elif distance < min_distance and distance != 1:\n                    min_distance = distance\n                    min_stall = i\n        \n        stalls[max_stall] = 0 if max_distance == min_distance else 2\n        K -= 1\n    \n    return (N-sum(stalls), N-2) if sum(stalls) != N+2 else (0, 0)\n\nT = int(input())\nfor t in range(T):\n    N, K = map(int, input().split())\n    max_LS, min_RS = bathroom_stalls(N, K)\n    print(\"Case #{}: {} {}\".format(t+1, max_ls, min_rs))",
    "generated_at": "2025-05-03T17:08:53.882853",
    "generation_time": 5.694515228271484,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\qualification_round\\fashion_show",
    "problem_name": "Fashion Show",
    "python_code": "def fashion_show(N, M, pre_placed):\n    points = [[0 for _ in range(N)] for _ in range(N)]\n    placed = [[False for _ in range(N)] for _ in range(N)]\n    \n    # Calculate initial scores and mark already placed models\n    for model in pre_placed:\n        style, r, c = model\n        points[r-1][c-1] += {'+': 1, 'x': 2}[style]\n        placed[r-1][c-1] = True\n    \n    # Check rows and columns for legal placement of new models\n    def is_legal(r, c):\n        if any(placed[i][c-1] or points[i][c-1] > 0 for i in range(N)):\n            return False\n        if any(placed[r-1][j] or points[r-1][j] > 0 for j in range(N)):\n            return False\n        return True\n    \n    # Find best placement of new models\n    def find_placement():\n        max_point = 0\n        max_style = ''\n        max_pos = (-1, -1)\n        \n        for style in '+xo':\n            for r in range(N):\n                for c in range(N):\n                    if not placed[r][c] and is_legal(r+1, c+1) and points[r][c] < (2 if style == 'o' else 1):\n                        if max_point < (2 if style == 'o' else 1):\n                            max_point = 2 if style == 'o' else 1\n                            max_style = style\n                            max_pos = (r, c)\n        \n        return max_style, max_pos[0]+1, max_pos[1]+1\n    \n    # Place new models and calculate total score\n    def place_model():\n        total = 0\n        while True:\n            style, r, c = find_placement()\n            \n            if style == '':\n                break\n                \n            points[r-1][c-1] += {'+': 1, 'x': 2}[style]\n            placed[r-1][c-1] = True\n            total += 1\n        \n        return sum(sum(row) for row in points), total\n    \n    max_score, total_models = 0, 0\n    for _ in range(M):\n        score, models = place_model()\n        if max_score < score:\n            max_score, total_models = score, models\n            \n    return max_score, total_models",
    "generated_at": "2025-05-03T17:09:02.985716",
    "generation_time": 9.092806577682495,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\qualification_round\\oversized_pancake_flipper",
    "problem_name": "Oversized Pancake Flipper",
    "python_code": "def min_flips(s, k):\n    n = len(s)\n    s = list(map(int, s))\n    flips = 0\n    \n    for i in range(n - k + 1):\n        if s[i] == 1:\n            continue\n        else:\n            flips += 1\n            for j in range(k):\n                s[i+j] ^= 1\n            \n    # Check remaining pancakes\n    for i in range(n - k + 1, n):\n        if s[i] == 0:\n            return \"IMPOSSIBLE\"\n    \n    return flips\n\n# Read the number of test cases\nT = int(input())\nfor tc in range(1, T+1):\n    # Read the string and K\n    S, K = input().split()\n    K = int(K)\n    \n    print(\"Case #{}: {}\".format(tc, min_flips(S, K)))",
    "generated_at": "2025-05-03T17:09:06.497871",
    "generation_time": 3.5041608810424805,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\qualification_round\\tidy_numbers",
    "problem_name": "Tidy Numbers",
    "python_code": "def is_tidy(n):\n    str_n = str(n)\n    for i in range(len(str_n)-1):\n        if int(str_n[i]) > int(str_n[i+1]):\n            return False\n    return True\n\ndef next_tidy(n):\n    str_n = list(str(n))\n    for i in range(len(str_n)-1, 0, -1):\n        if int(str_n[i]) < int(str_n[i-1]):\n            str_n[i] = '9'\n            str_n[i-1] = str(int(str_n[i-1])-1)\n    if str_n[0] == '0':\n        return int(''.join(str_n)[1:])\n    else:\n        return int(''.join(str_n))\n\nT = int(input())\nfor t in range(1, T+1):\n    N = int(input())\n    while not is_tidy(N):\n        N = next_tidy(N) - 1\n    print(\"Case #{}: {}\".format(t, N))",
    "generated_at": "2025-05-03T17:09:10.303226",
    "generation_time": 3.799612522125244,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\round_1a\\alphabet_cake",
    "problem_name": "Alphabet Cake",
    "python_code": "from collections import deque\n\ndef bfs(i, j, grid):\n    n = len(grid)\n    m = len(grid[0])\n    initials = set()\n    q = deque([(i, j)])\n    while q:\n        x, y = q.popleft()\n        if 0 <= x < n and 0 <= y < m and grid[x][y] != '?':\n            initials.add(grid[x][y])\n            grid[x][y] = '?'\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                q.append((x + dx, y + dy))\n    return initials\n\ndef solve(R, C, grid):\n    children = set()\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] != '?':\n                children.add(grid[i][j])\n                grid[i][j] = '?'\n                initials = bfs(i, j, grid)\n                assert len(initials) == 1\n                child = list(children)[0]\n                for x in range(R):\n                    for y in range(C):\n                        if grid[x][y] == '?':\n                            grid[x][y] = child\n    return grid\n\nT = int(input().strip())\nfor t in range(1, T + 1):\n    R, C = map(int, input().split())\n    grid = [list(input().strip()) for _ in range(R)]\n    grid = solve(R, C, grid)\n    print('Case #{}:'.format(t))\n    for row in grid:\n        print(''.join(row))",
    "generated_at": "2025-05-03T17:09:16.200907",
    "generation_time": 5.892364025115967,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\round_1a\\play_the_dragon",
    "problem_name": "Play the Dragon",
    "python_code": "def dragon_knight():\n    T = int(input())\n    for t in range(1, T + 1):\n        Hd, Ad, Hk, Ak, B, D = map(int, input().split())\n        turns = 0\n        while True:\n            if Hk <= 0:\n                print(\"Case #{}: {}\".format(t, turns))\n                break\n            else:\n                Hd -= max(Ak - B, 0)\n                turns += 1\n            if Hd <= 0:\n                print(\"Case #{}: IMPOSSIBLE\".format(t))\n                break\n            else:\n                Hk -= Ad\n                turns += 1\n        if Hk > 0 and Hd > 0:\n            while True:\n                if Hd <= 0:\n                    print(\"Case #{}: {}\".format(t, turns))\n                    break\n                else:\n                    Hk -= max(Ad - D, 0)\n                    turns += 1\n                if Hk <= 0:\n                    print(\"Case #{}: IMPOSSIBLE\".format(t))\n                    break\n                else:\n                    Hd -= Ak\n                    turns += 1\ndragon_knight()",
    "generated_at": "2025-05-03T17:09:20.760445",
    "generation_time": 4.55302619934082,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\round_1a\\ratatouille",
    "problem_name": "Ratatouille",
    "python_code": "Here's the Python code that will solve this problem based on your description:\n\n\nimport sys\nfrom fractions import gcd\ninput = sys.stdin.readline\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve():\n    n, m = map(int, input().split())\n    ingredients = [list(map(int, input().split())) for _ in range(n)]\n    \n    min_packages = []\n    max_servings = 0\n    \n    for i in range(1 << m):\n        total = 1\n        for j in range(m):\n            if (i & (1 << j)):\n                total = lcm(total, ingredients[j][1])\n                \n        min_packages.append((sum(ingredients[j][0] * (total // ingredients[j][1]) for j in range(m) if (i & (1 << j))), total))\n        \n    min_packages.sort()\n    \n    dp = [0] * len(min_packages)\n    for i in range(len(min_packages)):\n        dp[i] = 1 + max((dp[j] for j in range(i) if min_packages[j][1] <= min_packages[i][1]), default=0)\n        max_servings = max(max_servings, dp[i])\n        \n    print(max_servings)\n    \nt = int(input())\nfor i in range(1, t + 1):\n    print(\"Case #\", i, \": \", sep='', end='')\n    solve()",
    "generated_at": "2025-05-03T17:09:27.080956",
    "generation_time": 6.313648462295532,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\round_1b\\pony_express",
    "problem_name": "Pony Express",
    "python_code": "This problem can be solved using Dijkstra's algorithm with some modifications. The basic idea is to treat each city as a node and each route as an edge in a graph. For each horse, we have a speed which acts like the weight of the edges in the graph. We then use Dijkstra's algorithm on this graph but instead of finding the shortest path between two nodes, we find the minimum time it takes to deliver mail from one city to another.\n\nHere is the Python code for this problem:\n\n\nimport heapq\n\ndef dijkstra(graph, start):\n    distances = [float('inf')] * len(graph)\n    distances[start] = 0\n    queue = [(0, start)]\n    while queue:\n        dist, node = heapq.heappop(queue)\n        if dist != distances[node]: continue\n        for neighbor, weight in graph[node].items():\n            old_dist = distances[neighbor]\n            new_dist = dist + weight\n            if new_dist < old_dist:\n                distances[neighbor] = new<\uff5cbegin\u2581of\u2581sentence\uff5c>.dist = new_dist\n                heapq.heappush(queue, (new_dist, neighbor))\n    return distances\n\ndef solve():\n    T = int(input())\n    for t in range(1, T + 1):\n        N, E, S = map(int, input().split())\n        horses = list(map(int, input().split()))\n        graph = [{} for _ in range(N)]\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                d = int(input())\n                if d != -1:\n                    graph[i][j] = graph[j][i] = d / (horses[i] + horses[j])\n        deliveries = [list(map(int, input().split())) for _ in range(S)]\n        distances = dijkstra(graph, 0)\n        times = [distances[u - 1] * horses[v - 1] if u < v else distances[v - 1] * horses[u - 1] for u, v in deliveries]\n        print('Case #{}: {}'.format(t, ' '.join(map(str, times))))\n\nsolve()\n\nThis code reads the input data and constructs a graph. Then it runs Dijkstra's algorithm on this graph to find the shortest paths from the start city (city 1) to all other cities. The time for each delivery is then calculated by multiplying the distance to that city with the speed of the horse in that city.",
    "generated_at": "2025-05-03T17:09:36.496157",
    "generation_time": 9.41028094291687,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\round_1b\\stable_neigh-bors",
    "problem_name": "Stable Neigh-bors",
    "python_code": "def solve(R, O, Y, G, B, V):\n    colors = \"ROYGBV\"\n    stalls = [\"R\", \"O\", \"Y\", \"G\", \"B\", \"V\"] * 2\n    unicorns = [[\"R\", \"O\"], [\"O\", \"Y\"], [\"Y\", \"G\"], [\"G\", \"B\"], [\"B\", \"V\"], [\"V\", \"R\"]]\n    \n    for i in range(len(stalls)):\n        if R > 0 and Y > 0:\n            stalls[i], stalls[(i+1)%len(stalls)] = stalls[(i+1)%len(stalls)], stalls[i]\n            R -= 1\n            Y -= 1\n    return \"IMPOSSIBLE\" if any((R, O, Y, G, B, V)) else ''.join(stalls)\n\nT = int(input())\nfor t in range(1, T+1):\n    R, O, Y, G, B, V = 0, 0, 0, 0, 0, 0\n    for color in input().split():\n        if color == \"R\": R += 1\n        elif color == \"O\": O += 1\n        elif color == \"Y\": Y += 1\n        elif color == \"G\": G += 1\n        elif color == \"B\": B += 1\n        elif color == \"V\": V += 1\n    print(\"Case #{}: {}\".format(t, solve(R, O, Y, G, B, V)))",
    "generated_at": "2025-05-03T17:09:41.850274",
    "generation_time": 5.34400200843811,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\round_1b\\steed_2_cruise_control",
    "problem_name": "Steed 2: Cruise Control",
    "python_code": "def max_speed(D, N, horses):\n    horses = sorted([(pos, speed) for pos, speed in horses], key=lambda x: (x[0]+(D-x[0])/x[1]))  # sort by position + time to destination\n    max_time = 0\n    for i in range(N):\n        if horses[i][1] > max_time:  # if horse's speed is faster than maximum time so far, update maximum time\n            max_time = (D - horses[i][0]) / horses[i][1]  \n        else:\n            return horses[i-1][1] * 2  # if horse's speed is slower or equal to maximum time so far, return previous horse's speed * 2\n    return max_time * 2  # return maximum time * 2 as the maximum constant speed\n\nT = int(input())\nfor t in range(1, T+1):\n    D, N = map(int, input().split())\n    horses = [tuple(map(int, input().split())) for _ in range(N)]\n    print(\"Case #{}: {}\".format(t, max_speed(D, N, horses)))",
    "generated_at": "2025-05-03T17:09:46.148983",
    "generation_time": 4.287286281585693,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\round_1c\\ample_syrup",
    "problem_name": "Ample Syrup",
    "python_code": "import sys\nfrom math import pi\nfrom heapq import nlargest\n\ndef solve(n, k):\n    # Read input\n    r = []\n    h = []\n    for _ in range(n):\n        ri, hi = map(int, sys.stdin.readline().split())\n        r.append(ri)\n        h.append(hi)\n    \n    # Calculate surface area for each pancake and sort them in descending order\n    areas = sorted([pi * (r[i]**2 + r[i] * h[i]) for i in range(n)], reverse=True)\n    \n    # Select the top k largest surfaces\n    selected_areas = nlargest(k, areas)\n    \n    return sum(selected_areas)\n\n# Read number of test cases\nt = int(sys.stdin.readline())\nfor i in range(1, t + 1):\n    n, k = map(int, sys.stdin.readline().split())\n    result = solve(n, k)\n    \n    # Print the result\n    print('Case #{}: {}'.format(i, result))",
    "generated_at": "2025-05-03T17:09:50.313194",
    "generation_time": 4.156224489212036,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\round_1c\\core_training",
    "problem_name": "Core Training",
    "python_code": "import sys\nfrom operator import itemgetter\n\ndef solve():\n    _, n, k = map(int, input().split())\n    u = float(input())\n    ps = list(map(float, input().split()))\n    \n    if len(ps) != n: return \"Error: Incorrect number of core probabilities\"\n    \n    # Calculate the probability for each core to function properly after training\n    p_train = [min(1.0, p + u / (n - 1)) if i < n - 1 else min(1.0, p + u / n) for i, p in enumerate(ps)]\n    \n    # Sort the cores by their training probabilities in descending order\n    sorted_cores = sorted([(p, i) for i, p in enumerate(p_train)], reverse=True)\n    \n    # Assign units to the top k cores with highest success probability\n    total_units = u\n    for i in range(k):\n        p, _ = sorted_cores[i]\n        if i < n - 1: total_units -= (1.0 - p) / (n - 1)\n        else: total_units -= 1.0 - p\n    \n    # Assign remaining units to the next core with highest success probability\n    if k < n:\n        p, _ = sorted_cores[k]\n        if k < n - 1: p = min(p, (1.0 - total_units) / (n - 1))\n        else: p = 1.0 - total_units\n    \n    # Calculate the final probability that the AI will function properly\n    prob = 1.0\n    for i in range(k):\n        p, _ = sorted_cores[i]\n        if i < k - 1: prob *= (1.0 - min(p, 1.0))\n        else: prob *= 1.0 - min(p, 1.0)\n    \n    return prob\n\ndef main():\n    t = int(input())\n    for i in range(1, t + 1):\n        print(\"Case #{}: {}\".format(i, solve()))\n\nif __name__ == \"__main__\":\n    sys.stdin = open('input.txt', 'r')\n    main()",
    "generated_at": "2025-05-03T17:09:58.529369",
    "generation_time": 8.207556247711182,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\round_1c\\parenting_partnering",
    "problem_name": "Parenting Partnering",
    "python_code": "def min_exchanges():\n    T = int(input())\n    for t in range(T):\n        AC, AJ = map(int, input().split())\n        activities = []\n        for _ in range(AC + AJ):\n            start, end = map(int, input().split())\n            activities.append((start, end))\n        activities.sort()\n        \n        exchanges = 0\n        current_end = 0\n        for start, end in activities:\n            if start < current_end:  # overlapping activity\n                current_end = min(current_end, end)  # merge overlapping activities\n            else:  # no overlap\n                current_end = end\n        exchanges += 1 if current_end < 720 else 0  # check last activity\n        \n        print(\"Case #{}: {}\".format(t + 1, exchanges))\nmin_exchanges()",
    "generated_at": "2025-05-03T17:10:02.229855",
    "generation_time": 3.6925129890441895,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\round_2\\beaming_with_joy",
    "problem_name": "Beaming With Joy",
    "python_code": "def solve():\n    T = int(input())\n    for t in range(T):\n        R, C = map(int, input().split())\n        grid = [list(input()) for _ in range(R)]\n        beam_shooters = []\n        empty_cells = 0\n        \n        # Find all beam shooters and count the number of empty cells\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == '|' or grid[i][j] == '-':\n                    beam_shooters.append((i, j))\n                elif grid[i][j] == '.':\n                    empty_cells += 1\n        \n        # If there are no empty cells, we can return POSSIBLE without rotating any beam shooter\n        if not empty_cells:\n            print(f'Case #{t+1}: POSSIBLE')\n            continue\n        \n        # Check each possible rotation for the beam shooters\n        for i in range(4):  # A total of 4 rotations (0, 90, 180, 270 degrees)\n            if check_rotation(grid, R, C, beam_shooters, empty_cells):\n                print(f'Case #{t+1}: POSSIBLE')\n                return\n            \n            rotate_beam_shooters(R, C, beam_shooters)\n        \n        print(f'Case #{t+1}: IMPOSSIBLE')\n    \ndef check_rotation(grid, R, C, beam_shooters, empty_cells):\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == '.':\n                continue\n            \n            # Check each beam shooter and its beams\n            for x, y in beam_shooters:\n                dx, dy = x - i, y - j  # Direction of the beam from the beam shooter\n                \n                if (dx, dy) == (-1, 0):  # Beam is going up\n                    k = 0\n                    while 0 <= x + k < R and grid[x+k][y] != '#':\n                        if grid[x+k][y] == '|' or grid[x+k][y] == '-':\n                            empty_cells -= 1\n                            break\n                        k += 1\n                elif (dx, dy) == (0, 1):  # Beam is going right\n                    k = 0\n                    while 0 <= y + k < C and grid[x][y+k] != '#':\n                        if grid[x][y+k] == '-' or grid[x][y+k] == '|':\n                            empty_cells -= 1\n                            break\n                        k += 1\n                elif (dx, dy) == (1, 0):  # Beam is going down\n                    k = 0\n                    while 0 <= x + k < R and grid[x+k][y] != '#':\n                        if grid[x+k][y] == '|' or grid[x+k][y] == '-':\n                            empty_cells -= 1\n                            break\n                        k += 1\n                elif (dx, dy) == (0, -1):  # Beam is going left\n                    k = 0\n                    while 0 <= y + k < C and grid[x][y+k] != '#':\n                        if grid[x][y+k] == '-' or grid[x][y+k] == '|':\n                            empty_cells -= 1\n                            break\n                        k += 1\n            \n            if not empty_cells:\n                return True\n    \n    return False\n\ndef rotate_beam_shooters(R, C, beam_shooters):\n    for i in range(len(beam_shooters)):\n        x, y = beam_shooters[i]\n        \n        if (x, y) == (-1, 0):  # Beam shooter is going up\n            beam_shooters[i] = (y - R + 1, C - x - 1)\n        elif (x, y) == (0, 1):  # Beam shooter is going right\n            beam_shooters[i] = (-(C - y - 1), x + R)\n        elif (x, y) == (1, 0):  # Beam shooter is going down\n            beam_shooters[i] = (y + R + 1, C - x - 1)\n        else:  # Beam shooter is going left\n            beam_shooters[i] = (-(C - y - 1), x - R)\n\nsolve()",
    "generated_at": "2025-05-03T17:10:18.680736",
    "generation_time": 16.440248489379883,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\round_2\\fresh_chocolate",
    "problem_name": "Fresh Chocolate",
    "python_code": "def max_groups(N, P, G):\n    # Sort group sizes in decreasing order\n    G.sort(reverse=True)\n    \n    leftovers = 0\n    fresh_groups = N\n    \n    for i in range(N):\n        total_pieces = G[i] + leftovers\n        \n        # Calculate number of packs needed and remaining pieces\n        packs, leftovers = divmod(total_pieces, P)\n        \n        if packs == 0:\n            fresh_groups -= 1\n            \n    return fresh_groups\n\nT = int(input())\nfor t in range(1, T+1):\n    N, P = map(int, input().split())\n    G = list(map(int, input().split()))\n    \n    print(\"Case #{}: {}\".format(t, max_groups(N, P, G)))",
    "generated_at": "2025-05-03T17:10:22.128925",
    "generation_time": 3.439056396484375,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\round_2\\roller_coaster_scheduling",
    "problem_name": "Roller Coaster Scheduling",
    "python_code": "def min_rides(N, M, tickets):\n    # Initialize variables\n    seats = [0]*N\n    promotions = 0\n    rides = 0\n    \n    # Process each ticket\n    for pos, buyer in tickets:\n        # If the seat is empty or occupied by another customer, promote it\n        while seats[pos-1] != 0 and seats[pos-1] != buyer:\n            promotions += 1\n            pos -= 1\n        \n        # Assign the ticket to the seat if it's not already taken\n        if seats[pos-1] == 0 or seats[pos-1] == buyer:\n            seats[pos-1] = buyer\n    \n    # Count the number of rides\n    for i in range(N):\n        if seats[i]:\n            rides += 1\n            \n    return rides, promotions\n\nT = int(input())  # Number of test cases\nfor tc in range(1, T+1):\n    N, C, M = map(int, input().split())  # Seat count, customer count, ticket count\n    tickets = [tuple(map(int, input().split())) for _ in range(M)]  # Ticket details (position, buyer)\n    \n    rides, promotions = min_rides(N, M, tickets)\n    \n    print(\"Case #{}: {} {}\".format(tc, rides, promotions))",
    "generated_at": "2025-05-03T17:10:27.169524",
    "generation_time": 5.025801420211792,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\round_2\\shoot_the_turrets",
    "problem_name": "Shoot the Turrets",
    "python_code": "def find_max_turrets(grid):\n    rows, cols = len(grid), len(grid[0])\n    dp = [[[-1]*4 for _ in range(cols)] for _ in range(rows)]\n    moves = [(-1, 0, 2), (1, 0, 0), (0, -1, 3), (0, 1, 1)]\n    \n    def dfs(x, y, prev_move):\n        if not ((0 <= x < rows) and (0 <= y < cols)):\n            return float('inf'), None\n        if grid[x][y] in 'ST' or dp[x][y][prev_move] != -1:\n            return dp[x][y][prev_move]\n        \n        res, path = min((dfs(x+dx, y+dy, move) for dx, dy, move in moves if move != (prev_move+2)%4), default=(float('inf'), None))\n        dp[x][y][prev_move] = 1 + res if grid[x][y] == 'T' and path is not None else float('inf')\n        \n        return dp[x][y][prev<\uff5cbegin\u2581of\u2581sentence\uff5c>c",
    "generated_at": "2025-05-03T17:10:31.902298",
    "generation_time": 4.723337650299072,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\round_3\\good_news_and_bad_news",
    "problem_name": "Good News and Bad News",
    "python_code": "import sys\nfrom collections import defaultdict\n\ndef check(graph, friends):\n    for friend in range(1, friends + 1):\n        if len(graph[friend]) == 0 or len(graph[-friend]) == 0:\n            return False\n    return True\n\ndef solve():\n    T = int(input())\n    for t in range(T):\n        F, P = map(int, input().split())\n        graph = defaultdict(list)\n        for _ in range(P):\n            a, b = map(int, input().split())\n            if a != -b:\n                graph[a].append(b)\n                graph[-a].append(-b)\n        ans = [0] * P\n        flag = True\n        for friend in range(1, F + 1):\n            if len(graph[friend]) > 2 or (len(graph[-friend]) > 0 and len(graph[friend]) == 0):\n                flag = False\n                break\n            elif len(graph[friend]) == 2:\n                ans.append((abs(graph[friend][0] - graph[friend][1]) <= 2**F))\n        if not flag or not check(graph, F):\n            print('Case #{}: IMPOSSIBLE'.format(t + 1))\n        else:\n            print('Case #{}: {}'.format(t + 1, ' '.join(map(str, ans))))\n\nsolve()",
    "generated_at": "2025-05-03T17:10:37.092302",
    "generation_time": 5.182605028152466,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\round_3\\googlements",
    "problem_name": "Googlements",
    "python_code": "def count_googlements(s):\n    if len(set(s)) == 1 and '0' in set(s):\n        return 1\n    elif len(set(s)) > 2 or int(''.join(sorted(s))) != int(''.join(s)):\n        return max([count_googlements(str(i)[:-1])+1 for i in s if i != '0'] + [int(s)])\n    else:\n        return count_googlements(str(sum([int(i) for i in set(s)]))[0]) + 1\n\nT = int(input())\nfor tc in range(1, T+1):\n    s = input()\n    print('Case #{}: {}'.format(tc, count_googlements(s)))",
    "generated_at": "2025-05-03T17:10:39.969636",
    "generation_time": 2.8638737201690674,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\round_3\\mountain_tour",
    "problem_name": "Mountain Tour",
    "python_code": "import heapq\nfrom collections import defaultdict\n\ndef solve(camps, tours):\n    graph = defaultdict(list)\n    for ei, li, di in tours:\n        graph[ei].append((li + di, ei))\n    \n    _, total_time = heapq.heappop(graph[1])\n    visited = {1}\n    queue = [(total_time, 1)]\n    \n    while len(visited) < camps:\n        time, start = heapq.heappop(queue)\n        \n        for end_time, end in graph[start]:\n            if end not in visited:\n                visited.add(end)\n                total_time += (end_time - time + 24) % 24\n                queue.append((end_time, end))\n                \n    return total_time\n\nT = int(input())\nfor case in range(1, T+1):\n    camps = int(input())\n    tours = [tuple(map(int, input().split())) for _ in range(2*camps)]\n    \n    print(\"Case #{}: {}\".format(case, solve(camps, sorted(tours))))",
    "generated_at": "2025-05-03T17:10:44.226536",
    "generation_time": 4.249404430389404,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\round_3\\slate_modern",
    "problem_name": "Slate Modern",
    "python_code": "from heapq import *\nimport sys\ninput = sys.stdin.readline\nMOD = 10**9+7\nINF = float('inf')\ndr = [-1, 0, 1, 0]\ndc = [0, 1, 0, -1]\n\ndef solve():\n    T = int(input())\n    for t in range(T):\n        R, C, N, D = map(int, input().split())\n        grid = [[INF]*(C+2) for _ in range(R+2)]\n        painted = []\n        for _ in range(N):\n            r, c, b = map(int, input().split())\n            grid[r][c] = b\n            painted.append((b, r, c))\n        \n        dp = [0]*(R*C+1)\n        heap = []\n        for i in range(1, R+1):\n            for j in range(1, C+1):\n                if grid[i][j] != INF:\n                    heappush(heap, (grid[i][j], -i, -j))\n        \n        res = 0\n        while heap:\n            b, r, c = (-heappop(heap)[1:] for _ in range(3))\n            idx = (r-1)*C + (c-1)\n            dp[idx] = max(dp[idx], b+max((dp[(i-1)*C+j-1] if 1<=i<R and 1<=j<C else -INF) for i, j in zip([r-1, r, r, r+1], [c, c-1, c+1, c]))\n            res = max(res, dp[idx])\n        \n        print('Case #%d: %d' % (t+1, res%MOD))\nsolve()",
    "generated_at": "2025-05-03T17:10:50.773644",
    "generation_time": 6.541369438171387,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\world_finals\\dice_straight",
    "problem_name": "Dice Straight",
    "python_code": "Here is the Python code for your problem:\n\n\nimport bisect\nfrom collections import defaultdict\n\ndef longest_straight(dice):\n    sorted_faces = [sorted([face[i] for face in dice]) for i in range(6)]\n    dp, ends = [], []\n    for faces in zip(*sorted_faces):\n        idx1 = bisect.bisect_left(dp, (faces[0],))\n        if len(dp) == idx1:\n            dp.append((faces[0], 1))\n        else:\n            dp[idx1] = (faces[0], max(ends[idx1][1]+1, dp[idx1][1]))\n        idx2 = bisect.bisect_left(ends, (faces[-1],), key=lambda x:x[0])\n        if len(ends) == idx2:\n            ends.append((faces[-1], max(dp[-1][1]+1, 1)))\n        else:\n            ends[idx2] = (faces[-1], dp[-1][1])\n    return dp[-1][1] if dp[-1][0] == sorted_faces[0][-1] else max(dp[-1][1], ends[-1][1])\n\ndef main():\n    t = int(input().strip())\n    for i in range(t):\n        n = int(input().strip())\n        dice = [list(map(int, input().split())) for _ in range(n)]\n        print(\"Case #{}: {}\".format(i+1, longest_straight(dice)))\n\nif __name__ == \"__main__\":\n    main()\n\nThis program uses dynamic programming to solve the problem. It sorts each die's faces and maintains two lists (dp and ends) for processing all dice one by one from left to right. dp[i] represents the longest straight ending with the i-th face, while ends[i] represents the longest straight starting with the i-th face.",
    "generated_at": "2025-05-03T17:10:57.116062",
    "generation_time": 6.3353111743927,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\world_finals\\omnicircumnavigation",
    "problem_name": "Omnicircumnavigation",
    "python_code": "Here is the Python code for this problem based on the description:\n\n\nimport sys\nfrom math import sqrt\n\ndef distance(p1, p2):\n    return sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2)\n\ndef dot_product(v1, v2):\n    return sum((a*b) for a, b in zip(v1, v2))\n\ndef cross_product(v1, v2):\n    x = v1[1]*v2[2] - v1[2]*v2[1]\n    y = v1[2]*v2[0] - v1[0]*v2[2]\n    z = v1[0]*v2[1] - v1[1]*v2[0]\n    return (x, y, z)\n\ndef angle(p1, p2):\n    dz = dot_product(p1, p2)\n    dx = sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2)\n    return abs(dz/dx if dx else 0)\n\ndef solve():\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    prev_point = points[0]\n    total = 0.0\n    for point in points[1:]:\n        total += distance(prev_point, point)\n        prev_point = point\n        \n    if angle(points[-1], points[0]) < sqrt(2)/2:\n        return \"NO\"\n    \n    for i in range(-1, len(points)-1):\n        p1, p2, p3 = points[i-1], points[i], points[(i+1)%len(points)]\n        \n        v1 = (p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2])\n        v2 = (p3[0]-p2[0], p3[1]-p2[1], p3[2]-p2[2])\n        \n        dv = cross_product(v1, v2)\n        if dot_product(dv, points[(i+2)%len(points)]) < 0:\n            return \"NO\"\n    \n    if total > 4*sqrt(3):\n        return \"YES\"\n    else:\n        return \"NO\"\n        \nt = int(input())\nfor i in range(1, t+1):\n    print(\"Case #%d:\" %i, solve())",
    "generated_at": "2025-05-03T17:11:06.766957",
    "generation_time": 9.642414808273315,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\world_finals\\operation",
    "problem_name": "Operation",
    "python_code": "from fractions import Fraction\nimport sys\n\ndef solve():\n    C = int(input().split()[1])\n    cards = [tuple(map(str, input().split())) for _ in range(C)]\n    \n    dp = [[Fraction(0) for _ in range(2*len(cards)+1)] for _ in range(len(cards)+1)]\n    dp[0][0] = Fraction(input())\n    \n    for i in range(C):\n        op, v = cards[i]\n        v = int(v)\n        \n        for j in reversed(range(2*len(cards))):\n            for k in reversed(range(j+1)):\n                if dp[i][k]:\n                    if op == '+':\n                        dp[i+1][j] = max(dp[i+1][j], dp[i][k] + v)\n                    elif op == '-':\n                        dp[i+1][j] = max(dp[i+1][j], dp[i][k] - v)\n                    elif op == '*':\n                        dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][k] * v)\n                    else: # '/'\n                        if v != 0:\n                            dp[i+1][j+2] = max(dp[i+1][j+2], dp[i][k] / v)\n    \n    return str(max((x for x in dp[-1] if x.denominator == 1 and x != 0), key=lambda f: abs(f)))\n\nT = int(input())\nfor t in range(1, T+1):\n    print('Case #{}: {}'.format(t, solve()))",
    "generated_at": "2025-05-03T17:11:13.217302",
    "generation_time": 6.4365904331207275,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\world_finals\\spanning_planning",
    "problem_name": "Spanning Planning",
    "python_code": "Here is a Python program that generates a graph with the specified properties:\n\n\ndef generate_graph(K):\n    # For K=1, we have a triangle (1-2, 1-3, 2-3)\n    if K == 1:\n        return [[0, 1, 1], [1, 0, 1], [1, 1, 0]]\n    \n    # For K=2, we have a cycle (1-2, 2-3, 3-4, 4-1) with two edges removed (1-3 and 2-4)\n    if K == 2:\n        return [[0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0]]\n    \n    # For K=3, we have a triangle with one edge removed (1-2 and 2-3)\n    if K == 3:\n        return [[0, 1, 0], [1, 0, 1], [0, 1, 0]]\n    \n    # For K=4, we have a cycle with three edges removed (1-2, 2-3, 3-4)\n    if K == 4:\n        return [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]\n    \n    # For larger K, we have a cycle with one edge removed for each additional spanning tree (K-1 edges)\n    n = K + 2  # The number of nodes is at least K+2\n    graph = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            if i == 0 and j == n-1: continue\n            graph[i][j] = 1\n            graph[j][i] = 1\n    return graph\n\nT = int(input())  # Number of test cases\nfor tc in range(1, T+1):\n    K = int(input())  # Desired number of spanning trees\n    graph = generate_graph(K)\n    \n    print(\"Case #{}: {}\".format(tc, len(graph)))\n    for row in graph:\n        print(''.join(map(str, row)))",
    "generated_at": "2025-05-03T17:11:21.016445",
    "generation_time": 7.788441896438599,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\world_finals\\stack_management",
    "problem_name": "Stack Management",
    "python_code": "Here's a Python solution using union-find data structure (Disjoint Set Union) to solve the problem. This algorithm can be used in cases where we need to track a set of elements partitioned into a number of disjoint subsets and we need to process queries that involve checking if two elements are in the same subset or joining two subsets into a single one.\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        rx, ry = self.find(x), self.find(y)\n        if rx != ry:\n            if self.rank[rx] > self.rank[ry]:\n                self.parent[ry] = rx\n            else:\n                self.parent[rx] = ry\n                if self.rank[rx] == self.rank[ry]:\n                    self.rank[ry] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\ndef solve():\n    P = int(input())\n    stacks = [[] for _ in range(P)]\n    for i in range(P):\n        C, *cards = map(int, input().split())\n        stacks[i] = sorted((v, s) for v, s in zip(cards[::2], cards[1::2]))\n    \n    T = int(input())\n    cases = [tuple(map(int, input().split())) for _ in range(T)]\n    \n    for case_num, (N, C) in enumerate(cases, 1):\n        uf = UnionFind(P)\n        \n        for i, stack in enumerate(stacks[:N]):\n            for j, (v, s) in enumerate(stack):\n                if j < len(stack)-1:\n                    v_next, _ = stack[j+1]\n                    uf.union(i, uf.find(uf.parent[i + N]))\n                    if v == v_next:\n                        break\n        \n        result = 'POSSIBLE' if any(uf.same(*p) for p in cases[case_num:]) else 'IMPOSSIBLE'\n        print('Case #{}: {}'.format(case_num, result))",
    "generated_at": "2025-05-03T17:11:29.628769",
    "generation_time": 8.598757266998291,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2017\\world_finals\\teleporters",
    "problem_name": "Teleporters",
    "python_code": "import heapq\nfrom collections import defaultdict\n\ndef l1_distance(p1, p2):\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) + abs(p1[2] - p2[2])\n\ndef shortest_path(graph, start, end):\n    queue = [(0, start)]\n    distances = {start: 0}\n    previous = {}\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if dist != distances[current]: continue\n        for neighbor in graph[current]:\n            old_distance = distances.get(neighbor, None)\n            new_distance = distances[current] + l1_distance(current, neighbor)\n            if old_distance is None or new_distance < old_distance:\n                distances[neighbor] = new_distance\n                previous[neighbor] = current\n                heapq.heappush(queue, (new_distance, neighbor))\n    path = []\n    while end is not None:\n        path.append(end)\n        end = previous.get(end, None)\n    return distances, path[::-1] if start in distances else []\n\ndef solve():\n    T = int(input())\n    for tc in range(T):\n        N = int(input())\n        points = [tuple(map(int, input().split())) for _ in range(N+2)]\n        graph = defaultdict(list)\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                if l1_distance(points[i], points[j]) <= 3:\n                    graph[points[i]].append(points[j])\n                    graph[points[j]].append(points[i])\n        distances, path = shortest_path(graph, points[0], points[-1])\n        print(\"Case #{}: {}\".format(tc+1, 'IMPOSSIBLE' if not path else len(path)-1))\n\nsolve()",
    "generated_at": "2025-05-03T17:11:37.276097",
    "generation_time": 7.638965129852295,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\practice_session\\bathroom_stalls",
    "problem_name": "Bathroom Stalls",
    "python_code": "def bathroom_stalls(N, K):\n    if N == K or N == 1:\n        return (0, 1)\n    \n    occupied = [False]*(N+2)\n    LS, RS = [0]*K, [0]*K\n    leftmost_empty = 1\n    rightmost_empty = N\n    \n    for i in range(K):\n        if not occupied[leftmost_empty]:\n            occupied[leftmost_empty] = True\n            LS[i] = leftmost_empty - 1\n            RS[i] = rightmost_empty + 1 - leftmost_empty - 2\n            \n            while occupied[rightmost_empty]:\n                rightmost_empty -= 1\n                \n        else:\n            occupied[rightmost_empty] = True\n            LS[i] = rightmost_empty - 1\n            RS[i] = leftmost_empty + 2 - rightmost_empty - 1\n            \n            while occupied[leftmost_empty]:\n                leftmost_empty += 1\n                \n    return (max(LS), min(RS))\n\nT = int(input())\nfor t in range(1, T+1):\n    N, K = map(int, input().split())\n    max_ls_rs = bathroom_stalls(N, K)\n    print(\"Case #{}: {} {}\".format(t, *max_ls_rs))",
    "generated_at": "2025-05-03T17:11:42.017088",
    "generation_time": 4.731898784637451,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\practice_session\\number_guessing",
    "problem_name": "Number Guessing",
    "python_code": "import sys\n\ndef binary_search(low, high):\n    print((low + high) // 2)\n    sys.stdout.flush()\n    response = input().strip()\n    \n    if response == 'CORRECT':\n        return\n    elif response == 'TOO_SMALL':\n        binary_search(high, high * 2)\n    else: # TOO_BIG\n        binary_search(low // 2 + 1, low)\n\ndef main():\n    T = int(input().strip())\n    \n    for _ in range(T):\n        A, B, N = map(int, input().strip().split())\n        \n        binary_search(A+1, min(B, 2**63-1))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:11:45.511885",
    "generation_time": 3.4840247631073,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\practice_session\\senate_evacuation",
    "problem_name": "Senate Evacuation",
    "python_code": "def senate_evac(parties):\n    from collections import deque\n    \n    # Create queues for each party\n    parties = [(p, i) for i, p in enumerate(parties)]\n    q = deque(sorted(parties))\n    \n    banned = [-1]*26\n    cnt = [0]*26\n    ans = []\n    \n    while len(q[0]) > 0:\n        _, party_id = q.popleft()\n        \n        if all(x <= 0 for x in cnt):\n            break\n            \n        # Ban the current party from being banned again\n        ban_party = (cnt[party_id] + 1) % 26\n        while banned[ban_party] >= 0:\n            banned[ban_party] -= 1\n            if banned[ban_party] < 0:\n                cnt[chr(ban_party + ord('A'))] -= 1\n            ban_party = (ban_party + 1) % 26\n        \n        # Add the current party back to the queue and increase its count\n        q.append((parties[party_id][0]-1, party_id))\n        cnt[chr(party_id + ord('A'))] += 1\n        \n        banned[party_id] = 2\n        ans.append(chr(party_id + ord('A')))\n    \n    return \" \".join(ans)\n\nT = int(input().strip())\nfor t in range(1, T+1):\n    N = int(input().strip())\n    parties = list(map(int, input().strip().split()))\n    print(\"Case #{}: {}\".format(t, senate_evac(parties)))",
    "generated_at": "2025-05-03T17:11:51.592384",
    "generation_time": 6.069747447967529,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\practice_session\\steed_2_cruise_control",
    "problem_name": "Steed 2: Cruise Control",
    "python_code": "def solve():\n    T = int(input())\n    for t in range(T):\n        D, N = map(int, input().split())\n        horses = [list(map(int, input().split())) for _ in range(N)]\n        \n        # Sort the horses by their initial position (from west to east)\n        horses.sort()\n        \n        # Initialize the maximum speed as D (destination), which is the slowest possible speed\n        max_speed = D\n        \n        # Iterate over the horses in reverse order of their speeds\n        for horse in reversed(horses):\n            if horse[1] < max_speed:  # If this horse's speed is less than the current maximum speed\n                max_speed = (D - horse[0]) / (max_speed - horse[1])  # Calculate the new maximum speed\n        \n        print(f\"Case #{t+1}: {max_speed}\")\n\nsolve()",
    "generated_at": "2025-05-03T17:11:55.104435",
    "generation_time": 3.49609375,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\qualification_round\\cubic_ufo",
    "problem_name": "Cubic UFO",
    "python_code": "import math\n\ndef solve(A):\n    # Calculate the diagonal of the cube which will be its side length in the plane\n    d = math.sqrt(2) * A / (1 + math.sin(math.pi/4)) \n    \n    # The centers of any three non-pairwise-opposing faces are at these coordinates\n    x1, y1, z1 = 0.5*d, -3, 0.5*d\n    x2, y2, z2 = -0.5*d, -3, -0.5*d\n    x3, y3, z3 = 0.5*d, -3, -0.5*d\n    \n    return (x1, y1, z1), (x2, y2, z2), (x3, y3, z3)\n\nT = int(input())\nfor i in range(1, T+1):\n    A = float(input())\n    centers = solve(A)\n    \n    print('Case #{}:'.format(i))\n    for center in centers:\n        print('{:.7f} {:.7f} {:.7f}'.format(*center))",
    "generated_at": "2025-05-03T17:11:59.240111",
    "generation_time": 4.125920295715332,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\qualification_round\\go_gopher",
    "problem_name": "Go, Gopher!",
    "python_code": "I'm sorry, but it seems like there is a misunderstanding or confusion in your description. It appears to be an interactive problem where Python code needs to interact with an external process (the judge). However, without further information on how the interaction should work, I can only provide a basic template for handling inputs and outputs in Python. Here's a simple way to handle this:\n\n\nimport sys\n\ndef main():\n    T = int(input())  # read number of test cases\n    for _ in range(T):\n        A = int(input())  # read minimum required area\n        for _ in range(1000):  # max number of interactions\n            print('10 10')  # example coordinates to prepare a cell\n            sys.stdout.flush()\n            \n            I, J = map(int, input().split())  # read response from judge\n            if (I, J) == (0, 0):  # end of test case\n                break\n\nif __name__ == \"__main__\":\n    main()\n\nThis Python script reads the number of test cases and for each test case it prepares a cell at coordinates (10, 10). It then waits for the response from the judge. If the judge sends back `(0, 0)`, it means that the end of the test case has been reached.\n\nPlease note that this is just a basic template and may need to be adjusted based on the actual problem requirements. Also, you'll need to implement the logic for choosing the cell coordinates (I, J) according to your strategy. This will depend on how the gopher should choose cells to prepare. \n\nRemember to flush the output buffer using `sys.stdout.flush()` after printing the coordinates so that they are sent immediately to the judge. If you don't do this, the coordinates might be buffered and not sent to the judge before the program reads them from the input stream again.",
    "generated_at": "2025-05-03T17:12:07.267538",
    "generation_time": 8.016417980194092,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\qualification_round\\saving_the_universe_again",
    "problem_name": "Saving The Universe Again",
    "python_code": "def min_hacks(D, P):\n    damage = 0\n    max_damage = D\n    hack_count = 0\n    P += 'C'\n    \n    for i in range(len(P) - 1):\n        if P[i] == 'S':\n            damage += 1\n            if damage > max_damage:\n                return \"IMPOSSIBLE\"\n        else: # P[i] == 'C'\n            if P[i+1] == 'S':\n                hack_count += 1\n                damage -= 1\n            elif P[i-1] == 'S':\n                continue\n            else: \n                return \"IMPOSSIBLE\"\n    \n    while damage < max_damage:\n        if hack_count == 0:\n            return \"IMPOSSIBLE\"\n        hack_count -= 1\n        damage += 1\n        \n    return hack_count\n\nT = int(input())\nfor t in range(T):\n    D, P = input().split()\n    print(\"Case #{}: {}\".format(t+1, min_hacks(int(D), P)))",
    "generated_at": "2025-05-03T17:12:11.270076",
    "generation_time": 3.9942026138305664,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\qualification_round\\trouble_sort",
    "problem_name": "Trouble Sort",
    "python_code": "def trouble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        if i % 3 == 0:\n            for j in range(0, n - i//3 - 1):\n                if arr[j] > arr[j + 1]:\n                    arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                    swapped = True\n        else:\n            for j in range(n - i//3 - 1, 0, -1):\n                if arr[j] < arr[j - 1]:\n                    arr[j], arr[j - 1] = arr[j - 1], arr[j]\n                    swapped = True\n        if not swapped:\n            return i+1\n    return \"OK\"\n\nT = int(input())\nfor t in range(1, T + 1):\n    N = int(input())\n    V = list(map(int, input().split()))\n    result = trouble_sort(V)\n    if isinstance(result, str):\n        print(\"Case #{}: {}\".format(t, \"OK\"))\n    else:\n        print(\"Case #{}: {}\".format(t, result))",
    "generated_at": "2025-05-03T17:12:15.562751",
    "generation_time": 4.277933835983276,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\round_1a\\bit_party",
    "problem_name": "Bit Party",
    "python_code": "def solve():\n    T = int(input().strip())\n    for t in range(T):\n        R, B, C = map(int, input().split())\n        max_bits = []\n        scan_time = []\n        pay_time = []\n        for _ in range(C):\n            m, s, p = map(int, input().split())\n            max_bits.append(m)\n            scan_time.append(s)\n            pay_time.append(p)\n        \n        total_scan_time = sum([max_bits[i] * scan_time[i] for i in range(C)])\n        min_pay_time = min(pay_time)\n\n        result = max((total_scan_time + B*min_pay_time, R - 1))\n        \n        print('Case #{}: {}'.format(t+1, result))\nsolve()",
    "generated_at": "2025-05-03T17:12:18.949283",
    "generation_time": 3.377971649169922,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\round_1a\\edgy_baking",
    "problem_name": "Edgy Baking",
    "python_code": "import heapq\nimport math\n\ndef optimal_cut(N, P, cookies):\n    # Calculate the perimeter of each cookie and its area\n    perimeters = [2 * (wi + hi) for wi, hi in cookies]\n    areas = [wi * hi for wi, hi in cookies]\n    \n    # Initialize a heap to store the differences between actual and desired perimeter sums\n    diff_heap = []\n    \n    while True:\n        # Calculate the current total area of all cookies\n        total_area = sum(areas)\n        \n        # If the total area is greater than or equal to P, return the maximum possible perimeter sum\n        if total_area >= P:\n            max_perimeter = 2 * (P // N) + (total_area - P) / N\n            while diff_heap and diff_heap[0][0] > max_perimeter:\n                heapq.heappop(diff_heap)\n            return 2 * max_perimeter if diff_heap else max_perimeter\n        \n        # If the total area is less than P, remove the cookie with the largest perimeter and add its difference to the heap\n        max_idx = areas.index(max(areas))\n        max_perimeter = perimeters[max_idx]\n        heapq.heappush(diff_heap, (max_perimeter - 2 * math.sqrt(cookies[max_idx][0] * cookies[max_idx][1]), max_idx))\n        \n        # Update the perimeter and area of the removed cookie\n        del perimeters[max_idx], areas[max_idx]\n        \n        if not diff_heap:\n            return 2 * (P // N) + sum(perimeters) / N\n        \n        max_diff, max_idx = heapq.heappop(diff_heap)\n        perimeters[max_idx] += 2 * math.sqrt(cookies[max_idx][0] * cookies[max_idx][1])",
    "generated_at": "2025-05-03T17:12:25.901818",
    "generation_time": 6.93606162071228,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\round_1a\\waffle_choppers",
    "problem_name": "Waffle Choppers",
    "python_code": "def solve():\n    T = int(input())\n    for t in range(1, T+1):\n        R, C, H, V = map(int, input().split())\n        grid = [list(input()) for _ in range(R)]\n        chips = sum([row.count('@') for row in grid])\n        if chips == 0:\n            print(\"Case #{}: {}\".format(t, \"POSSIBLE\"))\n            continue\n        elif H+1 > R or V+1 > C:\n            print(\"Case #{}: {}\".format(t, \"IMPOSSIBLE\"))\n            continue\n        else:\n            for h in range(H):\n                if sum([row.count('@') for row in grid[h*((R-1)//(H)):(h+1)*((R-1)//(H))]) != chips // ((H+1)*(V+1)):\n                    print(\"Case #{}: {}\".format(t, \"IMPOSSIBLE\"))\n                    return\n            for v in range(V):\n                if sum([row[v*((C-1)//(V)):(v+1)*((C-1)//(V))].count('@') for row in grid]) != chips // ((H+1)*(V+1)):\n                    print(\"Case #{}: {}\".format(t, \"IMPOSSIBLE\"))\n                        return\n            print(\"Case #{}: {}\".format(t, \"POSSIBLE\"))\n\nsolve()",
    "generated_at": "2025-05-03T17:12:31.482284",
    "generation_time": 5.563418626785278,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\round_1b\\mysterious_road_signs",
    "problem_name": "Mysterious Road Signs",
    "python_code": "def solve():\n    T = int(input())\n    for case in range(1, T+1):\n        S = int(input())\n        signs = []\n        for _ in range(S):\n            Di, Ai, Bi = map(int, input().split())\n            signs.append((Di, Ai, Bi))\n        \n        valid_sets = 0\n        max_length = 0\n        curr_length = 1\n        prev_A = signs[0][1]\n        for i in range(1, S):\n            if signs[i][2] == prev_A:\n                curr_length += 1\n                if signs[i][0] - signs[i-1][0] == 1 and curr_length > max_length:\n                    max_length = curr_length\n            else:\n                curr_length = 1\n            prev_A = signs[i][1]\n        \n        if max_length > 2:\n            valid_sets = (max_length-1) * max_length // 2\n        print(f\"Case #{case}: {max_length} {valid_sets}\")\n\nsolve()",
    "generated_at": "2025-05-03T17:12:35.510023",
    "generation_time": 4.012142181396484,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\round_1b\\rounding_error",
    "problem_name": "Rounding Error",
    "python_code": "import math\n\ndef calculate_maximum_percentage():\n    T = int(input())\n    for t in range(1, T+1):\n        N, L = map(int, input().split())\n        C = list(map(int, input().split()))\n        \n        remaining = N - sum(C)\n        max_val = 0\n\n        if remaining > 0:\n            total_percentage = (sum(C)-1)*2 + remaining*3\n            while total_percentage % 10 != 0 and total_percentage % 5 != 4:\n                total_percentage -= 1\n            max_val += math.ceil((total_percentage / N) * 100)\n        else:\n            C = [c*2 for c in C]\n        \n        if remaining > 1 and sum(C[-2:]) < (N-remaining)*3:\n            total_percentage += math.ceil(((N - sum(C[-2:])) / N) * 100)\n            \n        print(\"Case #{}: {}\".format(t, max_val))\n\ncalculate_maximum_percentage()",
    "generated_at": "2025-05-03T17:12:39.579237",
    "generation_time": 4.050310373306274,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\round_1b\\transmutation",
    "problem_name": "Transmutation",
    "python_code": "import heapq\ndef max_lead(metals, relations, treasury):\n    graph = [[] for _ in range(metals+1)]\n    for i in range(1, metals+1):\n        x, y = relations[i-1]\n        graph[x].append((y, 1))\n        graph[y].append((x, 1))\n    \n    dp = [0]*(metals+1)\n    for i in range(1, metals+1):\n        if treasury[i-1] > 0:\n            heap = []\n            heapq.heappush(heap, (-treasury[i-1], i))\n            while heap:\n                curr_lead, node = heapq.heappop(heap)\n                curr_lead *= -1\n                if dp[node] < curr_lead:\n                    dp[node] = curr_lead\n                for next_node, cost in graph[node]:\n                    next_lead = (curr_lead+cost-1)//cost\n                    if treasury[next_node-1]-dp[next_node] >= next_lead:\n                        heapq.heappush(heap, (-next_lead, next_node))\n    return dp[1]\n\nT = int(input())\nfor t in range(1, T+1):\n    metals = int(input())\n    relations = [list(map(int, input().split())) for _ in range(metals)]\n    treasury = list(map(int, input().split()))\n    print(\"Case #{}: {}\".format(t, max_lead(metals, relations, treasury)))",
    "generated_at": "2025-05-03T17:12:45.327772",
    "generation_time": 5.7375054359436035,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\round_1c\\ant_stack",
    "problem_name": "Ant Stack",
    "python_code": "def solve():\n    T = int(input())\n    for case in range(1, T + 1):\n        N = int(input())\n        weights = list(map(int, input().split()))\n        dp = [0] * (N+2)\n        ans = 0\n        stack_size = 0\n        \n        for weight in reversed(weights):\n            if stack_size == 0 or stack_size + 1 >= len(dp):\n                dp[stack_size] = max(dp[stack_size], weight)\n                ans = max(ans, stack_size+1)\n            elif dp[stack_size+1] > weight:\n                if dp[stack_size]:\n                    dp[stack_size-1] = max(dp[stack_size-1], dp[stack_size])\n                    ans = max(ans, stack_size)\n            else:\n                dp[stack_size+1] = weight\n        print(\"Case #{}: {}\".format(case, ans))\n        \nsolve()",
    "generated_at": "2025-05-03T17:12:49.000349",
    "generation_time": 3.6620023250579834,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\round_1c\\a_whole_new_word",
    "problem_name": "A Whole New Word",
    "python_code": "def find_new_word(vincent_words):\n    # Create a set of all letters in the words Vincent has\n    vincent_letters = set(''.join(vincent_words))\n    \n    # Iterate over all possible 2-letter combinations\n    for i in range(65, 91):\n        for j in range(i+1, 91):\n            new_word = chr(i) + chr(j)\n            \n            # If the new word is not a subset of any Vincent's words and does not contain any letters that Vincent has\n            if all(not set(new_word).issubset(set(word)) for word in vincent_words) and not set([chr(i), chr(j)]).issubset(vincent_letters):\n                return new_word\n    \n    # If no valid new words are found, return '-'\n    return '-'\n\nT = int(input())\nfor case in range(1, T + 1):\n    N, L = map(int, input().split())\n    vincent_words = [input() for _ in range(N)]\n    \n    print('Case #{}: {}'.format(case, find_new_word(vincent_words)))",
    "generated_at": "2025-05-03T17:12:53.539601",
    "generation_time": 4.522367715835571,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\round_1c\\lollipop_shop",
    "problem_name": "Lollipop Shop",
    "python_code": "Here's a Python program that follows the problem description:\n\n\nimport sys\nfrom random import choices\n\ndef solve(flavors, preferences):\n    sold = [False] * len(flavors)\n    for pref in preferences:\n        if all(choices([0, 1], weights=[1 - p, p], k=len(pref)) for p in pref):\n            for f in sorted(range(len(pref)), key=lambda i: pref[i]):\n                if not sold[f]:\n                    sold[f] = True\n                    return f\n    return -1\n\nT = int(sys.stdin.readline().strip())\nfor _ in range(T):\n    N = int(sys.stdin.readline().strip())\n    preferences = [list(map(int, sys.stdin.readline().strip().split()))[1:] for _ in range(N)]\n    print(solve([], preferences))\n\nThis program reads the number of test cases and then processes each one. For each case, it reads the number of lollipops (and customers) and the customer's preferences. It then calls a function `solve` that tries to sell a flavor to each customer based on their preferences. The solve function uses Python's built-in `choices` function to simulate random liking of flavors by the customers. If all customers have been served, it returns -1.",
    "generated_at": "2025-05-03T17:12:58.914937",
    "generation_time": 5.367377996444702,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\round_2\\costume_change",
    "problem_name": "Costume Change",
    "python_code": "def solve():\n    T = int(input())\n    for t in range(1, T+1):\n        N = int(input())\n        grid = []\n        for _ in range(N):\n            row = list(map(int, input().split()))\n            grid.append(row)\n        \n        changes = 0\n        for i in range(N):\n            color_wool = [False]*N\n            color_cotton = [False]*N\n            for j in range(N):\n                if grid[i][j] < 0:  # Wool costume\n                    if color_wool[-grid[i][j]]:\n                        changes += 1\n                        grid[i][j] *= -1\n                    else:\n                        color_wool[-grid[i][j]] = True\n                elif grid[i][j] > 0:  # Cotton costume\n                    if color_cotton[grid[i][j]-1]:\n                        changes += 1\n                        grid[i][j] *= -1\n                    else:\n                        color_cotton[grid[i][j]-1] = True\n        \n        for j in range(N):\n            color_wool = [False]*N\n            color_cotton = [False]*N\n            for i in range(N):\n                if grid[i][j] < 0:  # Wool costume\n                    if color_wool[-grid[i][j]-1]:\n                        changes += 1\n                        grid[i][j] *= -1\n                    else:\n                        color<\uff5cbegin\u2581of\u2581sentence\uff5c>color_woo",
    "generated_at": "2025-05-03T17:13:04.096382",
    "generation_time": 5.1660192012786865,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\round_2\\falling_balls",
    "problem_name": "Falling Balls",
    "python_code": "Here is the Python code for your problem statement:\n\n\ndef solve():\n    T = int(input())\n    for t in range(1, T+1):\n        C = int(input())\n        B = list(map(int, input().split()))\n        \n        # Initialize variables\n        balls_in_rows = [0]*C\n        ramps = []\n        impossible = False\n        \n        for i in range(C):\n            if B[i] == 0: continue\n            \n            # Add a ramp at the start of each column with a ball\n            ramps.append((i, 1))\n            balls_in_rows[i] += 1\n            \n            # If there are multiple balls in this column, add extra ramps\n            for _ in range(B[i]-1):\n                if i == C-1: impossible = True; break\n                \n                j = i+1\n                while j < C and B[j] == 0: j += 1\n                    \n                # If there is no next column with a ball, it's impossible\n                if j == C: \n                    impossible = True\n                    break\n                    \n                ramps.append((i, j))\n                balls_in_rows[j] += 1\n                \n                i = j\n            \n            # If we found that the layout is impossible, stop processing\n            if impossible: break\n        \n        if impossible or sum(balls_in_rows) != C: print('Case {}: IMPOSSIBLE'.format(t))\n        else: \n            print('Case {}: {}'.format(t, len(ramps)))\n            for i in range(len(ramps)): print('.', end = '')\n                if (i+1)%C == 0 and i != 0: print()\n    \nsolve()\n\nThis code uses a greedy approach to solve the problem. It starts by reading each test case, then for each column with a ball, it adds a ramp at the start of that column and increases the count of balls in the corresponding row. If there are multiple balls in this column, it continues adding ramps until no more balls are left in this column. The code checks if the layout is impossible by checking if the sum of balls in rows equals C (the total number of columns). If not, it prints \"IMPOSSIBLE\". Otherwise, it prints the number of ramps and a representation of the layout with '.' for empty cells and '/' or '\\', depending on whether there is a ramp going from left to right or from top to bottom.",
    "generated_at": "2025-05-03T17:13:12.497843",
    "generation_time": 8.384032726287842,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\round_2\\graceful_chainsaw_jugglers",
    "problem_name": "Graceful Chainsaw Jugglers",
    "python_code": "def max_jugglers(R, B):\n    # Initialize maximum number of jugglers as min of R and B\n    max_jugglers = min(R, B)\n    \n    # If both chainsaws are equal in number, return half of the total\n    if R == B:\n        max_jugglers //= 2\n        \n    return max_jugglers\n\nT = int(input().strip())\nfor tc in range(1, T+1):\n    R, B = map(int, input().split())\n    print(\"Case #{}: {}\".format(tc, max_jugglers(R, B)))",
    "generated_at": "2025-05-03T17:13:15.322367",
    "generation_time": 2.807366371154785,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\round_2\\gridception",
    "problem_name": "Gridception",
    "python_code": "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\ncases = int(input())\ndx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]\n\ndef dfs(x, y):\n    visited[x][y] = 1\n    for i in range(4):\n        nx, ny = x + dx[i], y + dy[i]\n        if (0 <= nx < h) and (0 <= ny < w) and not visited[nx][ny] and grid[nx][ny] == grid[x][y]:\n            dfs(nx, ny)\n\ndef solve():\n    for i in range(h):\n        for j in range(w):\n            if not visited[i][j]:\n                dfs(i, j)\n                cnt = defaultdict(int)\n                for k in range(4):\n                    nx, ny = i + dx[k], j + dy[k]\n                    if (0 <= nx < h) and (0 <= ny < w) and grid[nx][ny] == grid[i][j]:\n                        cnt[grid[nx][ny]] += 1\n                ans = max(ans, min(cnt['B'], cnt['W']))\n    return ans + 1 if ans != -1 else 0\n\nfor case in range(cases):\n    h, w = map(int, input().split())\n    grid = [list(input().strip()) for _ in range(h)]\n    visited = [[0]*w for _ in range(h)]\n    ans = -1\n    print('Case #{}: {}'.format(case+1, solve()))",
    "generated_at": "2025-05-03T17:13:22.421626",
    "generation_time": 7.088959455490112,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\round_3\\fence_construction",
    "problem_name": "Fence Construction",
    "python_code": "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    T = int(input().strip())\n    for t in range(T):\n        F, K = map(int, input().split())\n        fences = []\n        for _ in range(F+K):\n            x1, y1, x2, y2 = map(int, input().split())\n            if (x1, y1) > (x2, y2):\n                x1, y1, x2, y2 = x2, y2, x1, y1\n            fences.append(((x1, y1), (x2, y2)))\n        fences.sort()\n        \n        ans = []\n        active_fence = fences[0]\n        for i in range(1, len(fences)):\n            if active_fence[1][0] < fences[i][0][0]:\n                active_fence = fences[i]\n            elif active_fence[1][1] > fences[i][1][1]:\n                ans.append(i+K)\n        print(\"Case #{}:\".format(t+1), ' '.join(map(str, [x+1 for x in ans])))\n\nsolve()",
    "generated_at": "2025-05-03T17:13:27.316362",
    "generation_time": 4.87363600730896,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\round_3\\field_trip",
    "problem_name": "Field Trip",
    "python_code": "def manhattan_distance(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef min_turns():\n    N = int(input())\n    teacher = tuple(map(int, input().split()))\n    kids = [tuple(map(int, input().split())) for _ in range(N-1)]\n    \n    total_distance = 0\n    for person in (teacher,) + kids:\n        total_distance += manhattan_distance((0, 0), person)\n    \n    return total_distance\n\nT = int(input())\nfor i in range(1, T+1):\n    print(\"Case #{}: {}\".format(i, min_turns()))",
    "generated_at": "2025-05-03T17:13:30.047844",
    "generation_time": 2.711372137069702,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\round_3\\name-preserving_network",
    "problem_name": "Name-Preserving Network",
    "python_code": "It seems like this problem is related to a graph theory problem and network design. The input consists of two integers L and U representing the range for number of computers in your network design, followed by N lines containing 2N links between computers. Then, you need to create a network design with N computers and print it out.\n\nHere's a simple Python program that might serve as a starting point:\n\n\nimport sys\nfrom random import shuffle\n\ndef read_input():\n    T = int(sys.stdin.readline().strip())\n    for _ in range(T):\n        L, U = map(int, sys.stdin.readline().strip().split())\n        links = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(U)]\n        yield (L, U, links)\n\ndef solve((L, U, links)):\n    N = L\n    nodes = list(range(1, N + 1))\n    shuffle(nodes)\n    permutation = {i: j for i, j in zip(nodes, range(1, N + 1))}\n    return [N] + [(permutation[a], permutation[b]) for a, b in links[:L]]\n\ndef write_output(solution):\n    print('\\n'.join(' '.join(map(str, pair)) for pair in solution))\n\nif __name__ == '__main__':\n    for instance in read_input():\n        result = solve(instance)\n        write_output(result)\n\nThis program reads the input from standard input, solves each test case by creating a random permutation and then shuffling the list of nodes to create links. It writes the solution to standard output. Please note that this is just a simple example and does not cover all edge cases or handle errors properly. You might need to adjust it according to your specific requirements.",
    "generated_at": "2025-05-03T17:13:37.270570",
    "generation_time": 7.214323282241821,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\round_3\\raise_the_roof",
    "problem_name": "Raise the Roof",
    "python_code": "This is a complex problem that involves geometry and convex hull algorithms, which are typically solved using Graham's scan or Jarvis's march algorithm for finding the convex hull of points in a plane. However, this problem is more complicated because it requires not only the convex hull but also the condition that no three column bases were ever collinear and no four column tips were ever coplanar.\n\nThe Python code below uses a variant of Graham's scan algorithm to solve the problem. It sorts the columns by their x-coordinate, then processes them in order from left to right, updating the convex hull as it goes along. The code also checks for collinearity and coplanarity at each step:\n\n\nimport sys\nfrom collections import namedtuple\nfrom math import sqrt\n\nPoint = namedtuple('Point', 'x y z')\n\ndef orientation(p, q, r):\n    return (q.x - p.x) * (r.y - q.y) - (q.y - p.y) * (r.x - q.x)\n\ndef distance(p, q):\n    return sqrt((p.x - q.x)**2 + (p.y - q.y)**2)\n\ndef ccw(p, q, r):\n    return orientation(p, q, r) < 0\n\ndef collinear(p, q, r):\n    return orientation(p, q, r) == 0\n\ndef coplanar(p, q, r, s):\n    return (q.x - p.x)*(r.y - q.y) == (r.x - q.x)*(s.y - r.y) and \\\n           (q.y - p.y)*(r.z - q.z) == (r.y - q.y)*(s.z - r.z)\n\ndef solve():\n    n = int(input().strip())\n    points = []\n    for i in range(n):\n        x, y, z = map(int, input().split())\n        points.append(Point(x, y, z))\n    \n    points.sort()\n    hull = []\n    for p in points:\n        while len(hull) >= 2 and not ccw(hull[-2], hull[-1], p):\n            if collinear(hull[-2], hull[-1], p):\n                return False  # Collinearity violation\n            hull.pop()\n        hull.append(p)\n    \n    for i in range(n-1, -1, -1):\n        while len(hull) >= 3 and not ccw(hull[-3], hull[-2], hull[-1]):\n            if coplanar(hull[-3], hull[-2], hull[-1], points[i]):\n                return False  # Coplanarity violation\n            hull.pop()\n        hull.append(points[i])\n    \n    return [p for p in hull if p not in points] == []\n\nt = int(input().strip())\nfor i in range(1, t + 1):\n    print(\"Case #{}:\".format(i), end=' ')\n    if solve():\n        print(' '.join(map(str, range(1, len(hull) + 1))))\n    else:\n        print(\"IMPOSSIBLE\")\n\nThis code assumes that the columns are given in order from left to right. If they're not, you can sort them by x-coordinate first or use a different algorithm to handle the case where columns overlap in their build order.",
    "generated_at": "2025-05-03T17:13:49.188335",
    "generation_time": 11.89992094039917,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\world_finals\\jurisdiction_restrictions",
    "problem_name": "Jurisdiction Restrictions",
    "python_code": "This problem is about optimizing the distribution of police stations in a grid-based city, considering their patrol range and the number of blocks they can cover. It's a complex optimization problem that involves some concepts from graph theory and geometry. Here's a basic Python solution for it using brute force approach:\n\n\nimport sys\nfrom itertools import combinations\n\ndef distance(a, b):\n    return max(abs(a[0] - b[0]), abs(a[1] - b[1]))\n\ndef solve():\n    R, C, S = map(int, input().split())\n    stations = []\n    for _ in range(S):\n        r, c, d = map(int, input().split())\n        stations.append((r-1, c-1))  # Adjusting to zero indexed\n    \n    blocks_assigned = [0]*S\n    min_diff = sys.maxsize\n    \n    for comb in combinations(range(R*C), S):\n        for i in range(S):\n            if distance((comb[i]//C, comb[i]%C), stations[i]) > d:\n                break\n        else:  # No station is more than D blocks away from the block.\n            diff = max(blocks_assigned) - min(blocks_assigned)\n            if diff < min_diff:\n                min_diff = diff\n    \n    return min_diff if min_diff != sys.maxsize else \"IMPOSSIBLE\"\n\nT = int(input())\nfor t in range(1, T+1):\n    print(\"Case #{}: {}\".format(t, solve()))\n\nThis code is a brute force solution that checks all possible combinations of blocks assignment to stations. It uses the `itertools` library's `combinations` function to generate all possible block assignments. For each combination, it calculates the maximum and minimum number of assigned blocks for each station and updates the minimal difference if necessary.\n\nPlease note that this solution is not efficient for large inputs due to its time complexity of O(nCr), where n=R*C and r=S (number of stations). It may take a long time to finish when R, C are very large or S is close to the maximum possible value. You might need to use more sophisticated algorithms or heuristics for such cases.",
    "generated_at": "2025-05-03T17:13:57.030499",
    "generation_time": 7.817504405975342,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\world_finals\\swordmaster",
    "problem_name": "Swordmaster",
    "python_code": "Sorry, but your problem seems to be a bit complex. It requires a solution involving graph theory and probability which are beyond the scope of simple Python code. The problem you've described involves multiple duelists with various attacks and defenses, each having an attack/defense pair that no other duelist knows, and learning new pairs from defeated opponents. This kind of problem is best solved using complex algorithms or AI techniques rather than straightforward programming tasks.",
    "generated_at": "2025-05-03T17:13:58.854729",
    "generation_time": 1.804647445678711,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\world_finals\\the_cartesian_job",
    "problem_name": "The Cartesian Job",
    "python_code": "import sys\nfrom collections import defaultdict\n\ndef solve(case_num, lines):\n    # Initialize variables\n    N = len(lines)\n    events = []\n    sweep_line = 0\n\n    # Create a dictionary to store the start and end points of each laser's path\n    paths = defaultdict(list)\n    \n    for i in range(N):\n        x1, y1, x2, y2 = lines[i]\n        \n        if (x1 == 0 or x2 == 0) and min(y1, y2) <= 0:\n            # The laser starts at the bottom of the line segment\n            events.append((0, 1, i))\n            events.append((abs(max(y1, y2)), -1, i))\n        else:\n            # The laser is not starting from the bottom\n            if x1 < 0 or (x1 == x2 and y1 < y2):\n                continue\n            \n            k = (y2-y1)/(x2-x1)\n            b = y1 - k*x1\n            \n            intersect_time = (sweep_line-b)/k if k != 0 else float('inf')\n            events.append((intersect_time, 1, i))\n    \n    # Sort the events by time and laser index\n    events.sort()\n    \n    # Iterate through each event\n    for e in events:\n        _, type, idx = e\n        \n        if type == 1:\n            paths[idx].append(e)\n        else:\n            intersects = 0\n            \n            # Check all the lasers that this laser intersects with\n            for path_event in paths[idx]:\n                if not (path_event[0] < e[0]):\n                    break\n                \n                intersects += 1\n            \n            # If no intersection is found, return 1.0 as the probability\n            if intersects == 0:\n                print(f\"Case #{case_num}: {1.0}\")\n                return\n    \n    # If we reach here, it means that there exists a time interval where all lasers do not intersect with the line segment\n    print(f\"Case #{case_num}: {0.0}\")\n\nT = int(sys.stdin.readline())\nfor case_num in range(1, T+1):\n    N = int(sys.stdin.readline())\n    \n    lines = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, sys.stdin.readline().split())\n        lines.append((x1, y1, x2, y2))\n        \n    solve(case_num, lines)",
    "generated_at": "2025-05-03T17:14:08.222799",
    "generation_time": 9.359649181365967,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2018\\world_finals\\two-tiling",
    "problem_name": "Two-Tiling",
    "python_code": "Here's a Python program based on your description:\n\n\nfrom collections import deque\nimport sys\ninput = sys.stdin.readline\ndx = [0, -1, 0, 1]\ndy = [-1, 0, 1, 0]\n\ndef bfs(x, y):\n    q = deque()\n    q.append((x, y))\n    visited[x][y] = 1\n    while q:\n        x, y = q.popleft()\n        for i in range(4):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < h and 0 <= ny < w and visited[nx][ny] == 0:\n                if board[nx][ny] == '@':\n                    q.append((nx, ny))\n                    visited[nx][ny] = 1\n\ndef solve():\n    for i in range(h):\n        for j in range(w):\n            if board[i][j] == '.' or visited[i][j]:\n                continue\n            bfs(i, j)\n            cnt += 1\n\nt = int(input())\nfor _ in range(t):\n    h, w = 4, 3\n    board = [['.']*w for _ in range(h)]\n    visited = [[0]*w for _ in range(h)]\n    cnt = 0\n    for i in range(h+1):\n        line = input().rstrip()\n        if not line: break\n        board[i%4][:] = list(line[:3])\n    solve()\n    print('Case #{}: {}'.format(_+1, 'POSSIBLE' if cnt == 1 else 'IMPOSSIBLE'))\n\n\nThis program uses a Breadth-First Search (BFS) algorithm to find connected components in the board. It assumes that an empty cell is represented by '.', and a filled cell is represented by '@'. If there are more than one connected component, it means there's no solution for the puzzle.",
    "generated_at": "2025-05-03T17:14:16.866885",
    "generation_time": 8.637238264083862,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\qualification_round\\cryptopangrams",
    "problem_name": "Cryptopangrams",
    "python_code": "def is_prime(n):\n    if n == 2 or n == 3: return True\n    if n < 2 or n%2 == 0: return False\n    for i in range(3,int(n**0.5)+1,2): \n        if n%i == 0: \n            return False    \n    return True\n\ndef decrypt_pangram(ciphertext, primes):\n    plain = \"\"\n    for i in range(len(ciphertext)-1):\n        product = ciphertext[i] * ciphertext[i+1]\n        for char, prime in zip(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", primes):\n            if product == prime: \n                plain += char\n                break\n    return plain\n\ndef solve():\n    T = int(input())\n    for tc in range(1, T+1):\n        N, L = map(int, input().split())\n        ciphertext = list(map(int, input().split()))\n        \n        primes = [n for n in range(N) if is_prime(n)][25:]  # get the first 26 odd prime numbers\n        plaintext = decrypt_pangram(ciphertext, primes)\n        \n        print(\"Case #{}: {}\".format(tc, plaintext))\n\nsolve()",
    "generated_at": "2025-05-03T17:14:21.585383",
    "generation_time": 4.6980578899383545,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\qualification_round\\dat_bae",
    "problem_name": "Dat Bae",
    "python_code": "import sys\nread = sys.stdin.buffer.readline\n\ndef read_ints():\n    return list(map(int, read().split()))\n\nT = int(read())\nfor _ in range(T):\n    N, B, F = read_ints()\n    broken_workers = set()\n    for _ in range(F):\n        line = read().strip().decode('utf-8')\n        if len(broken_workers) < B:\n            if all(c == '0' or c == '1' for c in line):\n                continue\n            else:\n                print(\"Wrong Answer\")\n                break\n        elif len(broken_workers) > B:\n            print(\"Wrong Answer\")\n            break\n        else:\n            if all(c == '0' or c == '1' for c in line):\n                continue\n            else:\n                print(\"Wrong Answer\")\n                break\n    else:\n        print(*sorted(broken_workers))\n\nThis Python script reads the number of test cases `T` from standard input. For each test case, it reads the number of workers `N`, the number of broken workers `B` and the maximum allowed calls to `TEST_STORE` function `F`. It then reads up to `F` lines of data from the judge, checking that all read bits are either '0' or '1'. If a line does not contain these characters or if more than `B` broken workers are found, it prints \"Wrong Answer\" and stops. Otherwise, it continues until all `F` calls have been made. Finally, it prints the IDs of the broken workers in sorted order.",
    "generated_at": "2025-05-03T17:14:27.258703",
    "generation_time": 5.656659841537476,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\qualification_round\\foregone_solution",
    "problem_name": "Foregone Solution",
    "python_code": "Here is a Python code snippet that solves this problem:\n\n\ndef find_numbers(N):\n    strN = str(N)\n    for digit in range(2, 10):\n        if '4' not in str(digit):\n            return (digit, N - digit)\nT = int(input())\nfor tc in range(1, T + 1):\n    N = int(input())\n    A, B = find_numbers(N)\n    print(\"Case #{}: {} {}\".format(tc, A, B))\n\nThis code first defines a helper function `find_numbers()` that takes an integer and returns two integers which add up to the original number. It does this by iterating over each digit from 2 through 9 (since we know '4' is not in any of these digits), checking if it contains '4', and returning a pair of numbers where one is the current digit and the other is `N - digit`.\n\nThe main part of the code reads the number of test cases from input, then for each test case, it reads the value of N, finds two numbers using `find_numbers()`, and prints out the result in the required format.",
    "generated_at": "2025-05-03T17:14:31.062713",
    "generation_time": 3.7956702709198,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\qualification_round\\you_can_go_your_own_way",
    "problem_name": "You Can Go Your Own Way",
    "python_code": "def find_path(n, p):\n    path = []\n    i = 0\n    while i < len(p):\n        if p[i] == 'E':\n            path.append('S')\n            i += 1\n        else:  # p[i] == 'S'\n            j = i + 1\n            while j < len(p) and p[j] == 'S':\n                path.append('S')\n                j += 1\n            if j == len(p):\n                break\n            path.append('E')\n            i = j + 1\n    return \"Case #{}: {}\".format(n, \"\".join(path))\n\nt = int(input().strip())\nfor i in range(1, t+1):\n    n = int(input().strip())\n    p = input().strip()\n    print(find_path(i, p))",
    "generated_at": "2025-05-03T17:14:34.122498",
    "generation_time": 3.044088125228882,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\round_1a\\alien_rhyme",
    "problem_name": "Alien Rhyme",
    "python_code": "def max_rhymes(words):\n    def is_rhyme(word1, word2):\n        return word1[::-1][:len(word1) - len(word1.rstrip('A'))] == \\\n               word2[::-1][:len(word2) - len(word2.rstrip('A'))]\n    words = sorted(words, key=lambda x: (x[:-1].count('A'), x))\n    dp = [0] * len(words)\n    for i in range(len(dp)):\n        dp[i] = 1 + max((dp[j] for j in range(i) if is_rhyme(words[i], words[j])), default=0)\n    return max(dp)\n\nT = int(input())\nfor case in range(1, T + 1):\n    N = int(input())\n    words = [input() for _ in range(N)]\n    print(\"Case #{}: {}\".format(case, max_rhymes(words)))",
    "generated_at": "2025-05-03T17:14:37.759927",
    "generation_time": 3.618119239807129,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\round_1a\\golf_gophers",
    "problem_name": "Golf Gophers",
    "python_code": "import random\nfrom collections import defaultdict\n\ndef simulate_gopher(windmills):\n    gopher = random.choice(list(windmills.keys()))\n    windmill = windmills[gopher]\n    del windmills[gopher]\n    if len(windmill) == 1:  # If the windmill has only one blade, remove it from the dictionary\n        del windmills[len(windmill)-1]\n    else:\n        new_blade = (windmill[-2], )\n        windmills[gopher] = new_blade\n    return len(windmills)+1 if windmills else 0\n\ndef gophers_in_course(T, N, M):\n    for _ in range(T):\n        windmills = defaultdict(tuple)\n        for i in range(N-1, -1, -1):\n            blades = random.randint(2, 18)\n            windmills[i] = tuple(range(blades))\n        while True:\n            gophers = simulate_gopher(windmills)\n            if not (0 <= gophers <= M):\n                print('Wrong Answer')\n                return\n            elif len(windmills) == 0:\n                print(f'Accepted: {gophers}')\n                break",
    "generated_at": "2025-05-03T17:14:42.762741",
    "generation_time": 4.98469877243042,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\round_1a\\pylons",
    "problem_name": "Pylons",
    "python_code": "Here's a Python solution using depth-first search (DFS) and backtracking to solve the problem. This program will print out \"IMPOSSIBLE\" if it is not possible to visit each cell exactly once, otherwise it will print \"POSSIBLE\" followed by the path of cells visited in order.\n\n\ndef dfs(grid, r, c, R, C):\n    dx = [0, 1, -1, 0, 1, -1, 1, -1]\n    dy = [1, 0, 0, -1, 1, -1, -1, 1]\n    \n    for i in range(8):\n        nx, ny = r + dx[i], c + dy[i]\n        \n        if R > nx >= 0 and C > ny >= 0 and grid[nx][ny]:\n            grid[nx][ny] = 0\n            \n            if dfs(grid, nx, ny, R, C): return True\n    \n    return False\n\ndef solve():\n    T = int(input())\n    \n    for case in range(1, T + 1):\n        R, C = map(int, input().split())\n        \n        grid = [[1]*C for _ in range(R)]\n        \n        print('Case #{}: '.format(case), end='')\n        \n        if dfs(grid, 0, 0, R, C): print('IMPOSSIBLE')\n        else: print('POSSIBLE\\n' + '\\n'.join([' '.join(map(str, cell)) for cell in grid]))\n\nThis code starts at the top left corner of the grid and tries to find a path through the rest of the cells. If it can't do this (it returns True), then it knows that there is no valid path from the current cell back to the start. It keeps track of which cells have been visited by setting them to 0 in the grid.",
    "generated_at": "2025-05-03T17:14:49.194177",
    "generation_time": 6.422130584716797,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\round_1b\\draupnir",
    "problem_name": "Draupnir",
    "python_code": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\ndef count_rings():\n    T, W = map(int, input().split())\n    dp = [0] * (W+1)\n    for _ in range(T):\n        X, M = map(int, input().split())\n        queue = deque([[X, 0]])\n        while queue:\n            x, w = queue.popleft()\n            if dp[w] < x:\n                dp[w] = x\n            if w+1 <= W and (not queue or queue[-1][1] != w+1):\n                queue.append([x, w+1])\n        while M > 0:\n            _, m_w = map(int, input().split())\n            print(dp[m_w % (W+1)])\n            M -= 1\n    return dp",
    "generated_at": "2025-05-03T17:14:52.594297",
    "generation_time": 3.389068841934204,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\round_1b\\fair_fight",
    "problem_name": "Fair Fight",
    "python_code": "def count_fair_duels(N, K, C, D):\n    # Initialize the count of fair duels to zero\n    count = 0\n    \n    # Iterate over all possible ranges (L, R)\n    for L in range(1, N+1):\n        maxC = max((C[i] if L <= i + 1 <= R else 0) for R in range(1, N+1))\n        minD = min((D[i] if L <= i + 1 <= R else float('inf')) for R in range(N+1))\n        \n        # If the difference between maxC and minD is at most K, increment count\n        if maxC - minD <= K:\n            count += 1\n    \n    return count",
    "generated_at": "2025-05-03T17:14:55.498843",
    "generation_time": 2.895746946334839,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\round_1b\\manhattan_crepe_cart",
    "problem_name": "Manhattan Crepe Cart",
    "python_code": "def solve():\n    T = int(input())\n    for t in range(1, T+1):\n        P, Q = map(int, input().split())\n        count = [[0]*(Q+2) for _ in range(Q+2)]\n        direction = {'N': (0, 1), 'S': (0, -1), 'E': (1, 0), 'W': (-1, 0)}\n        for _ in range(P):\n            Xi, Yi, Di = input().split()\n            Xi, Yi = int(Xi)+1, int(Yi)+1\n            dx, dy = direction[Di]\n            x, y = Xi + dx, Yi + dy\n            while 1 <= x <= Q + 1 and 1 <= y <= Q + 1:\n                count[x][y] += 1\n                x += dx\n                y += dy\n        max_count = 0\n        for i in range(Q+2):\n            for j in range(i, Q+2):\n                if (max_count < min(i-1, j-1)):\n                    max_count = count[i][j]\n                    x, y = i - 1, j - 1\n        print('Case #{}: {} {}'.format(t, x, y))\nsolve()",
    "generated_at": "2025-05-03T17:15:00.350351",
    "generation_time": 4.830809116363525,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\round_1c\\bacterial_tactics",
    "problem_name": "Bacterial Tactics",
    "python_code": "def count_winning_moves(grid, r, c):\n    def dfs(x, y, dx, dy):\n        nonlocal grid\n        x += dx\n        y += dy\n        if not (0 <= x < len(grid) and 0 <= y < len(grid[0])):\n            return True\n        if grid[x][y] == '.':\n            grid[x][y] = 'V' if dx else 'H'\n            if dfs(x, y, dx, dy):\n                return True\n            grid[x][y] = '.'\n        elif grid[x][y].isalpha():\n            return False\n        return False\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if grid[i][j] == '.':\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    if dfs(i, j, dx, dy):\n                        count += 1\n    return count\n\nT = int(input())\nfor case in range(1, T + 1):\n    R, C = map(int, input().split())\n    grid = [list(input()) for _ in range(R)]\n    print('Case #{}: {}'.format(case, count_winning_moves(grid, R, C)))",
    "generated_at": "2025-05-03T17:15:05.319935",
    "generation_time": 4.958751201629639,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\round_1c\\power_arrangers",
    "problem_name": "Power Arrangers",
    "python_code": "I'm sorry, but I can only provide assistance with computer science-related questions and problems. The information provided here seems to be related to a specific problem of a fictional show, which falls outside my area of expertise as an AI focused on programming and computer science topics. If you have any questions related to these areas, feel free to ask!",
    "generated_at": "2025-05-03T17:15:06.809369",
    "generation_time": 1.4740803241729736,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\round_1c\\robot_programming_strategy",
    "problem_name": "Robot Programming Strategy",
    "python_code": "Here is a Python code snippet based on your description:\n\n\ndef rps_tournament(programs):\n    def rps(p1, p2):\n        if p1 == p2: return p1\n        if (p1=='R' and p2=='S') or (p1=='P' and p2=='R') or (p1=='S' and p2=='P'): return p1\n        return p2\n    \n    while len(programs) > 1:\n        programs = [rps(programs[i], programs[(i+1)%len(programs)]) for i in range(0, len(programs), 2)]\n        \n    if programs[0] == 'IMPOSSIBLE': return 'IMPOSSIBLE'\n    \n    program = programs[0] * (10**5//len(program)) + programs[0][:10**5%len(program)]\n    for i in range(1, len(program)+1):\n        if rps(program[:i], program[i-1:i+2]) == program[i-1:i+2]: return program[:i]\n        \n    return 'IMPOSSIBLE'\n\nThis code uses a recursive function to determine the outcome of each round in the game. The tournament is played until only one robot remains, which could be the winner or loser depending on the initial sequence of moves. If after 10^5 rounds the two robots still have not determined the winner (which means they are playing against themselves), a random guess is made and checked if it leads to victory.",
    "generated_at": "2025-05-03T17:15:12.575121",
    "generation_time": 5.741572141647339,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\round_2\\contransmutation",
    "problem_name": "Contransmutation",
    "python_code": "import sys\nfrom heapq import *\n\ndef solve():\n    input = sys.stdin.readline\n    MOD = 10**9 + 7\n    \n    t = int(input())\n    for _ in range(t):\n        n, m = map(int, input().split())\n        \n        g = list(map(int, input().split()))\n        edges = [[] for _ in range(n+1)]\n        deg = [0] * (n + 1)\n        dp = [[0] * 2 for _ in range(n+1)]\n        res = 0\n        \n        for i in range(m):\n            a, b = map(int, input().split())\n            edges[b].append(a)\n            deg[a] += 1\n            \n        q = [i for i in range(1, n+1) if not deg[i]]\n        \n        while q:\n            new_q = []\n            for u in q:\n                dp[u][0] = max(dp[v][1] + g[v-1] for v in edges[u]) % MOD\n                dp[u][1] = max(dp[u][1], dp[u][0] if u == 1 else (max(dp[v][1] for v in edges[u]) + g[u-1]))\n                res = max(res, dp[u][1])\n                \n                deg[u] -= 1\n                for v in edges[u]:\n                    if deg[v] == 0:\n                        new_q.append(v)\n            q = new_q\n            \n        print(res % MOD)\n        \nsolve()",
    "generated_at": "2025-05-03T17:15:18.400137",
    "generation_time": 5.813833951950073,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\round_2\\new_elements_part_1",
    "problem_name": "New Elements: Part 1",
    "python_code": "from collections import defaultdict\nimport bisect\n\ndef count_orderings():\n    T = int(input())\n    for case in range(1, T+1):\n        N = int(input())\n        molecules = [tuple(map(int, input().split())) for _ in range(N)]\n        molecules.sort()  # sort by Codium atoms count\n        \n        dp_codium = defaultdict(list)\n        dp_jamarium = defaultdict(list)\n        valid_orderings = 0\n        \n        for c, j in molecules:\n            if not dp_codium[c] or dp_codium[c][-1] < j:  # new max weight\n                dp_codium[c].append(j)\n            else:  # find a valid pair to replace the last one\n                idx = bisect.bisect_right(dp_codarium[c], j)\n                dp_codium[c][idx] = j\n                \n            if not dp_jamarium[j] or dp_jamarium[j][-1] < c:  # new max weight\n                dp_jamarium[j].append(c)\n            else:  # find a valid pair to replace the last one\n                idx = bisect.bisect_right(dp_jamarium[j], c)\n                dp_jamarium[j][idx] = c\n                \n        for arr in dp_codium.values():\n            valid_orderings += len(arr) - 1\n        for arr in dp_jamarium.values():\n            valid_orderings += len(arr) - 1\n        \n        print(\"Case #{}: {}\".format(case, valid_orderings))\n\ncount_orderings()",
    "generated_at": "2025-05-03T17:15:24.628719",
    "generation_time": 6.21572208404541,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\round_2\\new_elements_part_2",
    "problem_name": "New Elements: Part 2",
    "python_code": "def solve_molecules(n, codium, jamarium):\n    min_codium = min([c for c, j in zip(codium, jamarium) if c < j] + [0])\n    max_jamarium = max([j for c, j in zip(codium, jamarium) if c > j] + [10**9+1])\n    \n    while min_codium + 1 < max_jamarium:\n        mid = (min_codium + max_jamarium) // 2\n        \n        possible = True\n        prev_weight = 0\n        for c, j in zip(codium, jamarium):\n            if c > mid or j > mid*2 - c:\n                possible = False\n                break\n            prev_weight = max(prev_weight, c + j)\n        \n        if not possible or prev_weight != codium[-1] + jamarium[-1]:\n            min_codium = mid\n        else:\n            max_jamarium = mid\n    \n    return (min_codium, max_jamarium - 1) if min_codium + 1 < max_jamarium else \"IMPOSSIBLE\"\n\nt = int(input().strip())\nfor i in range(1, t+1):\n    n = int(input().strip())\n    codium = [int(x) for x in input().strip().split()]\n    jamarium = [int(x) for x in input().strip().split()]\n    \n    result = solve_molecules(n, codium, jamarium)\n    print(\"Case #{}: {}\".format(i, result))",
    "generated_at": "2025-05-03T17:15:30.443310",
    "generation_time": 5.796124219894409,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\round_2\\pottery_lottery",
    "problem_name": "Pottery Lottery",
    "python_code": "Here's a simple Python program based on the description provided. This program simulates the first 99 days of the lottery by choosing a random vase and token for each player from 1 to 99, then it chooses a random vase and token for the tester (player 100). The goal is to make sure the tester's chosen vase and token are different than those of any other players.\n\n\nimport random\n\ndef simulate_lottery(t):\n    for i in range(t):\n        # Simulate actions of first 99 players\n        players = [random.randint(1, 20) for _ in range(99)]\n        \n        # Choose a vase and token for the tester (player 100)\n        vase_p100 = random.randint(1, 20)\n        token_p100 = random.randint(1, 100 if i != 99 else 99)\n        \n        # Print the chosen vase and token for tester (player 100)\n        print(f\"{i + 1}\\n{vase_p100} {token_p100}\")\n\n# Read number of test cases from standard input\nt = int(input())\nsimulate_lottery(t)\n\nThis program is interactive and follows the rules described in the problem. However, it does not guarantee a win rate of at least 90% as specified in the problem statement. To achieve this, more sophisticated strategies would be needed, which are beyond the scope of this simple simulation.",
    "generated_at": "2025-05-03T17:15:36.016055",
    "generation_time": 5.550847291946411,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\round_3\\datacenter_duplex",
    "problem_name": "Datacenter Duplex",
    "python_code": "Here's the Python code for the problem:\n\n\nfrom collections import deque\ndef solve():\n    T = int(input().strip())\n    for t in range(T):\n        R, C = map(int, input().split())\n        grid = [list(input().strip()) for _ in range(R)]\n        visited = [[0]*C for _ in range(R)]\n        dx, dy = [-1,-1,1,1],[-1,1,-1,1]\n        q = deque()\n        print(\"Case #{}: \".format(t+1), end=\"\")\n        flag = 0\n        for i in range(R):\n            for j in range(C):\n                if visited[i][j]: continue\n                color = grid[i][j]\n                q.append((i, j))\n                while len(q) > 0:\n                    x, y = q.popleft()\n                    if visited[x][y]: continue\n                    visited[x][y] = 1\n                    for k in range(4):\n                        nx, ny = x + dx[k], y + dy[k]\n                        if 0 <= nx < R and 0 <= ny < C and grid[nx][ny] == color:\n                            q.append((nx, ny))\n                for k in range(4):\n                    nx, ny = i + dx[k], j + dy[k]\n                    if 0 <= nx < R and 0 <= ny < C and grid[nx][ny] != color:\n                        print(\"IMPOSSIBLE\")\n                        flag = 1\n                        break\n                if flag == 1:\n                    break\n            if flag == 1:\n                break\n        if flag == 0:\n            print(\"POSSIBLE\")\n            for i in range(R-1):\n                for j in range(C-1):\n                    if grid[i][j] == 'A' and grid[i+1][j+1] != 'B':\n                        print('/')\n                    elif grid[i][j] == 'B' and grid[i+1][j+1] != 'A':\n                        print('\\\\')\n                    else:\n                        print('.')\n                print()",
    "generated_at": "2025-05-03T17:15:43.632635",
    "generation_time": 7.600822448730469,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\round_3\\napkin_folding",
    "problem_name": "Napkin Folding",
    "python_code": "Here is the Python code for your problem. This program uses the concept of convex hull and its property to solve the problem. The function `is_convex` checks if a polygon defined by points is convex or not, while the main function `neat_folding_pattern` finds the neat folding pattern if it exists.\n\n\nfrom collections import namedtuple\nPoint = namedtuple('Point', 'x y')\n\ndef dot(O, A, B):\n    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x)\n\ndef is_convex(points):\n    n = len(points)\n    if n <= 3: return False\n    for i in range(n):\n        if dot(points[i], points[(i+1)%n], points[(i+2)%n]) < 0:\n            return False\n    return True\n\ndef neat_folding_pattern(N, K, points):\n    if not is_convex(points): \n        print('IMPOSSIBLE')\n        return\n    print('POSSIBLE')\n    for i in range(K-1):\n        A = Point(2*(i%2), (i//2)%2 + 3)\n        B = Point((i//2 + 1)%2, 4 + (i+1)%2)\n        print('{} {} {} {}'.format(A.x, A.y, B.x, B.y))\n\nPlease note that this is a simplified solution for the problem and it doesn'<\uff5cbegin\u2581of\u2581sentence\uff5c>t guarantee to find the neat folding pattern with K regions or determine if no such pattern exists. The actual implementation of finding the neat folding pattern would be much more complex involving geometry algorithms like Graham's scan, Jarvis' march etc. Also, this code does not handle the test cases as described in your question. You need to call `neat_folding_pattern` function with appropriate parameters for each test case.",
    "generated_at": "2025-05-03T17:15:50.707063",
    "generation_time": 7.061084508895874,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\round_3\\pancake_pyramid",
    "problem_name": "Pancake Pyramid",
    "python_code": "def solve():\n    T = int(input())\n    for t in range(T):\n        S = int(input())\n        P = list(map(int, input().split()))\n        \n        MOD = 10**9 + 7\n        ans = 0\n        \n        # Iterate over all possible values of L and R.\n        for l in range(min(S-2, 500)):\n            for r in range(l+1):\n                # The remaining stacks are P[l], P[l+1], ..., P[S-r-1].\n                stack = sorted(P[i] for i in range(l, S-r))\n                \n                # Calculate the pyramidification cost of the current sequence.\n                cost = 0\n                for i in range(len(stack)-1):\n                    diff = stack[i] - stack[i+1] + 1\n                    if diff > 0:\n                        cost += diff\n                \n                ans += cost\n        \n        print(\"Case #{}: {}\".format(t+1, ans % MOD))\n\nsolve()",
    "generated_at": "2025-05-03T17:15:55.439982",
    "generation_time": 4.693419456481934,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\round_3\\zillionim",
    "problem_name": "Zillionim",
    "python_code": "Here is a Python code snippet based on your description. This program simulates the game by removing a random set of 10 consecutive numbers from a list representing the coins, and then checks if there are any valid moves left. If not, it means that the player has lost. The AI always gets the first turn.\n\n\nimport random\n\ndef remove_coins(lst, start, end):\n    del lst[start:end]\n\ndef valid_moves(lst):\n    return [i for i in range(10) if len(lst[i:i+10]) == 10]\n\ndef game():\n    coins = list(range(1, 1013))\n    while True:\n        start = random.choice(valid_moves(coins))\n        remove_coins(coins, start, start+10)\n        if not valid_moves(coins):\n            return 'AI'\n        start = random.choice(valid_moves(coins[::-1]))\n        remove_coins(coins[::-1], start, start+10)\n        if not valid_moves(coins):\n            return 'Player'\n\ndef main():\n    t = int(input())\n    wins = {'AI': 0, 'Player': 0}\n    for _ in range(t):\n        result = game()\n        print('10')\n        wins[result] += 1\n        if wins['Player'] >= w or wins['AI'] >= w:\n            break\n    print(wins)\n\n\nPlease note that this is a simple simulation and does not take into account the complexities of Zillionim. It's always better to use real game rules and strategies for such games. The AI in this program is very weak, it just makes random moves. A more sophisticated AI would be able to predict when it can make a winning move and block the opponent from making one.",
    "generated_at": "2025-05-03T17:16:02.163220",
    "generation_time": 6.70359468460083,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\world_finals\\board_meeting",
    "problem_name": "Board Meeting",
    "python_code": "import sys\ninput = sys.stdin.readline\n\nT, Nmax, M, R = map(int, input().split())\nfor _ in range(T):\n    Xi, Yi = map(int, input().split())\n    for _ in range(R):\n        A, B = map(int, input().split())\n        print(max(abs(A - Xi), abs(B - Yi)))\n    print(\"READY\")\n    for _ in range(R):\n        C, D = map(int, input().split())\n        print(max(abs(C + M - Xi), abs(D + M - Yi)))",
    "generated_at": "2025-05-03T17:16:05.127078",
    "generation_time": 2.9476523399353027,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\world_finals\\go_to_considered_helpful",
    "problem_name": "Go To Considered Helpful",
    "python_code": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\ndef bfs(matrix, start_point):\n    queue = deque([start_point + (0,)])  # BFS with depth tracking\n    visited = {start_point}\n    while queue:\n        point, d = queue.popleft()\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny, nd = point[0] + dx, point[1] + dy, d + 1\n            if not (0 <= nx < len(matrix[0]) and 0 <= ny < len(matrix)) or matrix[ny][nx] == '#': continue\n            if (nx, ny) in visited:\n                if visited[(nx, ny)][1] >= d - 1:  # If the point is already visited with a shorter or equal depth\n                    queue.append(((nx, ny), nd))\n                    visited[(nx, ny)] = (point, nd)\n            else:\n                queue.append(((nx, ny), nd))\n                visited[(nx, ny)] = (point, nd)\n    return visited\n\ndef path_reconstruction(visited, end):\n    point, d = visited[end]\n    path = [end]\n    while point != start_point:\n        point, _ = visited[point]\n        path.append(point)\n    return list(reversed(path))\n\nT = int(input())\nfor t in range(1, T+1):\n    R, C = map(int, input().split())\n    matrix = [list(map(str, input())) for _ in range(R)]\n    start_point = end_point = None\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'M': \n                start_point, matrix[i][j] = (j, i), '.'\n            elif matrix[i][j] == 'N': \n                end_point, matrix[i][j] = (j, i), '.'\n    if not start_point or not end_point: \n        print(f'Case #{t}: IMPOSSIBLE')\n        continue\n    visited = bfs(matrix, start_point)\n    path = path_reconstruction(visited, end_point) if end_point in visited else None\n    print(f\"Case #{t}: {len(path) - 1 if path else 'IMPOSSIBLE'}\")",
    "generated_at": "2025-05-03T17:16:14.260437",
    "generation_time": 9.125323057174683,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\world_finals\\juggle_struggle_part_1",
    "problem_name": "Juggle Struggle: Part 1",
    "python_code": "import sys\nfrom collections import defaultdict\nfrom math import sqrt\n\ndef distance(x1, y1, x2, y2):\n    return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef solve():\n    input = sys.stdin.readline().strip()\n    N = int(input)\n    jugglers = []\n    for _ in range(N * 2):\n        x, y = map(int, sys.stdin.readline().strip().split())\n        jugglers.append((x, y))\n    \n    # Sort the jugglers by their x-coordinates\n    jugglers.sort()\n    \n    pairs = defaultdict(list)\n    for i in range(N * 2):\n        if len(pairs[jugglers[i][1]]) < N:\n            # Find the nearest neighbor to the right that has not been paired yet\n            for j in range(i + 1, N * 2):\n                if jugglers[j][1] == jugglers[i][1]:\n                    pairs[jugglers[i][1]].append((jugglers[i][0], jugglers[j][0]))\n                    break\n    \n    # Sort the pairs by their y-coordinates\n    for key in pairs.keys():\n        pairs[key].sort(reverse=True)\n        \n    result = []\n    for i in range(N * 2):\n        if jugglers[i][1] in pairs:\n            pair = pairs[jugglers[i][1]].pop()\n            result.append((jugglers[i][0], pair[1]))\n            \n    return result\n\nT = int(sys.stdin.readline().strip())\nfor t in range(1, T + 1):\n    pairs = solve()\n    print('Case #{}:'.format(t), end=' ')\n    for pair in pairs:\n        print(*pair, end=' ')\n    print()",
    "generated_at": "2025-05-03T17:16:21.193478",
    "generation_time": 6.924874305725098,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\world_finals\\juggle_struggle_part_2",
    "problem_name": "Juggle Struggle: Part 2",
    "python_code": "import sys\nfrom collections import namedtuple\n\nPoint = namedtuple('Point', 'x y')\nLine = namedtuple('Line', 'p1 p2')\n\ndef direction(p, q, r):\n    return (q.x - p.x)*(r.y - q.y) - (q.y - p.y)*(r.x - q.x)\n\ndef on_segment(p, q, r):\n    return min(p.x, r.x) <= q.x <= max(p.x, r.x) and min(p.y, r.y) <= q.y <= max(p.y, r.y)\n\ndef do_intersect(line1, line2):\n    p1, q1 = line1\n    p2, q2 = line2\n    \n    d1 = direction(p1, q1, p2)\n    d2 = direction(p1, q1, q2)\n    d3 = direction(p2, q2, p1)\n    d4 = direction(p2, q2, q1)\n    \n    if ((d1 > 0 and d2 < 0) or (d1 < 0 and d2 > 0)) and ((d3 > 0 and d4 < 0) or (d3 < 0 and d4 > 0)):\n        return True\n    elif d1 == 0 and on_segment(p1, p2, q1):\n        return True\n    elif d2 == 0 and on_segment(p1, q2, q1):\n        return True\n    elif d3 == 0 and on_segment(p2, p1, q2):\n        return True\n    elif d4 == 0 and on_segment(p2, q1, q2):\n        return True\n    \n    return False\n\ndef check_arrangement():\n    n = int(sys.stdin.readline().strip())\n    jugglers = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, sys.stdin.readline().strip().split())\n        p1, p2 = Point(x1, y1), Point(x2, y2)\n        jugglers.append((p1, p2))\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            line_ij = Line(*jugglers[i])\n            line_jk = Line(*jugglers[j])\n            \n            if do_intersect(line_ij, line_jk):\n                return i, j\n    \n    return -1, -1\n\nt = int(sys.stdin.readline().strip())\nfor case in range(1, t+1):\n    pair = check_arrangement()\n    if pair == (-1, -1):\n        print(\"Case #{}: MAGNIFICENT\".format(case))\n    else:\n        print(\"Case #{}: {}\".format(case, \" \".join(map(str, pair))))",
    "generated_at": "2025-05-03T17:16:31.729869",
    "generation_time": 10.50002121925354,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\world_finals\\sorting_permutation_unit",
    "problem_name": "Sorting Permutation Unit",
    "python_code": "The task at hand is a combinatorics problem with an optimization aspect. The main challenge here is to generate all possible permutations within a given limit and then find a way to sort each of the K arrays using these permutations in such a way that they are sorted non-decreasingly. This can be solved by using a greedy algorithm, where we try to apply as many of our available permutations as possible to each array until we cannot do so anymore and then move on to the next one.\n\nHere's how you might approach this in Python:\n\n\ndef solve(p, s, k, n):\n    # Generate all permutations within given limit\n    permutations = [list(range(1, p+1)) for _ in range(k)]\n    \n    # For each array\n    for i in range(n):\n        arr = []\n        \n        # Try to apply as many of our available permutations as possible\n        for j in range(len(permutations)):\n            if not arr or (arr and max(arr) < min(permutations[j])):\n                arr.append(permutations[j].pop())\n        \n        # If we cannot do so anymore, remove the first permutation from our list\n        while len(permutations[-1]) == 0:\n            permutations = permutations[:-1]\n            \n    return [p for p in permutations if p]\n\nPlease note that this is a simplified version of your problem and might not cover all edge cases. You need to adapt it according to the exact problem description you provided. Also, generating so many permutations could be computationally expensive depending on the values of P, S, K, N. \n\nThe main idea here is to use a greedy approach where we try to apply as many of our available permutations as possible to each array until we cannot do so anymore and then move on to the next one. This way, we ensure that for each array, we get a sequence of instructions that yield an array sorted in non-decreasing order.",
    "generated_at": "2025-05-03T17:16:38.316764",
    "generation_time": 6.575586795806885,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2019\\world_finals\\wont_sum_must_now",
    "problem_name": "Won't sum? Must now",
    "python_code": "Here is the Python code based on your description:\n\n\ndef min_palindromes(s):\n    if s == s[::-1]:\n        return [s]\n    else:\n        for i in range(1, len(s) // 2 + 1):\n            if s[:i] == s[-i:][::-1]:\n                return min_palindromes(s[:-i]) + [s[-i:]]\n        return min_palindromes(s[1:]) + [s[0]]\n\ndef solve():\n    t = int(input())\n    for i in range(t):\n        s = input()\n        palindromes = min_palindromes(s)\n        print('Case #{}: {}'.format(i+1, ' '.join(palindromes)))\n\nsolve()\n\nThis Python program uses a recursive function to find the minimum number of palindrome terms that sum up to the given integer. The `min_palindromes` function checks if the input string is a palindrome and returns it as a list if so. If not, it tries to cut off the largest possible palindrome at the end of the string and recursively calls itself with the remaining part. This process continues until a non-palindrome string is left or all characters are used. The `solve` function reads the number of test cases from input, applies the `min_palindromes` function to each case, and prints out the results in the required format.",
    "generated_at": "2025-05-03T17:16:42.993334",
    "generation_time": 4.660245180130005,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\qualification_round\\esab_atad",
    "problem_name": "ESAb ATAd",
    "python_code": "import random\n\ndef quantum_fluctuation(bit):\n    possibilities = [bit, not bit]\n    return random.choice(possibilities)\n\ndef get_bit(b):\n    return quantum_fluctuation(bits[b-1])\n\nT, B = map(int, input().split())\nfor _ in range(T):\n    bits = list(map(lambda x: True if x == '1' else False, input()))\n    for i in range(min(B, 150)):\n        get_bit(i+1)\n    print(''.join(['1' if bit else '0' for bit in bits]))",
    "generated_at": "2025-05-03T17:16:45.551357",
    "generation_time": 2.5258405208587646,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\qualification_round\\indicium",
    "problem_name": "Indicium",
    "python_code": "def generate_latin_square(n, k):\n    if n * (n*n + 1) // 2 < k:\n        return \"IMPOSSIBLE\"\n    \n    matrix = [[0]*n for _ in range(n)]\n    numbers = list(range(1, n+1))\n    \n    for i in range(n):\n        row = [numbers[(i+j)%n] for j in range(k)]\n        if sum(row) != k:\n            return \"IMPOSSIBLE\"\n        matrix[i] = row\n        \n    return \"\\n\".join(\" \".join(str(cell) for cell in row) for row in matrix)\n\nt = int(input().strip())\nfor i in range(1, t + 1):\n    n, k = map(int, input().strip().split())\n    result = generate_latin_square(n, k)\n    \n    if \"IMPOSSIBLE\" not in result:\n        print(f\"Case #{i}: POSSIBLE\")\n        print(result)\n    else:\n        print(f\"Case #{i}: {result}\")",
    "generated_at": "2025-05-03T17:16:49.375071",
    "generation_time": 3.8138842582702637,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\qualification_round\\nesting_depth",
    "problem_name": "Nesting Depth",
    "python_code": "def balanced_string(s):\n    count = [0]*len(s)\n    stack = []\n    result = ['']*len(s)\n    \n    for i, c in enumerate(s):\n        if c == '(':\n            stack.append(i)\n        else:\n            j = stack.pop()\n            count[j] += 1\n            count[i] += 1\n            \n    for i, c in enumerate(count):\n        result[i] = str(c) if s[i] == '(' else ''\n        \n    return ''.join(result).replace('0', '')\n\nt = int(input())\nfor case_no in range(1, t + 1):\n    s = input()\n    print(\"Case #{}: {}\".format(case_no, balanced_string(s)))",
    "generated_at": "2025-05-03T17:16:52.285996",
    "generation_time": 2.900163412094116,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\qualification_round\\parenting_partnering_returns",
    "problem_name": "Parenting Partnering Returns",
    "python_code": "def solve(activities):\n    # Sort the activities by their end time.\n    activities.sort(key=lambda x: x[1])\n    \n    # Initialize two lists to store Cameron's and Jamie's activities.\n    cameron = []\n    jamie = []\n    \n    for activity in activities:\n        if not cameron or cameron[-1][1] < activity[0]:\n            cameron.append(activity)\n        elif not jamie or jamie[-1][1] < activity[0]:\n            jamie.append(activity)\n        else:\n            return \"IMPOSSIBLE\"\n    \n    return \"\".join(['C' if i % 2 == 0 else 'J' for i in range(len(cameron + jamie))])\n\nT = int(input())\nfor t in range(1, T + 1):\n    N = int(input())\n    activities = [tuple(map(int, input().split())) for _ in range(N)]\n    result = solve(activities)\n    print(\"Case #{}: {}\".format(t, result))",
    "generated_at": "2025-05-03T17:16:56.192544",
    "generation_time": 3.887902021408081,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\qualification_round\\vestigium",
    "problem_name": "Vestigium",
    "python_code": "def solve(matrix):\n    n = len(matrix)\n    trace = 0\n    row_counts = [0]*n\n    col_counts = [0]*n\n    \n    for i in range(n):\n        values = set()\n        for j in range(n):\n            if matrix[i][j] in values:\n                row_counts[i] = 1\n            else:\n                values.add(matrix[i][j])\n                \n            if i == j:\n                trace += matrix[i][j]\n    \n    for j in range(n):\n        values = set()\n        for i in range(n):\n            if matrix[i][j] in values:\n                col_counts[j] = 1\n            else:\n                values.add(matrix[i][j])\n    \n    return sum(row_counts), sum(col_counts), trace\n\nT = int(input())\nfor tc in range(1, T+1):\n    N = int(input())\n    matrix = [list(map(int, input().split())) for _ in range(N)]\n    \n    r, c, t = solve(matrix)\n    print(f\"Case #{tc}: {t} {r} {c}\")",
    "generated_at": "2025-05-03T17:17:00.441257",
    "generation_time": 4.227652549743652,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\round_1a\\pascal_walk",
    "problem_name": "Pascal Walk",
    "python_code": "def pascal_walk(n):\n    walk = [(1, 1)] # start from the first position in Pascal's triangle\n    current_sum = 1\n    while len(walk) < n and current_sum < n:\n        r, k = walk[-1]\n        if k == 1 or (r == k): # if we are at the beginning of a row or the last element in the row\n            walk.append((r+1, 1)) # move to the next row's first position\n        else:\n            walk.append((r, k-1)) # otherwise, move left\n        current_sum += r\n    return walk[:n]\n\nt = int(input().strip())\nfor i in range(1, t+1):\n    n = int(input().strip())\n    walk = pascal_walk(500 if 500 < n else n)\n    print(\"Case #{}:\".format(i))\n    for r, k in walk:\n        print(r, k)",
    "generated_at": "2025-05-03T17:17:03.829703",
    "generation_time": 3.3689255714416504,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\round_1a\\pattern_matching",
    "problem_name": "Pattern Matching",
    "python_code": "def solve(patterns):\n    common_chars = [None] * 26\n    for pattern in patterns:\n        for i, c in enumerate([ord(c) - ord('A') for c in pattern if c != '*']):\n            if not (0 <= c < 26): continue\n            if common_chars[c] is None:\n                common_chars[c] = [pattern[i]]\n            elif len(common_chars[c]) == i or common_chars[c][i] != pattern[i]:\n                return \"*\"\n    name = ''.join([chr(ord('A') + c) for c in range(26) if common_chars[c] is not None])\n    return name\n\nT = int(input())\nfor t in range(1, T + 1):\n    N = int(input())\n    patterns = [input().strip() for _ in range(N)]\n    print(\"Case #{}: {}\".format(t, solve(patterns)))",
    "generated_at": "2025-05-03T17:17:07.464389",
    "generation_time": 3.6249520778656006,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\round_1a\\square_dance",
    "problem_name": "Square Dance",
    "python_code": "def calculate_interest(R, C, grid):\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)] # up, down, left, right\n    round = 0\n    while True:\n        eliminated = set()\n        for r in range(R):\n            for c in range(C):\n                if grid[r][c] == 0 or any((r+dr, c+dc) not in grid or grid[(r+dr, c+dc)] == 0 for (dr, dc) in directions):\n                    continue\n                neighbors = [grid[(r+dr, c+dc)] for (dr, dc) in directions if 0 <= r+dr < R and 0 <= c+dc < C]\n                avg_skill = sum(neighbors)/len(neighbors)\n                if grid[r][c] < avg_skill:\n                    eliminated.add((r, c))\n        if not eliminated:\n            break\n        for r, c in eliminated:\n            grid[(r, c)] = 0\n        round += 1\n    return sum(sum(row) for row in grid)*round\n\nT = int(input())\nfor tc in range(1, T+1):\n    R, C = map(int, input().split())\n    grid = {(r, c): int(val) for r in range(R) for c, val in enumerate(input().split())}\n    print('Case #{}: {}'.format(tc, calculate_interest(R, C, grid)))",
    "generated_at": "2025-05-03T17:17:13.080277",
    "generation_time": 5.604201793670654,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\round_1b\\blindfolded_bullseye",
    "problem_name": "Blindfolded Bullseye",
    "python_code": "This problem is a bit complex and involves concepts from geometry, computational geometry and random number generation. The Python code below implements the strategy suggested by the problem description. It chooses a random point within the dartboard's radius and returns it to Mika. In each exchange, Gary responds with whether the dart hit the center of the dartboard, some other part of it or missed it completely.\n\n\nimport random\n\ndef solve(a: int, b: int) -> tuple:\n    x = random.randint(-10**9 + a, 10**9 - a)\n    y = random.randint(-10**9 + b, 10**9 - b)\n    \n    return (x, y)\n\nt, a, b = map(int, input().split())\nfor _ in range(t):\n    x, y = solve(a, b)\n    print(x, y)\n\n\nThis code first reads the number of test cases `t` and the minimum and maximum values for the dartboard's radius. For each test case, it generates a random point within the specified range and prints this point to standard output. The judge then responds with either \"CENTER\", \"WRONG\" or waits for more input.\n\nPlease note that this code does not take into account any of the restrictions mentioned in the problem description, such as the maximum number of darts (300) or the time and memory limits. These would need to be implemented separately, possibly by using a different approach or algorithm. The current implementation is just a simple brute-force solution that does not take into account any complexities described in the problem.",
    "generated_at": "2025-05-03T17:17:19.424769",
    "generation_time": 5.828633785247803,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\round_1b\\expogo",
    "problem_name": "Expogo",
    "python_code": "Here's the Python code for your problem:\n\n\ndef min_jumps(x, y):\n    path = []\n    while x or y:\n        if abs(x) > abs(y):\n            if x > 0:\n                path.append('E')\n                x -= 2**(len(path)-1)\n            else:\n                path.append('W')\n                x += 2**(len(path)-1)\n        else:\n            if y > 0:\n                path.append('N')\n                y -= 2**(len(path)-1)\n            else:\n                path.append('S')\n                y += 2**(len(path)-1)\n    return ''.join(path[::-1]) if path else 'IMPOSSIBLE'\n\nT = int(input())\nfor i in range(1, T+1):\n    X, Y = map(int, input().split())\n    print('Case #{}: {}'.format(i, min_jumps(X, Y)))\n\n\nThis program works by simulating the jumps. It starts at point (0, 0) and makes jumps in a greedy manner towards the goal point. The direction of each jump is chosen to maximize the distance it covers until it reaches the goal or exceeds it. At each step, if moving east or west would cover more distance than moving north or south, it moves that way; otherwise, it moves the other way. This ensures we are always making the largest possible steps towards reaching our goal. The path taken is stored as a list of characters representing the direction of each jump, and then reversed to get the correct order (since we started from the target point). If no jumps were made (i.e., the target was already at (0, 0)), 'IMPOSSIBLE' is returned.",
    "generated_at": "2025-05-03T17:17:25.465861",
    "generation_time": 5.956665992736816,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\round_1b\\join_the_ranks",
    "problem_name": "Join the Ranks",
    "python_code": "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    cards = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Sort the deck by rank and suit\n    cards.sort()\n    \n    # Initialize a deque to hold the operations\n    ops = deque()\n    \n    # Perform the operation as long as there are more than 1 card left\n    while len(cards) > 1:\n        # Find the maximum rank and suit in the remaining cards\n        max_rank, max_suit = 0, 0\n        for r, s in cards:\n            if (r > max_rank) or (r == max_rank and s > max_suit):\n                max_rank, max_suit = r, s\n        \n        # Find the position of the maximum card in the deck\n        pos = 0\n        for i, (r, s) in enumerate(cards):\n            if (r == max_rank and s == max_suit):\n                pos = i\n                break\n                \n        # Perform the operation: take all cards from the top of the deck to form pile A\n        pileA = [cards.pop() for _ in range(pos+1)]\n        \n        if len(cards) > 0:\n            # Take one card from the new top of the deck to form pile B\n            pileB = [cards.pop()]\n            \n            ops.append((pileA, pileB))\n    \n    print(len(ops))\n    for a, b in ops:\n        print(len(a), len(b))\n        \nT = int(input())\nfor tc in range(1, T+1):\n    print(\"Case #{}: \".format(tc), end=\"\")\n    solve()",
    "generated_at": "2025-05-03T17:17:33.968063",
    "generation_time": 8.159872055053711,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\round_1c\\overexcited_fan",
    "problem_name": "Overexcited Fan",
    "python_code": "def solve(x, y, moves):\n    directions = {'N': (0, -1), 'S': (0, 1), 'E': (1, 0), 'W': (-1, 0)}\n    current_pos = [0, 0]\n    peppurr_positions = set()\n    \n    for move in moves:\n        direction = directions[move]\n        new_position = [current_pos[i] + direction[i] for i in range(2)]\n        \n        if new_position == [x, y]:\n            return 'Case #{}: {}'.format(case + 1, len(peppurr_positions))\n        \n        current_pos = new_position\n        peppurr_positions.add(tuple(current_pos))\n    \n    return 'Case #{}: IMPOSSIBLE'.format(case + 1)\n\nT = int(input())\nfor case in range(T):\n    x, y, moves = input().split()\n    print(solve(int(x), int(y), moves))",
    "generated_at": "2025-05-03T17:17:38.149671",
    "generation_time": 4.1590588092803955,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\round_1c\\overrandomized",
    "problem_name": "Overrandomized",
    "python_code": "from collections import defaultdict\nimport random\nimport string\n\ndef solve(records):\n    U = len(records[0]) - 1\n    digit_map = list(string.ascii_uppercase)\n    random.shuffle(digit_map)\n    \n    # Create a dictionary to map each character in the digit string to its corresponding value\n    char_to_value = {char: i for i, char in enumerate(digit_map)}\n    \n    # Count the frequency of each character in all records\n    freqs = defaultdict(int)\n    for record in records:\n        for char in record[1]:\n            freqs[char] += 1\n            \n    # Sort characters by their frequencies and shuffle them if they have the same frequency\n    chars_ordered = sorted(freqs.items(), key=lambda x: (-x[1], random.random()))\n    \n    # Create a mapping from digit string to value\n    value_to_char = {i: char for i, (char, _) in enumerate(chars_ordered)}\n    \n    # Reconstruct the original digit string\n    digit_string = ''.join([value_to_char[i] for i in range(10)])\n    \n    return digit_string\n\nT = int(input())\nfor tc in range(1, T+1):\n    U = int(input().split()[-1])\n    records = [input().split() for _ in range(U)]\n    print('Case #{}: {}'.format(tc, solve(records)))",
    "generated_at": "2025-05-03T17:17:43.669025",
    "generation_time": 5.4999799728393555,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\round_1c\\oversized_pancake_choppers",
    "problem_name": "Oversized Pancake Choppers",
    "python_code": "Here is the Python code based on your description:\n\n\nimport sys\nfrom heapq import *\n\ndef solve():\n    input = sys.stdin.readline\n    output = sys.stdout.write\n    \n    t = int(input())\n    for case in range(1, t + 1):\n        n, d = map(int, input().split())\n        angles = list(map(int, input().split()))\n        \n        total_cuts = 0\n        max_heap = [-angle for angle in angles]\n        heapify(max_heap)  # convert the list into a heap\n        \n        while len(max_heap) >= d:\n            largest_cut = -1 * heappop(max_heap)\n            second_largest_cut = -1 * heappop(max_heap)\n            \n            total_cuts += 1\n            if largest_cut - second_largest_cut > 0:\n                heappush(max_heap, -second_largest_cut)  # push the remaining piece back to heap\n                heappush(max_heap, -((largest_cut - second_largest_cut) / 2))\n        \n        output(\"Case #{}: {}\\n\".format(case, total_cuts if len(max_heap) == 0 else \"impossible\"))\n    \nif __name__ == '__main__':\n    solve()\n\nThis program uses a priority queue (or max heap in this case) to keep track of the largest angles. It pops out two largest elements from the heap, increments total cuts by 1 and pushes back the remaining piece into the heap if it's larger than zero. This process continues until there are not enough pieces left for each diner or until all diners have been served. If at any point the largest angle is less than the second largest (which would mean we can't satisfy a diner with two slices), the program outputs \"impossible\".",
    "generated_at": "2025-05-03T17:17:50.275408",
    "generation_time": 6.5811803340911865,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\round_2\\emacs",
    "problem_name": "Emacs++",
    "python_code": "def solve(K, Q, P, Li, Ri, Pi):\n    prefix_sum = [0] * (K + 1)\n    for i in range(1, K + 1):\n        if P[i - 1] == '(':\n            prefix_sum[i] = prefix_sum[i - 1] + 1\n        else:\n            prefix_sum[i] = prefix_sum[i - 1] - 1\n    min_time = 0\n    for i in range(Q):\n        S, E = Li[i], Ri[i]\n        if Pi[S-1] == 3 or (Pi[E-1] == 2 and prefix_sum[E] > prefix_sum[S] - 2) \\\n                or (Pi[E-1] == 1 and abs(prefix_sum[E] - prefix_sum[S]) <= 1):\n            min_time += E - S + 1\n    return min_time\n\nT = int(input())\nfor t in range(1, T+1):\n    K, Q = map(int, input().split())\n    P = input()\n    Li, Ri, Pi = [], [], []\n    for _ in range(K):\n        li, ri, pi = map(int, input().split())\n        Li.append(li)\n        Ri.append(ri)\n        Pi.append(pi)\n    print(\"Case #{}: {}\".format(t, solve(K, Q, P, Li, Ri, Pi)))",
    "generated_at": "2025-05-03T17:17:55.620736",
    "generation_time": 5.304591417312622,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\round_2\\incremental_house_of_pancakes",
    "problem_name": "Incremental House of Pancakes",
    "python_code": "T = int(input())\nfor case_num in range(1, T + 1):\n    L, R = map(int, input().split())\n    n = 0\n    while min(L, R) >= n+1:\n        if L > R:\n            L -= n+1\n            n += 1\n        else:\n            R -= n+1\n            n += 1\n    print(f\"Case #{case_num}: {n} {L} {R}\")",
    "generated_at": "2025-05-03T17:17:58.375868",
    "generation_time": 2.7289962768554688,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\round_2\\security_update",
    "problem_name": "Security Update",
    "python_code": "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    T = int(input())\n    for t in range(1, T+1):\n        C, D = map(int, input().split())\n        X = list(map(int, input().split()))\n        edges = defaultdict(list)\n        for _ in range(D):\n            u, v = map(int, input().split())\n            edges[u].append(v)\n            edges[v].append(u)\n        \n        res = [0]*D\n        min_latency = 10**6 + 7\n        for i in range(2, C+1):\n            if X[i-1] < 0:  # computer i received the update before computer 1\n                continue\n            \n            # find all computers that are connected to computer i and have received the update after computer 1\n            for j in edges[i]:\n                if X[j-1] > 0:  \n                    res[X[j-1]-1] = max(res[X[j-1]-1], abs(X[i-1] - X[j-1]))\n        \n        print(\"Case #%d:\" % t, end=\" \")\n        for i in range(D):\n            if res[i] == 0:  # no latency value has been assigned to connection i yet\n                res[i] = min_latency  \n            print(res[i], end=\" \")\n        print()\n\nsolve()",
    "generated_at": "2025-05-03T17:18:03.819013",
    "generation_time": 5.419922590255737,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\round_2\\wormhole_in_one",
    "problem_name": "Wormhole in One",
    "python_code": "import sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\nfrom math import gcd\n\ndef read_ints():\n    return map(int, sys.stdin.readline().split())\n\ndef solve():\n    n = int(sys.stdin.readline())\n    points = [tuple(read_ints()) for _ in range(n)]\n    \n    if n <= 1:\n        print(\"Case #{}: {}\".format(_+1, 1))\n        return\n        \n    gcds = defaultdict(int)\n    maxgcd = 0\n    \n    for i in range(n):\n        xi, yi = points[i]\n        for j in range(i + 1, n):\n            xj, yj = points[j]\n            \n            dx, dy = xj - xi, yj - yi\n            g = abs(gcd(dx, dy))\n            \n            if (dx // g, dy // g) in gcds:\n                maxgcd = max(maxgcd, gcds[(dx // g, dy // g)] + 1)\n                \n            gcds[(dx // g, dy // g)] = max(gcds[(dx // g, dy // g)], 2 if (xi + yi) % 2 == 0 else 3)\n            \n    print(\"Case #{}: {}\".format(_+1, n - maxgcd))\n\nT = int(sys.stdin.readline())\nfor _ in range(T):\n    solve()",
    "generated_at": "2025-05-03T17:18:09.809807",
    "generation_time": 5.912553310394287,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\round_3\\naming_compromise",
    "problem_name": "Naming Compromise",
    "python_code": "def edit_distance(s1, s2):\n    if len(s1) > len(s2):\n        s1, s2 = s2, s1\n\n    distances = list(range(len(s1) + 1))\n    for index2, char2 in enumerate(s2):\n        newDistances = [index2 + 1] + [0] * len(s1)\n        for index1, char1 in enumerate(s1):\n            if char1 == char2:\n                newDistances[index1 + 1] = distances[index1]\n            else:\n                newDistances[index1 + 1] = 1 + min(distances[index1], distances[index1 + 1], newDistances[index1])\n        distances = newDistances\n    return distances[-1]\n\ndef compromise_name(c, j):\n    if len(j) > len(c):\n        c, j = j, c\n\n    min_distance = float('inf')\n    best_names = []\n    for i in range(len(c)):\n        name1 = c[:i] + c[i+1:]\n        name2 = j[:i] + j[i+1:]\n        distance1 = edit_distance(name1, c) + edit_distance(j, name1)\n        distance2 = edit_distance(name2, c) + edit<\uff5cbegin\u2581of\u2581sentence\uff5c>(j, name2)\n        if distance1 < min_distance or (distance1 == min_distance and abs(len(name1)-len(c)) < abs(len(best_names[0])-len(c))):\n            min_distance = distance1\n            best_names = [name1]\n        elif distance1 == min_distance:\n            best_names.append(name1)\n        if distance2 < min_distance or (distance2 == min_distance and abs(len(name2)-len(c)) < abs(len(best_names[0])-len(c))):\n            min_distance = distance2\n            best_names = [name2]\n        elif distance2 == min_distance:\n            best_names.append(name2)\n    return best_names\n\nt = int(input().strip())\nfor i in range(1, t + 1):\n    c, j = input().strip().split()\n    names = compromise_name(c, j)\n    print('Case #{}: {}'.format(i, min(names, key=len)))",
    "generated_at": "2025-05-03T17:18:18.377049",
    "generation_time": 8.54597282409668,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\round_3\\pen_testing",
    "problem_name": "Pen Testing",
    "python_code": "import sys\nfrom random import shuffle\n\ndef readline_int_list():\n    return list(map(int, input().split()))\n\nt, n, c = readline_int_list()\npens = [i for i in range(1, n+1)]\nshuffle(pens)\n\nink_left = {}\nfor i in pens:\n    ink_left[i] = 0 if i == n else 1\n\ndef write(pen):\n    if pen in ink_left and ink_left[pen] > 0:\n        ink_left[pen] -= 1\n        return 1\n    else:\n        return 0\n\nsucceeded = 0\nrounds = n * (n + 1) // 2\nfor _ in range(rounds):\n    sys.stdout.write(' '.join(map(str, pens)) + '\\n')\n    sys.stdout.flush()\n    result = readline_int_list()\n    for i, pen in enumerate(pens):\n        if write(pen) == result[i]:\n            succeeded += 1\n        else:\n            ink_left[pen] = 0\n\nsys.stdout.write(' '.join(map(str, [3, 4])) + '\\n')\nif succeeded >= c:\n    sys.stdout.write('0\\n')\nelse:\n    sys.stdout.write('-1\\n')",
    "generated_at": "2025-05-03T17:18:25.442260",
    "generation_time": 7.0442283153533936,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\round_3\\recalculating",
    "problem_name": "Recalculating",
    "python_code": "import sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef manhattan_distance(x1, y1, x2, y2):\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef solve():\n    T = int(input().strip())\n    for t in range(T):\n        n, d = map(int, input().split())\n        centers = [tuple(map(int, input().split())) for _ in range(n)]\n        \n        # Create a priority queue to store the repair center locations relative to Principia's current location.\n        pq = [(0, 0, 0)]\n        visited = defaultdict(lambda: float('inf'))\n        while pq:\n            dist, x, y = heappop(pq)\n            \n            if dist > visited[(x, y)]: continue\n            \n            for nx, ny in centers:\n                ndist = manhattan_distance(nx, ny, x, y)\n                \n                if ndist <= d and (ndist < visited[(nx - x, ny - y)] or ((ndist == visited[(nx - x, ny - y)]) and (nx < x))):\n                    visited[(nx - x, ny - y)] = ndist\n                    heappush(pq, (ndist, nx, ny))\n        \n        # Count the number of distinguishable locations.\n        count = 0\n        for dist in visited.values():\n            if dist <= d: count += 1\n                \n        print(\"Case #{}: {}\".format(t + 1, count))\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T17:18:33.513610",
    "generation_time": 8.04007363319397,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\round_3\\thermometers",
    "problem_name": "Thermometers",
    "python_code": "def solve(K, N, X, T):\n    # Create a list of tuples for each temperature measurement\n    measurements = [(X[i], T[i]) for i in range(N)]\n    \n    # Initialize the minimum number of thermometers to K (the maximum possible)\n    min_thermometers = K\n    \n    # Iterate over all possible combinations of thermometer locations\n    for i in range(1 << N):\n        # Create a list of temperature measurements that would be produced with this combination\n        produced = [T[0]] + [next((t for x, t in sorted(measurements)[j:] if x > X[i-j]), T[-1]) \n                             for j in range(N)]\n        \n        # If the produced measurements match the input measurements, update the minimum number of thermometers\n        if all(a == b for a, b in zip(produced, T)):\n            min_thermometers = min(min_thermometers, bin(i).count(\"1\"))\n    \n    return min_thermometers\n\nT = int(input())\nfor tc in range(1, T + 1):\n    K, N = map(int, input().split())\n    X = list(map(int, input().split()))\n    T = list(map(int, input().split()))\n    print(\"Case #{}: {}\".format(tc, solve(K, N, X, T)))",
    "generated_at": "2025-05-03T17:18:38.849812",
    "generation_time": 5.303787708282471,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\virtual_world_finals\\adjacent_and_consecutive",
    "problem_name": "Adjacent and Consecutive",
    "python_code": "def calculate_mistakes(n, moves):\n    # Initialize counters for each player\n    mistakes = [0, 0]\n    \n    # Iterate over the moves\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            player = 1\n        else:\n            player = 0\n        \n        # Check if current move creates a winning state\n        if abs(moves[i-2][0] - moves[i-1][0]) == 1 and (moves[i-2][1] == moves[i-1][1] or moves[i-2][1]+1 == moves[i-1][1] or moves[i-2][1]-1 == moves[i-1][1]):\n            # If current move creates a winning state, the other player made a mistake\n            mistakes[player] += 1\n    \n    return mistakes\n\n# Read number of test cases\nt = int(input())\nfor case in range(1, t+1):\n    n = int(input())\n    moves = []\n    \n    # Read the moves\n    for _ in range(n):\n        m, c = map(int, input().split())\n        moves.append((m, c))\n        \n    mistakes = calculate_mistakes(n, sorted(moves))\n    \n    print(\"Case #{}: {} {}\".format(case, mistakes[0], mistakes[1]))",
    "generated_at": "2025-05-03T17:18:43.899747",
    "generation_time": 5.037651777267456,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\virtual_world_finals\\hexacoin_jam",
    "problem_name": "Hexacoin Jam",
    "python_code": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef hex_to_dec(hex_num):\n    return int(hex_num, 16)\n\ndef dec_to_hex(dec_num):\n    return format(dec_num, 'X')\n\ndef calc_probability(N, D, S, E, L):\n    count = 0\n    total = (16 ** D) // 2\n    for i in range(16 ** D):\n        num1 = dec_to_hex(i).zfill(D)\n        for j in range(16 ** D):\n            num2 = dec_to_hex(j).zfill(D)\n            if hex_to_dec(num1) + hex_to_dec(num2) % (16 ** D) >= S and hex_to_dec(num1) + hex_to_dec(num2) % (16 ** D) <= E:\n                count += 1\n    g = gcd(count, total)\n    return f\"{count//g}/{total//g}\"\n\nT = int(input())\nfor t in range(1, T + 1):\n    N, D = map(int, input().split())\n    S, E = map(lambda x: hex_to_dec(x), input().split())\n    L = [hex_to_dec(num) for num in input().split()]\n    print(f\"Case #{t}: {calc_probability(N, D, S, E, L)}\")",
    "generated_at": "2025-05-03T17:18:50.130640",
    "generation_time": 6.205554723739624,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\virtual_world_finals\\musical_cords",
    "problem_name": "Musical Cords",
    "python_code": "import heapq\nimport math\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef solve():\n    N, R, K = map(int, input().split())\n    points = [tuple(map(float, input().split())) for _ in range(N)]\n    \n    angles = sorted([(i * 360 / (2 * math.pi), d + l) for i, (d, l) in enumerate(points)])\n    angles += [(a + 360, d + l) for a, (d, l) in angles[:K]]\n    \n    heap = []\n    for i in range(N):\n        x1, y1 = R * math.cos((angles[i][0] - 90) * math.pi / 180), R * math.sin((angles[i][0] - 90) * math.pi / 180)\n        for j in range(i + 1, i + K):\n            x2, y2 = R * math.cos((angles[j][0] - 90) * math.pi / 180), R * math.sin((angles[j][0] - 90) * math.pi / 180)\n            d = distance(x1, y1, x2, y2)\n            heapq.heappush(heap, (-d + angles[i][1] + angles[j][1]))\n    \n    result = [(-heapq.heappop(heap)) for _ in range(K)]\n    print('Case #{}: {}'.format(_ + 1, ' '.join(map(str, result))))\n\nT = int(input())\nfor _ in range(T):\n    solve()",
    "generated_at": "2025-05-03T17:18:57.399824",
    "generation_time": 7.246262073516846,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\virtual_world_finals\\pack_the_slopes",
    "problem_name": "Pack the Slopes",
    "python_code": "import sys\nfrom heapq import *\ninput = sys.stdin.readline\nINF = int(1e9)\n\ndef dijkstra():\n    dist[0] = 0\n    hq = [(0, 0)]\n    while hq:\n        d, now = heappop(hq)\n        if dist[now] < d: continue\n        for next_node, cost in graph[now]:\n            next_d = d + cost\n            if next_d < dist[next_node]:\n                dist[next_node] = next_d\n                heappush(hq, (next_d, next_node))\n\ndef solve():\n    T = int(input())\n    for t in range(1, T + 1):\n        N = int(input())\n        graph = [[] for _ in range(N)]\n        dist = [INF] * N\n        for i in range(N - 1):\n            u, v, s, c = map(int, input().split())\n            graph[u - 1].append((v - 1, -c)) # negative cost because we are minimizing\n        dijkstra()\n        ans = sum([-i for i in dist])\n        print(\"Case #{}: {}\".format(t,ans))\n        \nsolve()",
    "generated_at": "2025-05-03T17:19:02.172207",
    "generation_time": 4.761971712112427,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2020\\virtual_world_finals\\replace_all",
    "problem_name": "Replace All",
    "python_code": "Here is a Python solution for this problem using recursion and set operations to find the maximum number of unique characters in the final text after performing all implemented replacements to an initial string one or more times each, in some order:\n\n\ndef replace_chars(s, replacements):\n    if not replacements:\n        return {s[-1]}\n    \n    last = set()\n    for r in replacements.keys():\n        if r in s:\n            new_str = s.replace(r, replacements[r])\n            last |= replace_chars(new_str, {k: v for k, v in replacements.items() if k != r})\n    \n    return last\n\nt = int(input())  # number of test cases\nfor case in range(1, t + 1):\n    s, n = input().split(' ')  # initial string and number of implemented replacements\n    n = int(n)\n    replacements = {}\n    for _ in range(n):\n        a, b = input().split(' ')  # replacement pairs\n        replacements[a] = b\n    \n    unique_chars = replace_chars(s, replacements)\n    print(\"Case #{}: {}\".format(case, len(unique_chars)))\n\nThis solution uses recursion to try all possible combinations of replacement operations on the string. It keeps track of the unique characters in each step and returns a set of these at the end of the recursive call. The final result is the maximum number of unique characters among all returned sets. Each test case is processed independently, with the results being printed out in the required format.",
    "generated_at": "2025-05-03T17:19:08.039166",
    "generation_time": 5.853176116943359,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\qualification_round\\cheating_detection",
    "problem_name": "Cheating Detection",
    "python_code": "import numpy as np\nfrom scipy.special import expit  # Sigmoid function\n\ndef sigmoid(x):\n    return expit(x)\n\ndef generate_skills_questions():\n    skills = np.random.uniform(-3, 3, size=100)\n    questions = np.random.uniform(-3, 3, size=10000)\n    return skills, questions\n\ndef calculate_probabilities(skill, question):\n    return sigmoid(skill - question)\n\ndef generate_answers(skills, questions):\n    answers = []\n    for i in range(len(questions)):\n        answer = np.random.binomial(n=1, p=calculate_probabilities(skills[i], questions[i]), size=100)\n        answers.append(answer)\n    return np.array(answers).T  # Transpose to match the format of input\n\ndef cheat(player_answer):\n    return np.random.binomial(n=1, p=0.5, size=len(player_answer))\n\ndef identify_cheater(players_answers, player_count):\n    for i in range(player_count):\n        if sum(players_answers[:,i]) == len(players_answers[0]):  # All questions answered correctly\n            return i + 1  # Adding 1 to match the player numbers starting from 1\n    return -1  # Return -1 if no cheater is found\n\ndef tournament():\n    T = int(input())\n    P = float(input()) / 100\n    \n    for t in range(T):\n        skills, questions = generate_skills_questions()\n        players_answers = generate_answers(skills, questions)\n        \n        # Cheat with 50% probability\n        cheating_probs = np.random.binomial(n=1, p=0.5, size=len(players_answers[0]))\n        for i in range(len(players_answers)):\n            if cheating_probs[i]:  # If player is going to cheat\n                players_answers[i] = cheat(players_answers[i])\n        \n        cheater = identify_cheater(players_answers, len(skills))\n        print(\"Case #{}: {}\".format(t+1, cheater if cheater != -1 else \"Cannot determine\"))",
    "generated_at": "2025-05-03T17:19:16.456551",
    "generation_time": 8.403542280197144,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\qualification_round\\median_sort",
    "problem_name": "Median Sort",
    "python_code": "Here's a Python program based on the description provided. This program uses a recursive function `find_median` to find the median of each group of three elements in an array, and then sorts the array in ascending order using this information. Note that for simplicity, I assume that we have enough questions remaining to ask about any three-element subset (i.e., no more than Q/T queries).\n\n\ndef find_median(arr):\n    arr = sorted(arr)  # sort the array in ascending order\n    mid = len(arr) // 2  # calculate the middle index of the array\n    return arr[mid] if len(arr) % 2 == 1 else (arr[mid - 1] + arr[mid]) // 2  # find the median\n\ndef sort_array(n, q):\n    if n < 3 or not q:\n        return [i + 1 for i in range(n)]\n    \n    arr = list(range(1, n + 1))  # create an array of size n with elements from 1 to n\n    medians = []\n    for i in range(0, n - 2):\n        print(f\"{arr[i]}, {arr[i + 1]}, {arr[i + 2]}\")  # ask the judge for median of three elements\n        medians.append((find_median([arr[i], arr[i + 1], arr[i + 2]]), i, i + 1, i + 2) if n % 3 == 0 else (find_median([arr[i], arr[i + 1], arr[i + 2]]), i, i + 2, i + 1))  # find the median of three elements\n    medians.sort()  # sort the medians in ascending order\n    \n    for i in range(n - 3):\n        if (medians[i][0] == arr[i]) and (medians[i][1] == arr[i + 1]) and (medians[i][2] == arr[i + 2] or medians[i][2] == arr[i + 3]):  # check if the median is in the correct position\n            arr[i], arr[i + 1], arr[i + 2] = arr[i + 1], arr[i + 2], arr[i]  # swap elements to put them in ascending order\n        else:\n            arr[i], arr[i + 1], arr[i + 2] = arr[i + 2], arr[i + 1], arr[i]  # swap elements to put them in ascending order\n    return arr\n\nPlease note that this code does not handle the interaction with the judge. You would need a separate function for reading and interpreting the responses from the judge, which is beyond the scope of this question. Also, you might want to adjust the number of questions asked per list based on your specific requirements. The current implementation assumes an average of Q/T questions per list.",
    "generated_at": "2025-05-03T17:19:26.445908",
    "generation_time": 9.962965250015259,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\qualification_round\\moons_and_umbrellas",
    "problem_name": "Moons and Umbrellas",
    "python_code": "def min_copyright_cost(X, Y, S):\n    min_cost = 0\n    CJ = S.count('CJ')\n    JC = S.count('JC')\n    \n    while CJ > 0 and X <= Y:\n        min_cost += X\n        S = S.replace('CJ', '?', 1)\n        CJ -= 1\n        \n    while JC > 0 and X >= Y:\n        min_cost += Y\n        S = S.replace('JC', '?', 1)\n        JC -= 1\n    \n    remaining = S.count('C') + S.count('J')\n    return min_cost + 2 * X * remaining if X < 0 else min_cost + 2 * Y * remaining\n\nT = int(input())\nfor t in range(1, T+1):\n    X, Y, S = input().split()\n    print(\"Case #{}: {}\".format(t, min_copyright_cost(int(X), int(Y), S)))",
    "generated_at": "2025-05-03T17:19:30.219149",
    "generation_time": 3.7535579204559326,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\qualification_round\\reversort",
    "problem_name": "Reversort",
    "python_code": "def reversort(lst):\n    n = len(lst)\n    total_cost = 0\n    \n    for i in range(n-1):\n        j = lst.index(min(lst[i:]), i) + 1\n        sublist_length = j - i\n        \n        # Reverse the sublist and add its length to total cost\n        total_cost += sublist_length \n        \n        lst[i:j] = reversed(lst[i:j])\n    \n    return total_cost\n\nt = int(input())\nfor case in range(1, t + 1):\n    n = int(input())\n    lst = list(map(int, input().split()))\n    cost = reversort(lst)\n    \n    print('Case #{}: {}'.format(case, cost))",
    "generated_at": "2025-05-03T17:19:33.663471",
    "generation_time": 3.434061050415039,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\qualification_round\\reversort_engineering",
    "problem_name": "Reversort Engineering",
    "python_code": "def reversort(n, c):\n    if n * (n - 1) // 2 < c or c % 2 != n % 2:\n        return \"IMPOSSIBLE\"\n    lst = list(range(1, n + 1))\n    res = []\n    for i in range(n - 1):\n        j = min(c - (i * (i + 1) // 2), ((n - i) * (n - i - 1) // 2) + i)\n        c -= j - i\n        lst[i:j] = reversed(lst[i:j])\n    return ' '.join(map(str, lst))\n\nt = int(input())\nfor case in range(1, t + 1):\n    n, c = map(int, input().split())\n    print(\"Case #{}: {}\".format(case, reversort(n, c)))",
    "generated_at": "2025-05-03T17:19:37.615112",
    "generation_time": 3.9295449256896973,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\round_1a\\append_sort",
    "problem_name": "Append Sort",
    "python_code": "def solve():\n    T = int(input())\n    for tc in range(1, T + 1):\n        N = int(input())\n        X = list(map(int, input().split()))\n        ops = 0\n        for i in range(N - 1):\n            if X[i] >= X[i+1]:\n                diff = X[i] - X[i+1] + 1\n                X[i+1] += diff\n                ops += diff\n        print(\"Case #{}: {}\".format(tc, ops))\n\nsolve()",
    "generated_at": "2025-05-03T17:19:39.776510",
    "generation_time": 2.1493849754333496,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\round_1a\\hacked_exam",
    "problem_name": "Hacked Exam",
    "python_code": "Here is a Python program based on your description:\n\n\nfrom fractions import Fraction\nimport sys\n\ndef solve():\n    n, q = map(int, input().split())\n    scores = [0]*q\n    for _ in range(n):\n        s, ans = input().split()\n        s = int(s)\n        for i in range(q):\n            if ans[i] == 'T':\n                scores[i] += Fraction(1)/Fraction(2)**int(ans[i]) * 2 - 1\n    return \" \".join([str((scores.index(max(scores)), max(scores))) for _ in range(q)] + [str(sum(scores))])\n\nt = int(input())\nfor i in range(1, t+1):\n    print(\"Case #{}: {}\".format(i, solve()))\n\nThis program uses the concept of expected value and probability to calculate the maximum expected score. It reads the number of students (n) and questions (q). For each student, it calculates their score based on whether they answered 'T' or 'F'. The scores are stored in a list. Finally, it prints out the index of the question with the highest score along with the score itself.",
    "generated_at": "2025-05-03T17:19:44.170934",
    "generation_time": 4.37183403968811,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\round_1a\\prime_time",
    "problem_name": "Prime Time",
    "python_code": "from math import prod\nfrom sys import stdin\nfrom itertools import combinations\n\ndef solve():\n    primes = list(map(int,stdin.readline().split()))\n    dp1 = [0]*(1<<len(primes))\n    dp2 = [0]*(1<<len(primes))\n    total = 1<<len(primes)\n    for mask in range(total):\n        sub_set = [primes[i] for i in range(len(primes)) if (mask & 1<<i)!=0]\n        dp1[mask] = sum(sub_set) if sub_set else 0\n        dp2[mask] = prod(sub_set) if sub_set else 1\n    dp = [[(dp1[a^b],dp2[a^b]) for b in range(total)] for a in range(total)]\n    for c in reversed(range(len(primes))):\n        for mask in range(1<<c):\n            dp[mask][0] = max((dp1[mask],dp2[mask]), key=lambda x:abs(x[0]-x[1]))\n            dp[mask|1<<c][0] = max((dp1[mask|1<<c],dp2[mask|1<<c]), key=lambda x:abs(x[0]-x[1]))\n    for c in range(1,len(primes)):\n        for mask in range(total):\n            dp[mask][c%2] = max((dp1[mask],dp2[mask]), (dp1[mask|1<<c]+dp2[mask^1<<c],dp2[mask|1<<c]-dp1[mask^1<<c])) if c%2==0 else \\\n                            max((dp1[mask],dp2[mask]), (dp1[mask|1<<c]-dp2[mask^1<<c],dp2[mask|1<<c]+dp1[mask^1<<c]))\n    return dp[0][len(primes)%2-1][0] if len(primes) else 0\n\nT = int(stdin.readline())\nfor t in range(1, T + 1):\n    print(\"Case #{}: {}\".format(t, solve()))",
    "generated_at": "2025-05-03T17:19:51.775668",
    "generation_time": 7.591637372970581,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\round_1b\\broken_clock",
    "problem_name": "Broken Clock",
    "python_code": "def find_time(A, B, C):\n    # Calculate total degrees of rotation for each hand\n    A = (360 - A) % 360 * 12 / 360 * 1e9\n    B = (360 - B) % 360 * 12 / 360 * 1e9\n    C = (360 - C) % 360 * 12 / 360 * 1e9\n    \n    # Calculate time in nanoseconds\n    total_time = A + B + C\n    \n    h, r = divmod(total_time, 3600*1e9)\n    m, r = divmod(r, 60*1e9)\n    s, n = divmod(r, 1e9)\n    \n    return int(h), int(m), int(s), int(n)\n\nT = int(input())\nfor i in range(1, T+1):\n    A, B, C = map(int, input().split())\n    h, m, s, n = find_time(A, B, C)\n    print(\"Case #{}: {} {} {} {}\".format(i, h, m, s, n))",
    "generated_at": "2025-05-03T17:19:56.676848",
    "generation_time": 4.8918657302856445,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\round_1b\\digit_blocks",
    "problem_name": "Digit Blocks",
    "python_code": "It seems like this problem is more related to algorithm design rather than a specific Python programming task. However, I can provide a basic structure of how the program might be structured based on your description. This code will not solve all cases due to the nature of the problem and it's likely that you would need a more sophisticated algorithm for optimal results.\n\n\nimport sys\nfrom collections import deque\n\n# Read input data from judge\nT, N, B, P = map(int, sys.stdin.readline().split())\ntowers = [deque() for _ in range(N)]\nscores = []\n\nfor _ in range(T * N):\n    D = int(sys.stdin.readline())  # digit printed on the block to be placed\n    \n    max_score = 0\n    max_tower_index = -1\n    \n    for i, tower in enumerate(towers):\n        if len(tower) < B:  # we can place the block here\n            score = int(''.join([str(D)] + [str(b) for b in tower]))\n            if score > max_score:\n                max_score = score\n                max_tower_index = i\n    \n    if max_tower_index == -1:  # no valid towers, output -1 and exit\n        print(-1)\n        sys.exit(0)\n        \n    towers[max_tower_index].appendleft(D)\n    scores.append(max_score)\n    \n# Output the total score\nprint(sum(scores)) if sum(scores) >= P else print(-1)\n\nThis code reads the number of test cases, towers and blocks from the judge's input. For each block to be placed, it finds a tower with less than B blocks (to avoid rotating digits). The score is calculated as the integer formed by concatenating the digit D with the existing digits in the tower. If no valid tower is found, -1 is outputted and the program exits. Otherwise, the block is added to the selected tower and its score is appended to a list of scores. Finally, if the total score is greater or equal to P, it's printed; otherwise, -1 is outputted.",
    "generated_at": "2025-05-03T17:20:04.658552",
    "generation_time": 7.973278999328613,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\round_1b\\subtransmutation",
    "problem_name": "Subtransmutation",
    "python_code": "from queue import PriorityQueue\n\ndef solve():\n    T = int(input())\n    for t in range(T):\n        N, A, B = map(int, input().split())\n        units = list(map(int, input().split()))\n        \n        pq = PriorityQueue()\n        for u in units:\n            pq.put((u, 1))\n            \n        while not pq.empty():\n            curr_unit, count = pq.get()\n            if curr_unit <= A or (curr_unit - B) <= 0:\n                continue\n            new_units = [(curr_unit - x, count + 1) for x in range(A, min(B, curr_unit))]\n            for nu, nc in new_units:\n                pq.put((nu, nc))\n        \n        if not pq.empty():\n            print(\"Case #{}: {}\".format(t + 1, pq.get()[0]))\n        else:\n            print(\"Case #{}: IMPOSSIBLE\".format(t + 1))\n            \nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T17:20:09.218411",
    "generation_time": 4.535024404525757,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\round_1c\\closest_pick",
    "problem_name": "Closest Pick",
    "python_code": "from collections import Counter\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    n, k = map(int, input().split())\n    nums = list(map(int, input().split()))\n    \n    counter = Counter(nums)\n    keys = sorted(counter.keys(), reverse=True)\n    \n    for i in range(len(keys)-1):\n        if abs(keys[i] - k/2) < abs(keys[i+1] - k/2):\n            return \"Case #{}: {:.7f}\".format(t, 0.5)\n    \n    return \"Case #{}: {:.7f}\".format(t, 0 if keys[-1] > k-keys[-1] else 0.5)\n\nT = int(input())\nfor t in range(1, T+1):\n    print(solve())",
    "generated_at": "2025-05-03T17:20:12.459844",
    "generation_time": 3.229902982711792,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\round_1c\\double_or_noting",
    "problem_name": "Double or NOTing",
    "python_code": "Here's the Python code that solves this problem using Breadth-First Search (BFS):\n\n\nfrom collections import deque\n\ndef binary_transform(S, E):\n    visited = set()\n    queue = deque([(S, 0)])\n    \n    while queue:\n        curr, step = queue.popleft()\n        \n        if curr == E:\n            return step\n            \n        for next in (int(curr) ^ int('1'*len(curr), 2)), int(curr)*2:\n            if next not in visited and '0'+bin(next)[2:] not in visited:\n                queue.append((bin(next)[2:].zfill(8), step+1))\n                visited.add('0'+bin(next)[2:])\n                \n        for next in int(curr) ^ int('1'*len(curr), 2):\n            if '1'+bin(next)[2:] not in visited and int(curr) ^ int('1'*len(curr), 2) not in visited:\n                queue.append(('1'+bin(next)[2:].zfill(8), step+1))\n                visited.add('1'+bin(next)[2:])\n                \n    return \"IMPOSSIBLE\"\n\nT = int(input())\nfor t in range(1, T+1):\n    S, E = input().split()\n    print(\"Case #{}: {}\".format(t, binary_transform(S, E)))\n\nThis code uses a deque for BFS and a set to keep track of visited nodes. It starts from the initial number `S` and tries all possible transformations (double operation or NOT operation) in each step until it reaches the target number `E`. The function returns the minimum number of operations needed, or \"IMPOSSIBLE\" if no such transformation is possible.",
    "generated_at": "2025-05-03T17:20:19.005712",
    "generation_time": 6.5165650844573975,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\round_1c\\roaring_years",
    "problem_name": "Roaring Years",
    "python_code": "def next_roaring(y):\n    y += 1\n    while True:\n        str_y = str(y)\n        is_roaring = all([str(i+1) in str_y for i in range(len(str_y)-1)])\n        if is_roaring and len(set(str_y)) == len(str_y):\n            return y\n        y += 1\n\ndef main():\n    T = int(input())\n    for case in range(1, T+1):\n        Y = int(input())\n        print('Case #{}: {}'.format(case, next_roaring(Y)))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:20:21.495267",
    "generation_time": 2.475712537765503,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\round_2\\hidden_pancakes",
    "problem_name": "Hidden Pancakes",
    "python_code": "Here's the Python code for your problem:\n\n\nfrom math import factorial as f\nMOD = 10**9 + 7\ndef inv(x):\n    return pow(x, MOD-2, MOD)\nfact = [f(i) % MOD for i in range(13)] + [0]*85\ninv_fact = [inv(f(i)) % MOD for i in range(13)] + [0]*85\ndef choose(n, k):\n    if k > n or k < 0: return 0\n    return fact[n] * inv_fact[k] % MOD * inv_fact[n-k] % MOD\nt = int(input())\nfor case in range(1, t+1):\n    n = int(input())\n    visibles = list(map(int, input().split()))\n    ans = 0\n    for i in range(1, n+1):\n        if visibles[i-1] == i:\n            ans += choose(n, i) * pow(2, i*(n-i), MOD) % MOD\n            ans %= MOD\n        elif visibles[i-1] == i-1 and visibles[i-2] < i - 1:\n            ans += choose(n, i) * (pow(2, i*(n-i), MOD)-1) % MOD\n            ans %= MOD\n    print(\"Case #%d: %d\" % (case, ans))\n\nThis program uses dynamic programming to solve the problem. The `choose` function calculates combinations modulo 10^9+7. It first calculates factorials and their inverses up to n=12, then extends these lists by zeros for future use. For each test case, it checks the number of visible pancakes at each step. If all pancakes are visible or none are, we have `choose(n, i) * pow(2, i*(n-i), MOD) % MOD` possible cooking orders (where `pow(2, i*(n-i), MOD)` is the number of ways to arrange the visible pancakes). If exactly one pancake is visible at each step, we have `choose(n, i) * (pow(2, i*(n-i), MOD)-1) % MOD` possible cooking orders. The result is the sum of these possibilities modulo 10^9+7 for all i from 1 to n.",
    "generated_at": "2025-05-03T17:20:29.858502",
    "generation_time": 8.34838080406189,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\round_2\\matrygons",
    "problem_name": "Matrygons",
    "python_code": "Here's the Python code for this problem. It uses dynamic programming to solve it. The idea is that we keep track of the maximum number of polygons at each step and update it based on whether adding another polygon can increase the total number of sides or not.\n\n\nimport sys\n\n# Pre-calculate the maximum possible number of polygons for every valid side count\nmax_polygons = [0] * 1001\nfor i in range(2, len(max_polygons)):\n    max_polygons[i] = 1 + max((i - j*(j-4)//2 for j in range(int((i*8+9)**.5), 3, -1)))\n\n# Read the number of test cases from standard input\nT = int(sys.stdin.readline())\nfor t in range(1, T + 1):\n    # Read the total number of sides from standard input\n    N = int(sys.stdin.readline())\n    \n    # Print the maximum number of polygons for this side count\n    print('Case #{}: {}'.format(t, max_polygons[N]))\n\nThis code assumes that the input is coming from standard input and it reads one integer per line. The first line should be the total number of test cases (T). Each of the following T lines should contain a single integer representing the target total number of sides for each case. It then calculates and prints out the maximum number of polygons that can be part of a matrygon with exactly N sides, as per your specifications.",
    "generated_at": "2025-05-03T17:20:34.790682",
    "generation_time": 4.916856288909912,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\round_2\\minimum_sort",
    "problem_name": "Minimum Sort",
    "python_code": "Here's a Python program based on the problem description. This program sorts a list of distinct integers in strictly increasing order by swapping elements and querying for minimum values from ranges. The number of coins per test case is limited to 6 * 10^8, as specified in the problem statement.\n\nPlease note that this code assumes you have access to an interactive environment where you can send queries and receive responses. This might be a part of a larger system or a separate script for testing purposes:\n\n\nimport math\n\ndef get_min(i, j):\n    coins = math.ceil(10**8 / (j - i + 1))\n    if coins > remaining_coins[testcase]:\n        return None\n    print(f\"Q {i} {j}\")\n    response = int(input())\n    remaining_coins[testcase] -= coins\n    return response\n\ndef solve():\n    n = len(arr)\n    for i in range(n):\n        min_pos = i\n        for j in range(i+1, n):\n            if arr[j] < arr[min_pos]:\n                min_pos = j\n        # Swap element at position i with the minimum element found\n        if i != min_pos:\n            coins_needed = 0\n            for k in range(i+1, n):\n                query_result = get_min(i+1, k)\n                if query_result is not None and arr[query_result] < arr[i]:\n                    min_pos = k\n            if min_pos != i:\n                print(f\"S {i} {min_pos}\")\n                arr[i], arr[min_pos] = arr[min_pos], arr[i]\n\nT, N = map(int, input().split())\nremaining_coins = [600000000 for _ in range(T)]  # Initialize with maximum coins per test case\nfor testcase in range(T):\n    arr = list(map(int, input().split()))\n    solve()\n    print(\"D\")  # Signal that we are done\n\nThis code first defines a function `get_min` to query the minimum value within a range. It then uses this function in the main `solve` function to find the minimum of each subarray and swap it with the current element if necessary. After all swaps, it signals that we are done by printing \"D\".",
    "generated_at": "2025-05-03T17:20:42.911988",
    "generation_time": 8.111940383911133,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\round_2\\retiling",
    "problem_name": "Retiling",
    "python_code": "def solve(R, C, F, S, grid_start, grid_end):\n    def get_diff():\n        diff = [[0]*C for _ in range(R)]\n        for i in range(R):\n            for j in range(C):\n                if grid_start[i][j] != grid_end[i][j]:\n                    diff[i][j] = 1\n        return diff\n    \n    def get_min_cost():\n        min_cost = sum([sum(row) for row in grid_start]) * F\n        changes = get_diff()\n        \n        # Try to change all the tiles with one operation (flip or swap).\n        if any(changes):\n            flips = [[0]*C for _ in range(R)]\n            swaps = 2*sum([row.count('MG') + row.count('GM') for row in changes])\n            \n            # Try to flip the tiles with one operation and see if it's better than current min_cost.\n            for i in range(R):\n                for j in range(C-1):\n                    if changes[i][j] == changes[i][j+1] == 1:\n                        flips[i][j], flips[i][j+1] = 1, 1\n                        cost = sum([sum(row) for row in flips]) * F + swaps * S\n                        if cost < min_cost:\n                            min_cost = cost\n                            \n            # Try to swap the tiles with one operation and see if it's better than current min_cost.\n            flips = [[0]*C for _ in range(R)]\n            swaps = 2*(sum([row.count('MG') + row.count('GM') for row in changes]) - 1)\n            for i in range(R-1):\n                if changes[i][0] == changes[i+1][0] == 1:\n                    flips[i][0], flips[i+1][0] = 1, 1\n                    cost = sum([sum(row) for row in flips]) * F + swaps * S\n                    if cost < min_cost:\n                        min_cost = cost\n                        \n        return min_cost\n    \n    t = int(input())\n    for case in range(1, t+1):\n        R, C, F, S = map(int, input().split())\n        grid_start = [list(input().strip()) for _ in range(R)]\n        grid_end = [list(input().strip()) for _ in range(R)]\n        print('Case #{}: {}'.format(case, get_min_cost()))\n        \nsolve(*[int(x) for x in input().split()], [[char for char in input().strip()] for _ in range(R)], [[char for char in input().strip()] for _ in range(R)])",
    "generated_at": "2025-05-03T17:20:52.631526",
    "generation_time": 9.67138934135437,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\round_3\\binary_search_game",
    "problem_name": "Binary Search Game",
    "python_code": "import sys\nfrom collections import defaultdict\ninput = sys.stdin.readline\nMOD = 10**9 + 7\n\ndef solve(N, M, L, A):\n    dp_min = [0] * (1 << L)\n    dp_max = [0] * (1 << L)\n    \n    for i in range(L-1, -1, -1):\n        n = 1 << i\n        m = 2 * n\n        \n        cards = defaultdict(int)\n        for j in range(m):\n            cards[A[j]] += 1\n            \n        dp_min_next = [0] * (1 << L)\n        dp_max_next = [0] * (1 << L)\n        \n        for mask in range(1, m):\n            if bin(mask).count('1') == n:\n                min_val = 1e9\n                max_val = 0\n                \n                for sub_mask in range(mask):\n                    if ((sub_mask & mask) == 0 and (sub_mask | mask) == m-1):\n                        min_val = min(min_val, dp_min[sub_mask] + cards[max(A[j] for j in range(m) if ((sub_mask >> j) & 1))])\n                        max_val = max(max_val, dp_max[sub_mask] + cards[max(A[j] for j in range(m) if ((sub_mask >> j) & 1))])\n                \n                dp_min_next[mask] = min_val % MOD\n                dp_max_next[mask] = max_val % MOD\n        \n        dp_min, dp_max = dp_min_next, dp_max_next\n    \n    return sum(dp_min) * 2 % MOD if L % 2 == 0 else (sum(dp_min) + sum(dp_max)) % MOD\n\nT = int(input())\nfor t in range(1, T+1):\n    N, M, L = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    print(\"Case #{}: {}\".format(t, solve(N, M, L, A)))",
    "generated_at": "2025-05-03T17:21:00.768242",
    "generation_time": 8.125080823898315,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\round_3\\build-a-pair",
    "problem_name": "Build-A-Pair",
    "python_code": "from itertools import permutations\n\ndef min_diff(digits):\n    # Generate all possible permutations of the digits\n    perms = [''.join(p) for p in permutations(digits)]\n    \n    min_difference = float('inf')\n    for perm in perms:\n        # Split the permutation into two numbers without leading zeros\n        num1, num2 = int(perm[:-1]), int(perm[-1])\n        \n        # Skip if any of the numbers are 0 or negative\n        if num1 <= 0 or num2 <= 0:\n            continue\n            \n        # Update min_difference if necessary\n        min_difference = min(min_difference, abs(num1 - num2))\n    \n    return min_difference\n\nT = int(input())\nfor t in range(1, T+1):\n    digits = input()\n    print('Case #{}: {}'.format(t, min_diff(digits)))",
    "generated_at": "2025-05-03T17:21:04.202833",
    "generation_time": 3.3781468868255615,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\round_3\\fence_design",
    "problem_name": "Fence Design",
    "python_code": "import sys\nfrom typing import List, Tuple\n\ndef solve(poles: List[Tuple[int, int]], fence1: Tuple[int, int], fence2: Tuple[int, int]) -> List[Tuple[int, int]]:\n    # Check if the poles are collinear\n    (x1, y1), (x2, y2), (x3, y3) = sorted(poles)[1:]\n    if (y2 - y1) * (x3 - x2) == (y3 - y2) * (x2 - x1):\n        return []\n    \n    # Sort the poles by their X-coordinates\n    poles.sort()\n    \n    # Initialize a list to keep track of the fences\n    fences = [fence1, fence2]\n    \n    # Iterate over all the remaining poles and add new fences where necessary\n    for i in range(len(poles)):\n        if not is_valid_fence((poles[i-1], poles[i]), fences):\n            fences.append((i, i+1))\n    \n    return fences[2:]  # Return the new fences (not including the existing ones)\n\ndef is_valid_fence(fence: Tuple[int, int], fences: List[Tuple[int, int]]) -> bool:\n    # Check if any of the existing fences intersect with the new fence\n    for old_fence in fences:\n        if (fence[0] in old_fence and fence[1] not in old_fence) or \\\n           (fence[1] in old_fence and fence[0] not in old_fence):\n            return False\n    return True\n\ndef main():\n    T = int(sys.stdin.readline().strip())\n    for t in range(T):\n        N = int(sys.stdin.readline().strip())\n        poles = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(N)]\n        fence1 = tuple(map(lambda x: int(x) + 1, sys.stdin.readline().strip().split()))\n        fence2 = tuple(map(lambda x: int(x) + 1, sys.stdin.readline().strip().split()))\n        \n        fences = solve(poles, fence1, fence2)\n        \n        print(\"Case #{}: {}\".format(t+1, len(fences)))\n        for f in fences:\n            print(*f)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:21:12.945146",
    "generation_time": 8.725330591201782,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\round_3\\square_free",
    "problem_name": "Square Free",
    "python_code": "def solve(R, C, S_row, S_col):\n    if sum(S_row) != R * max(S_row) or sum(S_col) != C * max(S_col):\n        return \"IMPOSSIBLE\"\n    \n    matrix = [['/' if i < j and (i + j) % 2 == 0 else '\\\\' for j in range(C)] for i in range(R)]\n    \n    for i in range(min(R, C)):\n        if S_row[i] > 0:\n            matrix[i][0] = '/'\n            S_row[i] -= 1\n        if S_col[i] > 0:\n            matrix[0][i] = '\\\\'\n            S_col[i] -= 1\n    \n    for i in range(min(R, C)):\n        for j in range(S_row[i]):\n            if (j + i) % 2 == 0:\n                matrix[i][j + 1] = '/'\n            else:\n                matrix[i][j + 1] = '\\\\'\n    \n    for i in range(min(R, C)):\n        for j in range(S_col[i]):\n            if (j + i) % 2 == 0:\n                matrix[j + 1][i] = '/'\n            else:\n                matrix[j + 1][i] = '\\\\'\n    \n    return \"POSSIBLE\\n\" + \"\\n\".join(\"\".join(row) for row in matrix)\n\nT = int(input())\nfor tc in range(1, T+1):\n    R, C = map(int, input().split())\n    S_row = list(map(int, input().split()))\n    S_col = list(map(int, input().split()))\n    \n    print(\"Case #{}: {}\".format(tc, solve(R, C, S_row, S_col)))",
    "generated_at": "2025-05-03T17:21:19.929727",
    "generation_time": 6.969957113265991,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\world_finals\\cutting_cake",
    "problem_name": "Cutting Cake",
    "python_code": "Here's the Python code for this problem based on your description:\n\n\ndef solve(N, W, H, P, Q, R, S, patches):\n    # Calculate area of each patch and total enjoyment from all patches\n    areas = []\n    enjoyments_A = []\n    enjoyments_B = []\n    for Xi, Yi, Ai, Bi in patches:\n        x1 = Xi\n        y1 = Yi\n        x2 = Xi + P\n        y2 = Yi + Q\n        x3 = Xi + R\n        y3 = Yi + S\n        area = 0.5 * abs((x2 - x1)*(y3 - y1) - (x3 - x1)*(y2 - y1))  # Calculate triangle area using cross product\n        enjoyment_A = Ai * area / ((P + R) * (Q + S))   # Enjoyment from eating a part of the patch\n        enjoyment_B = Bi * area / ((P + R) * (Q + S))   # Enjoyment from your twin eating a part of the patch\n        areas.append(area)\n        enjoyments_A.append((x1, x2, enjoyment_A))\n        enjoyments_B.append((x1, x2, enjoyment_B))\n    enjoyments_A.sort()  # Sort by starting point\n    enjoyments_B.sort()\n    \n    # Calculate cumulative sum of enjoyments from left to right\n    cumsum_A = [0] * (N + 1)\n    cumsum_B = [0] * (N + 1)\n    for i in range(N):\n        cumsum_A[i+1] = cumsum<\uff5cbegin\u2581of\u2581sentence\uff5c>_A[i] + enjoyments_A[i][2]\n        cumsum_B[i+1] = cumsum<\uff5cbegin\u2581of\u2581sentence\uff5c>_B[i] + enjoyments_B[i][2]\n    \n    # Calculate minimum difference in total enjoyments\n    min_diff = float('inf')\n    for i in range(N):\n        diff = abs(cumsum_A[i+1] - cumsum_B[-i-2])  # Sum of enjoyments on left side and right side after cut\n        if diff < min_diff:\n            min_diff = diff\n            \n    return min_diff",
    "generated_at": "2025-05-03T17:21:28.686237",
    "generation_time": 8.553330898284912,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\world_finals\\divisible_divisions",
    "problem_name": "Divisible Divisions",
    "python_code": "def solve(S, D):\n    MOD = 10**9+7\n    n = len(S)\n    \n    dp = [0]*(n+2)\n    dp[0] = 1\n    prev_zero = [-1]*10\n    curr_divisible = [False]*n\n    \n    for i in range(n):\n        digit = int(S[i])\n        for j in range(digit+1 if i > 0 else 1, 10):\n            if prev_zero[j-1] != -1:\n                dp[i+2] += dp[prev_zero[j-1]]\n                dp[i+2] %= MOD\n        for j in range(digit, 10):\n            if not curr_divisible[i]:\n                prev_zero[j] = i+1\n    \n    divisible = [False]*(n+1)\n    stack = []\n    for i in range(n-1,-1,-1):\n        while stack and S[stack[-1]] < S[i]:\n            stack.pop()\n        if not stack:\n            divisible[i] = True\n        else:\n            j = stack[-1]\n            if (j-i+1)%D == 0 or ((S[i:j+1])%D == 0):\n                divisible[i] = True\n        stack.append(i)\n    \n    for i in range(n+1):\n        if not divisible[i]: continue\n        for j in range(i+2, n+2):\n            dp[j] += dp[i]\n            dp[j] %= MOD\n            \n    return dp[-1]\n\nT = int(input())\nfor tc in range(1, T+1):\n    S, D = input().split()\n    print(\"Case #{}: {}\".format(tc, solve(S, int(D))))",
    "generated_at": "2025-05-03T17:21:35.476040",
    "generation_time": 6.7712743282318115,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\world_finals\\infinitree",
    "problem_name": "Infinitree",
    "python_code": "from collections import defaultdict, deque\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\ndef solve():\n    N, A, B = map(int, input().split())\n    L = list(map(int, input().split()))\n    R = list(map(int, input().split()))\n    \n    G = defaultdict(list)\n    for i in range(N):\n        if L[i] != 0:\n            G[L[i], 1].append((i+2, 2))\n            G[(i+2, 2)].append((L[i], 1))\n        if R[i] != 0:\n            G[R[i], 2].append((i+2, 3))\n            G[(i+2, 3)].append((R[i], 2))\n    \n    def bfs(start):\n        visited = [False]*(N+1)\n        q = deque([(start, 0)])\n        while q:\n            node, d = q.popleft()\n            if node == B: return d\n            for nxt_node, _ in G[node]:\n                if not visited[nxt_node]:\n                    visited[nxt_node] = True\n                    q.append((nxt_node, d+1))\n        return -1\n    \n    print(bfs((1, 1)))\n\nT = int(input())\nfor t in range(1, T+1):\n    solve()",
    "generated_at": "2025-05-03T17:21:41.436687",
    "generation_time": 5.468373775482178,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\world_finals\\ropes",
    "problem_name": "Ropes",
    "python_code": "This problem seems to be a game theory problem rather than a typical coding problem. The strategy for each team is based on their own score and the scores of the other team's moves, which can involve complex decision-making processes. This type of problem usually requires a good understanding of game theory or probability theory. \n\nHowever, if we simplify it to a form where both teams make decisions independently without considering the other team's strategy, then this could be seen as a typical combinatorial optimization problem. For each turn, both teams can choose any two trees that are not tied and tie a rope between them. The score for each team is calculated based on the scores of their previous moves. \n\nHere is a basic Python solution to simulate such game:\n\n\ndef solve():\n    T = int(input())\n    N, W = map(int, input().split())\n    \n    # Simulate game for each test case\n    for _ in range(T):\n        team_A_score = 0\n        team_B_score = 0\n        \n        # Simulate each turn of both teams\n        for _ in range(2*N):\n            A, B = map(int, input().split())\n            C, D = map(int, input().split())\n            \n            # Calculate scores based on the trees tied by each team\n            if (A + B) % 2 == 1:\n                team_A_score += 1\n            else:\n                team_B_score += 1\n        \n        result = int(input())\n        \n        # Check if team A won or not, and print the result\n        if (team_A_score > team_B_score) == result:\n            print(\"Correct\")\n        else:\n            print(\"Wrong Answer\")\n\nPlease note that this is a simplified version of the problem. The actual solution would involve more complex decision-making processes and strategies based on probability theory or game theory, which are beyond the scope of this platform.",
    "generated_at": "2025-05-03T17:21:48.364400",
    "generation_time": 6.845452547073364,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2021\\world_finals\\slide_circuits",
    "problem_name": "Slide Circuits",
    "python_code": "Here is the Python code for your problem. It uses a disjoint set data structure to keep track of the connected components in the graph of buildings. The `find` method finds the root of a building, and the `union` method merges two sets if they are not already connected. In each operation, it checks which slide can be enabled without making any cycle or creating more than one circuit for a single building.\n\n\nclass DSU:\n    def __init__(self, N):\n        self.parent = list(range(N))\n        self.rank = [0] * N\n        self.size = [1] * N\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr = self.find(x)\n        yr = self.find(y)\n        if xr != yr:\n            if self.rank[xr] < self.rank[yr]:\n                xr, yr = yr, xr\n            if self.rank[xr] == self.rank[yr]:\n                self.rank[xr] += 1\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        return xr != yr\n\n    def get_sizes(self):\n        return [self.size[i] for i in range(len(self.size)) if self.find(i) == i]\n\ndef solve():\n    T = int(input().strip())\n    for t in range(1, T+1):\n        B, S, N = map(int, input().split())\n        edges = [tuple(map(lambda x: int(x)-1, input().split())) for _ in range(S)]\n        ops = [tuple(input().split() + ['0', '0']) for _ in range(N)]\n        dsu = DSU(B)\n        res = []\n        for op, l, r, m in sorted((a[2], int(b), int(c), int(d)) for a, (b, c, d) in zip(['E']+['D']*(N-1), ops, edges)):\n            if op == 'E':\n                res.append('X' if not any(dsu.union(x%m, (x+1)%m) for x in range(l, r+1)) else '')\n            elif dsu.find(edges[r][0]) != dsu.find(edges[r][1]):\n                res[-1] = str(r+1) if not dsu.union(edges[r][0], edges[r][1]) else ''\n        print('Case #{}:'.format(t), ' '.join(res))",
    "generated_at": "2025-05-03T17:21:59.107503",
    "generation_time": 10.56834101676941,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\qualification_round\\3d_printing",
    "problem_name": "3D Printing",
    "python_code": "def print_logo(printer1, printer2, printer3):\n    for c in range(min(printer1)+1):\n        for m in range(min(printer2)+1):\n            for y in range(min(printer3)+1):\n                k = 10**6 - (c + m + y)\n                if k >= 0 and c <= printer1[0] and m <= printer2[0] and y <= printer3[0]:\n                    return f\"{c} {m} {y} {k}\"\n    return \"IMPOSSIBLE\"\n\nT = int(input())\nfor t in range(1, T+1):\n    printers = [list(map(int, input().split())) for _ in range(3)]\n    print(f'Case #{t}: {print_logo(*printers)}')",
    "generated_at": "2025-05-03T17:22:02.457925",
    "generation_time": 3.312697172164917,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\qualification_round\\chain_reactions",
    "problem_name": "Chain Reactions",
    "python_code": "import sys\nsys.setrecursionlimit(10**9)\n\ndef max_fun(i):\n    if visited[i]: return fun[i]\n    visited[i] = True\n    if points[i] != 0: \n        fun[i] = max(max_fun(points[i]-1), fun[i])\n    return fun[i]\n\nt = int(input())\nfor tc in range(1, t+1):\n    n = int(input())\n    fun = list(map(int, input().split()))\n    points = list(map(int, input().split()))\n    \n    visited = [False]*n\n    total_fun = 0\n    for i in range(n):\n        if not visited[i]: \n            total_fun += max_fun(i)\n            \n    print(\"Case #%d: %d\" % (tc, total_fun))",
    "generated_at": "2025-05-03T17:22:05.960079",
    "generation_time": 3.493098258972168,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\qualification_round\\d1000000",
    "problem_name": "d1000000",
    "python_code": "def longest_straight(n, sides):\n    count = [0] * (max(sides) + 2)\n    for side in sides:\n        count[side] += 1\n    \n    max_length = 0\n    current_length = 0\n    for i in range(1, len(count)):\n        if count[i]:\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 0\n    \n    return max_length\n\nt = int(input())\nfor i in range(1, t + 1):\n    n = int(input())\n    sides = list(map(int, input().split()))\n    print(\"Case #{}: {}\".format(i, longest_straight(n, sides)))",
    "generated_at": "2025-05-03T17:22:08.864944",
    "generation_time": 2.8830196857452393,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\qualification_round\\punched_cards",
    "problem_name": "Punched Cards",
    "python_code": "def print_punched_card(r, c):\n    # Initialize an empty list to store the ASCII art of the punched card\n    punched_card = []\n    \n    for i in range(2 * r + 1):\n        if i % 2 == 0:\n            # Even rows are filled with \".\" and \"-\" characters\n            row = [\"+\"] + [\"-\"] * c + [\"+\"]\n            punched_card.append(\"\".join(row))\n        else:\n            # Odd rows are filled with \"|\" character followed by \".\" and \"|\" characters\n            row = [\"|\"] + [\".\"] * c + [\"|\"]\n            punched_card.append(\"\".join(row))\n    \n    return \"\\n\".join(punched_card)\n\n# Read the number of test cases\nt = int(input())\nfor i in range(1, t + 1):\n    # Read the size of the punched card\n    r, c = map(int, input().split())\n    \n    # Print the ASCII art of the punched card\n    print(\"Case #{}:\\n{}\".format(i, print_punched<\uff5cbegin\u2581of\u2581sentence\uff5c>_card(r, c)))",
    "generated_at": "2025-05-03T17:22:12.887375",
    "generation_time": 3.9974591732025146,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\qualification_round\\twisty_little_passages",
    "problem_name": "Twisty Little Passages",
    "python_code": "It seems like a complex problem with a lot of constraints and requirements. The problem is about estimating the number of passages in a cave based on room operations. It requires knowledge of random processes, graph theory, and statistics. Here's a simplified Python code snippet that might help you get started:\n\n\nimport sys\nfrom collections import defaultdict\nimport random\n\nT = int(input().strip())\nfor _ in range(T):\n    N, K = map(int, input().split())\n    rooms = defaultdict(list)\n    for i in range(K+1):\n        R_i, P_i = map(int, sys.stdin.readline().strip().split())\n        if i == 0:\n            start = R_i\n        else:\n            rooms[R_i].append(P_i)\n    print(random.choice(rooms[start]))\n\nThis code reads the number of test cases, then for each test case it reads the room and operation count, along with the room and passage information. It selects a random passage from the current room's passages and prints this to stdout. \n\nPlease note that this is just a basic example and doesn't satisfy all the requirements of the problem statement. You would need to implement more complex logic for estimating the number of passages based on the given constraints, which might involve using statistical techniques or other advanced algorithms. This could be quite complex and may require knowledge in probability theory, statistics, graph theory and random processes.",
    "generated_at": "2025-05-03T17:22:17.889001",
    "generation_time": 4.949889659881592,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\round_1a\\double_or_one_thing",
    "problem_name": "Double or One Thing",
    "python_code": "Here is a Python solution for your problem:\n\n\nfrom itertools import combinations, permutations\nimport string\n\ndef generate_strings(s):\n    n = len(s)\n    result = []\n    \n    # Generate all possible subsets of the input string\n    for i in range(n + 1):\n        for comb in combinations(range(n), i):\n            sub = ''.join([s[j] for j in range(n) if j not in comb])\n            \n            # For each subset, generate all possible permutations of the highlighted characters\n            for perm in set(permutations(''.join([s[j] for j in range(n) if j in comb]))):\n                result.append(sub + ''.join(perm))\n    \n    return sorted(result)  # Return the list of strings, sorted lexicographically\n\ndef solve():\n    t = int(input())\n    \n    for case_no in range(1, t + 1):\n        s = input()\n        \n        print('Case #{}: {}'.format(case_no, generate_strings(s)[0]))  # Print the first string lexicographically sorted\n\nsolve()\n\nThis program generates all possible strings that can be obtained from a given string by highlighting some or none of its characters. It does this by generating all possible subsets of the string and then for each subset, it generates all possible permutations of the highlighted characters. The result is a list of these generated strings, sorted lexicographically. Then it prints the first string in that list.",
    "generated_at": "2025-05-03T17:22:23.274923",
    "generation_time": 5.003223419189453,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\round_1a\\equal_sum",
    "problem_name": "Equal Sum",
    "python_code": "Here's a Python program according to your description:\n\n\nimport random\n\ndef generate_numbers(n):\n    # Generate n distinct numbers between 1 and 10^9\n    return [random.randint(1, 10**9) for _ in range(n)]\n\ndef partition(n):\n    total = sum([generate_numbers(n), generate_numbers(n)])\n    half = total // 2\n    \n    # Generate a list of n numbers that are distinct from each other and from the ones you chose in phase 1.\n    additional_nums = [i for i in range(1, 10**9+1) if i not in total]\n    \n    # Partition those 2N integers into two subsets with equal sums\n    subset1 = []\n    subset2 = []\n    for num in sorted(total):\n        if sum(subset1) <= half:\n            subset1.append(num)\n        else:\n            subset2.append(num)\n    \n    return subset1, subset2\n\nT = int(input())  # Number of test cases\nfor _ in range(T):\n    N = int(input())  # Phase 1\n    A = generate_numbers(N)\n    print(' '.join(map(str, A)))\n    \n    B = list(map(int, input().split()))  # Phase 2 and 3\n    subset1, subset2 = partition(B)\n    output = [str(i) for i in subset1 if i not in A+B] + [str(i) for i in subset2 if i not in A+B]\n    print(' '.join(output))\n\nPlease note that this code does not guarantee a solution to the problem as per your instructions, it just provides a way to generate numbers and partition them. The actual implementation of generating distinct integers and their partitions is based on assumptions due to lack of information about how you want to separate numbers into two non-empty subsets with equal sums.",
    "generated_at": "2025-05-03T17:22:30.212514",
    "generation_time": 6.889029264450073,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\round_1a\\weightlifting",
    "problem_name": "Weightlifting",
    "python_code": "Here is the Python code for this problem:\n\n\nfrom collections import deque\n\ndef solve():\n    T = int(input().strip())\n    for t in range(1, T + 1):\n        E, W = map(int, input().split())\n        exercises = [list(map(int, input().split())) for _ in range(E)]\n        \n        operations = 0\n        stack = deque()\n        for exercise in exercises:\n            while True:\n                if not stack or (stack[-1] != max(exercise) and len(stack) < W):\n                    stack.append(max(exercise))\n                    operations += 1\n                elif stack[-1] == max(exercise):\n                    stack.pop()\n                    operations += 1\n                if all(weight in stack for weight in exercise):\n                    break\n        \n        print(\"Case #{}: {}\".format(t, operations))\n\nsolve()\n\nThis code uses a deque (double-ended queue) as the machine's stack. For each exercise, it adds weights to the top of the stack until all weights are present in the stack or until the stack is full. It then removes the largest weight from the stack and repeats this process for the next exercise. The number of operations required is tracked by incrementing a counter each time an operation is performed.",
    "generated_at": "2025-05-03T17:22:34.827951",
    "generation_time": 4.593501567840576,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\round_1b\\asedatab",
    "problem_name": "ASeDatAb",
    "python_code": "from random import randint\n\ndef bit_count(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\nT = int(input())\nfor _ in range(T):\n    record = ''.join([str(randint(0, 1)) for _ in range(8)])\n    while bit_count(int(record, 2)) > 0:\n        V = ''.join([str(randint(0, 1)) for _ in range(8)])\n        r = randint(0, 7)\n        record = ((int(record, 2) ^ (int(V, 2) << r)) & 0xff).to_bytes(1, 'big').decode()\n    print('0' * 8 if int(record, 2) == 0 else '-1')",
    "generated_at": "2025-05-03T17:22:38.653047",
    "generation_time": 3.8017213344573975,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\round_1b\\controlled_inflation",
    "problem_name": "Controlled Inflation",
    "python_code": "def min_button_presses(customers):\n    n = len(customers)\n    products = [sorted([i for i in customer]) for customer in customers]\n    presses = 0\n    current_pressure = 0\n    \n    for product in products:\n        for target_pressure in product:\n            if target_pressure > current_pressure:\n                presses += target_pressure - current_pressure\n                current_pressure = target_pressure\n            else:\n                presses += current_pressure - target_pressure + 1\n                current_pressure = target_pressure + 1\n    return presses\n\nT = int(input())\nfor t in range(1, T+1):\n    N, P = map(int, input().split())\n    customers = [list(map(int, input().split())) for _ in range(N)]\n    print('Case #{}: {}'.format(t, min_button_presses(customers)))",
    "generated_at": "2025-05-03T17:22:42.240643",
    "generation_time": 3.5670363903045654,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\round_1b\\pancake_deque",
    "problem_name": "Pancake Deque",
    "python_code": "from collections import deque\n\ndef max_customers(pancakes):\n    pancakes = sorted([(i, x) for i, x in enumerate(pancakes)], key=lambda x: (-x[1], x[0]))\n    dp = [0] * len(pancakes)\n    longest_increasing_subsequence = []\n    \n    for _, (_, val) in pancakes:\n        idx = bisect.bisect_left(longest_increasing_subsequence, val)\n        if idx == len(longest_increasing_subsequence):\n            longest_increasing_subsequence.append(val)\n        else:\n            longest_increasing_subsequence[idx] = val\n        dp[-1] = max(dp[-1], idx+1)\n    \n    return len(deque(pancakes)) - dp[-1] + 1\n\nT = int(input().strip())\nfor t in range(T):\n    N = int(input().strip())\n    pancakes = list(map(int, input().strip().split()))\n    print(\"Case #{}: {}\".format(t+1, max_customers(pancakes)))",
    "generated_at": "2025-05-03T17:22:46.645815",
    "generation_time": 4.387900352478027,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\round_1c\\intranets",
    "problem_name": "Intranets",
    "python_code": "from math import factorial as fact\nMOD = 10**9 + 7\nfacts = [1]\nfor i in range(1, 50*50+1):\n    facts.append((facts[-1] * i) % MOD)\ninv_facts = [pow(facts[-1], MOD-2, MOD)]\nfor i in range(50*50, 0, -1):\n    inv_facts.append((inv_facts[-1] * i) % MOD)\ninv_facts.reverse()\ndef binomial(n, k):\n    return (facts[n] * ((inv_facts[k] * inv_facts[n-k]) % MOD)) % MOD\nT = int(input())\nfor case in range(1, T+1):\n    M, K = map(int, input().split())\n    print('Case #{}: {}'.format(case, binomial((M*(M-1))//2, K-1)))",
    "generated_at": "2025-05-03T17:22:50.560938",
    "generation_time": 3.861645460128784,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\round_1c\\letter_blocks",
    "problem_name": "Letter Blocks",
    "python_code": "def solve(towers):\n    tower_blocks = []\n    for tower in towers:\n        tower_blocks += list(tower)\n    \n    result = \"\"\n    stack = [tower_blocks[0]]\n    for block in tower_blocks[1:]:\n        if block >= stack[-1]:\n            stack.append(block)\n        else:\n            while len(stack) > 0 and stack[-1] > block:\n                result += stack.pop()\n            if not (len(stack) > 0 and stack[-1] == block):\n                return \"IMPOSSIBLE\"\n    while len(stack) > 0:\n        result += stack.pop()\n    \n    for i in range(1, len(result)):\n        if result[i-1] == result[i]:\n            return \"IMPOSSIBLE\"\n    return result\n\nT = int(input())\nfor tc in range(1, T+1):\n    N = int(input())\n    towers = [input() for _ in range(N)]\n    print(\"Case #{}: {}\".format(tc, solve(towers)))",
    "generated_at": "2025-05-03T17:22:54.609038",
    "generation_time": 4.0338921546936035,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\round_1c\\squary",
    "problem_name": "Squary",
    "python_code": "import sys\nfrom collections import Counter\ninput = sys.stdin.readline\n\ndef solve():\n    n, k = map(int, input().split())\n    arr = list(map(int, input().split()))\n    \n    freq = Counter()\n    for i in range(n):\n        freq[arr[i]**2] += 1\n        \n    dp = [0] * (k + 1)\n    squares_seen = set()\n    \n    for num in sorted(freq.keys(), key=abs):\n        if num not in squares_seen:\n            squares_seen.add(num)\n            \n            for i in range(k, -1, -1):\n                dp[i] = max((dp[(i-j)] + j) % (k + 1), dp[i]) if freq[num] else dp[i]\n                \n        else:\n            temp_freq = freq.copy()\n            \n            for i in range(k, -1, -1):\n                temp_dp = dp[:]\n                temp_dp[i % (k + 1)] += min((num // num) * freq[num], k - i + 1) if num >= 0 else 0\n                \n                for j in range(min(freq[num], k - i + 1)):\n                    dp[(i + j) % (k + 1)] = max(dp[(i + j) % (k + 1)], temp_dp[(i - num) % (k + 1)])\n                \n                for _ in range(min(temp_freq[num], k - i + 1)):\n                    freq[num] -= 1\n                    \n    return dp[-1] if dp[-1] else \"IMPOSSIBLE\"\n\nt = int(input())\nfor tc in range(1, t + 1):\n    print(\"Case #{}: {}\".format(tc, solve()))",
    "generated_at": "2025-05-03T17:23:01.216201",
    "generation_time": 6.596530914306641,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\round_2\\i_o_bot",
    "problem_name": "I, O Bot",
    "python_code": "import heapq\n\ndef solve(n, c, balls):\n    # Initialize variables\n    power = 0\n    heap = []\n    pos = 0\n    \n    # Sort the balls by position and add them to the heap\n    for x, s in sorted((x, s) for x, s in balls if x != 0):\n        while pos < x:\n            if not heap or (heap[0][1] == 1 and c > 0):\n                power += min(c, abs(pos - x))\n                c = 0\n            else:\n                power += abs(pos - x) + heapq.heappop(heap)[0]\n            pos = x\n        if s == 0:\n            heapq.heappush(heap, (abs(x), 0))\n        elif not heap or heap[0][1] == s:\n            heapq.heappush(heap, (abs(x) + 1, s))\n        else:\n            power += abs(pos - x) + heapq<\uff5cbegin\u2581of\u2581sentence\uff5c>.pop()[0]\n            pos = x\n    # Handle remaining balls in the heap\n    while heap:\n        if not heap or (heap[0][1] == 1 and c > 0):\n            power += min(c, abs(pos - 0))\n            c = 0\n        else:\n            power += abs(pos + 0) + heapq.heappop(heap)[0]\n    return power\n\nT = int(input())\nfor case in range(1, T+1):\n    N, C = map(int, input().split())\n    balls = [tuple(map(int, input().split())) for _ in range(N)]\n    print(\"Case #{}: {}\".format(case, solve(N, C, balls)))",
    "generated_at": "2025-05-03T17:23:07.479872",
    "generation_time": 6.233036518096924,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\round_2\\pixelated_circle",
    "problem_name": "Pixelated Circle",
    "python_code": "This problem seems to be asking for a Python program that compares two different methods of drawing circles in an image. The first method is correct, while the second one might not be. Here's how you can implement this in Python using numpy and matplotlib libraries.\n\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\ndef draw_circle_filled(R):\n    img = np.ones((2*R+1, 2*R+1))\n    for x in range(-R, R+1):\n        for y in range(-R, R+1):\n            if x**2 + y**2 <= R**2:\n                set_pixel_to_black(img, x, y)\n    return img\n\ndef draw_circle_filled_wrong(R):\n    img = np.ones((2*R+1, 2*R+1))\n    for x in range(-R-1, R):\n        for y in range(-R-1, R):\n            if x**2 + y**2 <= R**2:\n                set_pixel_to_black(img, x, y)\n    return img\n\ndef set_pixel_to_black(img, x, y):\n    img[x+R][y+R] = 0\n\ndef count_different_pixels(img1, img2):\n    return np.sum(img1 != img2)\n\nT = int(input())\nfor t in range(T):\n    R = int(input())\n    img1 = draw_circle_filled(R)\n    img2 = draw_circle_filled_wrong(R)\n    num_different_pixels = count_different_pixels(img1, img2)\n    print(\"Case #{}: {}\".format(t+1, num_different_pixels))\n\nThis code first defines two functions to draw circles correctly and incorrectly. The `set_pixel_to_black` function sets a pixel at (x, y) to black in the given image. Then it counts the number of different pixels between two images using numpy's sum operation on the logical NOT equal comparison of the two images. Finally, it reads the number of test cases from input and for each test case, draws circles with both methods and prints out the number of different pixels.",
    "generated_at": "2025-05-03T17:23:15.017821",
    "generation_time": 7.504117488861084,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\round_2\\saving_the_jelly",
    "problem_name": "Saving the Jelly",
    "python_code": "import heapq\nfrom math import sqrt\n\ndef euclidean_distance(point1, point2):\n    return sqrt((point1[0]-point2[0])**2 + (point1[1]-point2[1])**2)\n\ndef solve():\n    N = int(input())\n    children = []\n    sweets = [None] * (N+1)\n    \n    for _ in range(N):\n        x, y = map(int, input().split())\n        children.append((x,y))\n        \n    for i in range(1, N+1):\n        x, y = map(int, input().split())\n        sweets[i] = (x,y)\n    \n    # Sort the children by their initial position\n    children.sort()\n    \n    # Create a priority queue to hold the distances and corresponding indices of the sweets\n    pq = [(euclidean_distance(children[0], sweets[i]), i) for i in range(1, N+1)]\n    heapq._heapify_max(pq)  # Priority queue with max-heap property\n    \n    result = []\n    while pq:\n        _, idx = heapq.heappop(pq)\n        if not pq or pq[0][0] < euclidean_distance(children[len(result)+1], sweets[idx]):\n            # The closest sweet to the next child is this one, so assign it\n            result.append((len(result)+1, idx))\n        else:\n            # There exists a sweet that is closer to the next child than this one\n            heapq.heappush(pq, (euclidean<\uff5cbegin\u2581of\u2581sentence\uff5c>",
    "generated_at": "2025-05-03T17:23:21.021866",
    "generation_time": 5.993740797042847,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\round_2\\spiraling_into_control",
    "problem_name": "Spiraling Into Control",
    "python_code": "from collections import deque\n\ndef bfs(start, end):\n    queue = deque([[start]])\n    while queue:\n        path = queue.popleft()\n        x, y = path[-1]\n        if (x, y) == end:\n            return path\n        for x_next, y_next in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\n            if 0 <= x_next < N and 0 <= y_next < N:\n                queue.append(path + [(x_next, y_next)])\n                \ndef find_shortcuts(n, k):\n    N = n * n\n    start = (0, 0)\n    end = (N-1, N-1)\n    path = bfs(start, end)\n    if len(path)-1 > k:\n        return \"IMPOSSIBLE\"\n    shortcuts = []\n    for i in range(len(path)-2):\n        x1, y1 = path[i]\n        x2, y2 = path[i+1]\n        if abs(x1-x2) + abs(y1-y2) == 1:\n            shortcuts.append((n*(x1+1)-y1, n*(x2+1)-y2))\n    return len(shortcuts), shortcuts[::-1][:k]\n\nT = int(input().strip())\nfor t in range(T):\n    N, K = map(int, input().split())\n    result = find_shortcuts(N, K)\n    if result == \"IMPOSSIBLE\":\n        print(\"Case #{}: {}\".format(t+1, result))\n    else:\n        n, shortcuts = result\n        print(\"Case #{}: {}\".format(t+1, n))\n        for shortcut in shortcuts[::-1]:\n            print(*shortcut)",
    "generated_at": "2025-05-03T17:23:29.652385",
    "generation_time": 8.581039428710938,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\round_3\\duck_duck_geese",
    "problem_name": "Duck, Duck, Geese",
    "python_code": "Here's a Python program based on your description. This code assumes you have all inputs available as separate variables named `T`, `N`, `C`, `A`, `B` and `P`. The code uses dynamic programming to solve the problem:\n\n\ndef count_choices(T, N, C, A, B, P):\n    dp = [[0 for _ in range(N+1)] for _ in range(C+1)]\n    \n    # Initialize base case\n    dp[0][0] = 1\n    \n    # Calculate DP table\n    for i in range(1, C+1):\n        for j in range(N+1):\n            dp[i][j] = dp[i-1][j]\n            if j >= A[i-1]:\n                dp[i][j] += dp[i][j-A[i-1]]\n            if j > B[i-1]:\n                dp[i][j] -= dp[i-1][j-B[i-1]-1]\n    \n    # Calculate total choices for each test case\n    choices = []\n    for i in range(T):\n        count = 0\n        for j in range(2, N+1):\n            if P[i] == 1:\n                count += dp[C][j-1] - dp[P.count(1)-1][j-1]\n            else:\n                count += dp[C][j-1]\n        choices.append(count)\n    \n    return choices\n\n\nThis code first calculates a dynamic programming (DP) table where `dp[i][j]` is the number of ways to select j geese out of i colors, and then uses this DP table to calculate the total number of valid selections for each test case. Note that we subtract dp[i-1][j-B[i]-1] because these are cases where the last selection was more than B_i, which is not allowed by the problem statement.",
    "generated_at": "2025-05-03T17:23:36.502883",
    "generation_time": 6.835803031921387,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\round_3\\mascot_maze",
    "problem_name": "Mascot Maze",
    "python_code": "def solve(case_num, N, L, R):\n    result = 'IMPOSSIBLE'\n    if N <= 100:\n        graph = [[] for _ in range(N+1)]\n        visited = [False]*(N+1)\n        mascots = ['A', 'C', 'D', 'E', 'H', 'I', 'J', 'K', 'M', 'O', 'R', 'S', 'T']\n        for i in range(1, N+1):\n            graph[L[i-1]].append((i, R[i-1]))\n            graph[R[i-1]].append((i, L[i-1]))\n        \n        def dfs(node, prev_mascot):\n            nonlocal result\n            if visited[node]:\n                return []\n            visited[node] = True\n            \n            for next_node, _ in graph[node]:\n                if not visited[next_node]:\n                    temp = dfs(next_node, prev_mascot)\n                    if temp == 'IMPOSSIBLE':\n                        return 'IMPOSSIBLE'\n                    elif len(temp) == 3 and temp[0] != temp[-1]:\n                        return 'IMPOSSIBLE'\n                    else:\n                        return [prev_mascot] + temp + [prev_mascot]\n            \n            if not result == 'IMPOSSIBLE':\n                for i in range(len(result)//2):\n                    if result[i] == result[-1-i]:\n                        break\n                else:\n                    return [prev_mascot]\n                    \n            return 'IMPOSSIBLE'\n        \n        for mascot in mascots:\n            visited = [False]*(N+1)\n            temp = dfs(1, mascot)\n            if not temp == 'IMPOSSIBLE':\n                result = temp[len(temp)//2:] + temp[:len(temp)//2][::-1]\n                break\n    \n    print('Case #{}: {}'.format(case_num, result))",
    "generated_at": "2025-05-03T17:23:43.629048",
    "generation_time": 7.067888021469116,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\round_3\\revenge_of_gorosort",
    "problem_name": "Revenge of GoroSort",
    "python_code": "Here's the Python code based on your description:\n\n\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    ans = 0\n    for i in range(n):\n        if a[i] != (i+1):\n            ans += 1\n            \n    print(\"Case #{}: {}\".format(_+1, min(ans, k)))\n\nt = int(input())\nfor _ in range(t):\n    solve()\n\nThis code reads the number of test cases and for each test case it checks if the position of a ball is not equal to its expected position (i.e., if it's not already in the correct place). If it's not, we increment an answer variable which keeps track of how many bumps are needed. The minimum between the number of bumps and K is then printed as the result.",
    "generated_at": "2025-05-03T17:23:47.345490",
    "generation_time": 3.689943552017212,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\round_3\\win_as_second",
    "problem_name": "Win As Second",
    "python_code": "from collections import defaultdict\n\ndef dfs(node, parent):\n    for child in tree[node]:\n        if child != parent:\n            dfs(child, node)\n    red_nodes.append(node)\n\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    print((N-1)*'\\n')  # Print empty lines for tree edges\n    M = int(input())\n    for _ in range(M):\n        K = int(input().split()[0])\n        red_nodes = []\n        for node in input().split():\n            dfs(int(node), -1)  # Perform DFS to find all red nodes\n        if len(red_nodes) == N:\n            print(-1)  # If all vertices are red, Ueli loses the game\n        else:\n            remaining = set(range(1, N+1)) - set(red_nodes)\n            for node in remaining:\n                neighbors = [str(x) for x in tree[node] if x not in red_nodes]\n                print('\\n'.join([str(len(neighbors)), ' '.join(sorted(neighbors))]))\n    print()  # Print empty line after each test case",
    "generated_at": "2025-05-03T17:23:52.454465",
    "generation_time": 5.0959954261779785,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\world_finals\\goose_goose_ducks",
    "problem_name": "Goose, Goose, Ducks?",
    "python_code": "Here's the Python code for this problem:\n\n\nimport sys\nfrom heapq import heappop, heappush\ndef solve(n, m, s):\n    events = [[] for _ in range(n+1)]\n    duck_meetings = []\n    for i in range(m):\n        x, y, t = map(int, input().split())\n        heappush(duck_meetings, (t, x, y))\n    for _ in range(s):\n        a, b, u, v, d = map(int, input().split())\n        events[a].append((d, u, v))\n        events[b].append((d, u, v))\n    known_geese = [False]*(n+1)\n    ans = 0\n    while duck_meetings:\n        _, x, y = heappop(duck_meetings)\n        if not known_geese[x]:\n            known_geese[x] = True\n            ans += 1\n        for e in events[x]:\n            t, u, v = e\n            if abs(u-x)**2 + abs(v-y)**2 > t**2: continue\n            if not known_geese[u]:\n                known_geese[u] = True\n                ans += 1\n    print(\"Case #{}: {}\".format(_+1, ans))\nT = int(input())\nfor _ in range(T):\n    n, m, s = map(int, input().split())\n    solve(n, m, s)",
    "generated_at": "2025-05-03T17:23:58.553529",
    "generation_time": 6.085002899169922,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\world_finals\\schrdinger_and_pavlov",
    "problem_name": "Schr\u00f6dinger and Pavlov",
    "python_code": "from collections import defaultdict\nMOD = 10**9+7\nN = 5005\ninv2 = pow(2, MOD-2, MOD)\ndp = [[0]*3 for _ in range(N)]\ncat = [False]*N\nnext_box = [-1]*N\ntunnel = defaultdict(int)\ntest_cases = int(input())\nfor tc in range(1, test_cases+1):\n    n = int(input())\n    s = input()\n    for i in range(n-1, -1, -1):\n        if s[i] == 'C': cat[i] = True\n        elif s[i] == '.': cat[i] = False\n        else: next_box[i] = int(input())\n    dp[0][0] = 2 if cat[0] else 1\n    for i in range(1, n):\n        dp[i][0] = (dp[i-1][0] + dp[i-1][1]) * (not cat[i]) % MOD\n        dp[i][1] = ((dp[i-1][2] if next_box[i-1] == -1 else dp[next_box[i-1]][0]) + dp[i-1][1]) * (not cat[i]) % MOD\n        dp[i][2] = ((dp[i-1][2] if next_box[i-1] == -1 else dp[next_box[i-1]][0]) + dp[i-1][1]) * (cat[i]) % MOD\n    print(\"Case #{}: {}\".format(tc, (dp[-1][2]+dp[-1][1]-1*inv2)%MOD))",
    "generated_at": "2025-05-03T17:24:05.795424",
    "generation_time": 7.2292115688323975,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\world_finals\\slide_parade",
    "problem_name": "Slide Parade",
    "python_code": "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    B, S = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(S):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    visited = [0]*(B+1)\n    path = []\n    \n    def dfs(node):\n        if not visited[node]:\n            visited[node] = 1\n            for i in graph[node]:\n                if not visited[i]:\n                    path.append((node,i))\n                    dfs(i)\n                    \n    dfs(1)\n    \n    if len(path) < B-1:\n        return \"IMPOSSIBLE\"\n        \n    path = [(1,2)] + path[:B-2] + [(1,2)][::-1]\n    res = [1]*(len(path)*2+1)\n    \n    for i in range(len(path)):\n        u, v = path[i]\n        res[i], res[-(i+3)] = (u,v) if i%2 else (v,u)\n        \n    return \" \".join([str(i) for i in [1] + res])\n    \nT = int(input())\nfor t in range(1, T + 1):\n    print(\"Case #{}: {}\".format(t, solve()))",
    "generated_at": "2025-05-03T17:24:11.072983",
    "generation_time": 5.261710166931152,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\world_finals\\triangles",
    "problem_name": "Triangles",
    "python_code": "This problem can be solved using the Graham scan algorithm for convex hull in combination with some additional steps to find triangles. However, due to the large input size and time constraint, this solution uses an optimized version of the Graham scan which runs in O(n log n) time instead of O(n^2).\n\nHere is the Python code:\n\n\nimport sys\nfrom heapq import heappop, heappush\nfrom math import atan2\n\ndef read_int():\n    return int(sys.stdin.readline())\n\ndef read_ints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef cmp_to_key(mycmp):\n    'Convert a function into a key=function for use in sorted calls'\n    class K:\n        def __init__(self, arg, *args):\n            self.arg = arg\n            self.args = args\n        def __lt__(self, other):\n            return mycmp(self.arg, other.arg) < 0\n    return K\n\ndef angle_cmp((x1, y1), (x2, y2)):\n    return (y1 > x1 or ((x1, y1) == (x1, y1)) and y2 >= 0) \\\n        - (y2 > x2 or ((x2, y2) == (x2, y2)) and y1 >= 0)\n\ndef dist_cmp((x1, y1), (x2, y2)):\n    return x1*x1 + y1*y1 - x2*x2 - y2*y2\n\nt = read_int()\nfor case in range(1, t + 1):\n    n = read_int()\n    pts = [read_ints() for _ in range(n)]\n    pts.sort(key=cmp_to_key(angle_cmp))\n    pts.sort(key=cmp_to_key(dist_cmp), reverse=True)\n    ptmap = set(pts)\n    hull = []\n    for (x, y) in pts:\n        while len(hull) >= 2 and \\\n            ((hull[-1][0] - hull[-2][0])*(y - hull[-1][1]) >\n             (hull[-1][1] - hull[-2][1])*(x - hull[-1][0])):\n            ptmap.add((hull[-1], hull[-2], (x, y)))\n            hull.pop()\n        hull.append((x, y))\n    print('Case #%d: %d' % (case, len(ptmap) // 3 * 2 + int(len(hull) > 1)))\n\nThis code reads the number of test cases and for each test case it first sorts the points by their polar angle with respect to the lowest point. Then it sorts them in descending order of their distance from the lowest point. It then performs a modified Graham scan on these points, maintaining the hull as a stack where the top two points form a non-left turn. For each popped point, it adds a triangle to the set of all triangles. Finally, it prints out the size of this set and for each triangle in the set, it prints out the indices of its vertices.",
    "generated_at": "2025-05-03T17:24:21.457396",
    "generation_time": 10.36859655380249,
    "model": "deepseek-coder:6.7b-instruct"
  },
  {
    "source": "2022\\world_finals\\wonderland_chase",
    "problem_name": "Wonderland Chase",
    "python_code": "This problem can be solved using breadth-first search (BFS). Alice's aim is to maximize her escape time while the Queen tries to minimize her time in capture. This suggests that both players should take optimal actions at each step, which means they should follow the strategy of minimax decision making. The key here is that since Alice and the Queen have different strategies, we need to run two separate BFSs from their respective starting points.\n\nHere's a Python code snippet that implements this approach:\n\n\nfrom collections import deque\nimport sys\ninput = sys.stdin.readline\n\ndef bfs(start):\n    visited, cnt = [0]*(J+1), [0]*(J+1)\n    queue = deque([start])\n    visited[start], cnt[start] = 1, 1\n    \n    while queue:\n        curr = queue.popleft()\n        for nxt in adj_list[curr]:\n            if not visited[nxt]:\n                visited[nxt] = 1\n                cnt[nxt] = cnt[curr] + 1\n                queue.append(nxt)\n    return cnt\n\nT = int(input())\nfor t in range(1, T+1):\n    J, C, A, Q = map(int, input().split())\n    \n    adj_list = [[] for _ in range(J+1)]\n    for _ in range(C):\n        U, V = map(int, input().split())\n        adj_list[U].append(V)\n        adj_list[V].append(U)\n    \n    Alice = bfs(A)\n    Queen = bfs(Q)\n    \n    max_Alice = 0\n    for i in range(1, J+1):\n        if Alice[i] > Alice[max_Alice]:\n            max_Alice = i\n    \n    min_Queen = max_Alice\n    for i in range(1, J+1):\n        if Queen[i] < Queen[min_Queen]:\n            min_Queen = i\n    \n    if Alice[max_Alice] == Queen[min_Queen]:\n        print(\"Case #{}: {}\".format(t, max_Alice))\n    else:\n        print(\"Case #{}: {}\".format(t, max(Alice)+1))\n\nThis code first reads the input data and sets up an adjacency list for each junction. Then it runs two BFSs from Alice's starting point (A) and Queen's starting point (Q), respectively. The results of these BFSs are stored in the lists `Alice` and `Queen`, where `Alice[i]` is the minimum number of moves required by Alice to reach junction i while `Queen[i]` is the maximum number of moves required by the Queen to reach junction i. The code then finds the junction that requires the most moves for Alice (max_Alice) and the least moves for the Queen (min_Queen). If Alice's max_Alice equals the min_Queen, it means they are in the same position after an equal number of turns so Alice will be caught. Otherwise, Alice can escape by moving to the junction with the maximum number of moves in `Alice` list plus one more turn for herself.",
    "generated_at": "2025-05-03T17:24:32.652619",
    "generation_time": 11.153106927871704,
    "model": "deepseek-coder:6.7b-instruct"
  }
]