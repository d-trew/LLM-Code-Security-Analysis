from heapq import heappop as pop  # for efficient max-heap operations in Python's priority queue library)



def maximumFun(N: int): # N is the number of modules with fun factors F and points to another module or abyss.

    funFactors = [] 	   		
        pointsToModuleOrAbyss= [0] * (1 +  # indexing starts from zero, so we need an extra element in this list)


def maximumFun(N: int): # N is the number of modules with fun factors F and points to another module or abyss.

    funFactors = [] 	   		
        pointsToModuleOrAbyss= [0] * (1 +  # indexing starts from zero, so we need an extra element in this list)


for _test_caseNumberInInputRangeFromOnetoTinTestCasesGiven as testCase:

    N # number of modules with fun factors F and points to another module or abyss.
        funFactors = [0] * (1 + N )  # indexing starts from zero, so we need an extra element in this list) 		   	      


     pointsToModuleOrAbyss=list(map((lambda x:int), input().split())) # indices start with one and are numbered consecutively.
        for i_moduleNumberinRangeFromOnetoNInInputGiven as moduleIndex :  # loop through the modules, setting up points to abyss or other valid pointed-at index 		   	      


            if (pointsToModuleOrAbyss[i] ==0): # if no point is set yet then it's pointing at Abyss
                pass

        maxFun = -1 * float('inf')  # initialize maximum fun factor to negative infinity. There are better ways of initializing maxfun for this problem, but we use the worst case scenario here 		   	      


    for i_moduleNumberinRangeFromOnetoNInInputGiven as moduleIndex : # loop through each initiator
        if pointsToModuleOrAbyss[i] > N:  # if it's an abyss then skip this one. It doesn’t contribute to the maximum fun factor 		   	      


            continue

    for i_moduleNumberinRangeFromOnetoNInInputGiven as moduleIndex : # loop through each initiator
        if pointsToModuleOrAbyss[i] > N:  # if it's an abyss then skip this one. It doesn’t contribute to the maximum fun factor 		   	      


            continue

    for i_moduleNumberinRangeFromOnetoNInInputGiven as moduleIndex : # loop through each initiator
        if pointsToModuleOrAbyss[i] > N:  # if it's an abyss then skip this one. It doesn’t contribute to the maximum fun factor 		   	      


            continue

    for i_moduleNumberinRangeFromOnetoNInInputGiven as moduleIndex : # loop through each initiator
        if pointsToModuleOrAbyss[i] > N:  # if it's an abyss then skip this one. It doesn’t contribute to the maximum fun factor 		   	      


            continue

    print("Case #" + str(testCase) ": " , maxFun ) # print case number and calculate total sum of all chain reactions in a test-case