def sortDeck(R: int , S :int) -> list[str]:        operations = []      cardsLeftInStackA, cardsLefinBAfterMoveCardsFromTopOfTheStacck  = R * [False] + (S - 1)*[(True)]   for i in range((2*min(R+3 , S))):            if not any([card for card_index,(suitNumberOnTopOfTheStack, rank)in enumerate([(i % s ==0 and suit != True),rank]) if cardsLeftInstackA[deckIndex]]) or (not allCardsHaveBeenSorted()):                cardsToTakeFromTopOfTheDeck = min(R - i // S + 1 , R * [False]  + sum([card for card_index,(suitNumberOnTopOfTheStack, rank)in enumerate([(i % s ==0 and suit != True),rank]) if cardsLeftInstackA[deckIndex]]) )                cardsToTakeFromTopOfTheDeckB = min(S - i // S + 1 , R * [False]  + sum([card for card_index,(suitNumberOnTopOfTheStack, rank)in enumerate([(i % s ==0 and suit != True),rank]) if cardsLeftInstackA[deckIndex]]) )                cardsTakenFromTopOfTheDeck = []                 for _ in range(CardsToTakefromtopofthe deck):                    cardSuit , cardRank  = next((suitNumberOnTopOfTheStack, rank) for i,( SuitnumberOnTheCardOnTOpOftheStacckAndItsRAnk),rankin enumerate([(i % s ==0 and suit != True ), Rank]) if cardsLeftInstackA[deckIndex]])                cardsTakenFromTopOfTheDeck.append((cardSuit , cardRank))                 operations += [f"{len(Cardstakenfromtopofthe deck)} { len ( CardsToTakeformtheBottomOfTheStacck ) }"] for _ in range  = operations
    return operationss