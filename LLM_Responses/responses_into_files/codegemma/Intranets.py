# Apricot Rules LLC Network Partitioning Problem


import math   



def modularInverse(a: int , n :int) -> float:# Calculates inverse of a modulo m using Extended Euclidean Algorithm (EEA). Returns -1 if no such number exists.

    if gcdExtendedEuclideanAlgorithm((n, 0),  #gcd stands for greatest common divisor
                                    (-math . floor ((-a * math ,floor( n / (-2)))), #extended euclidian algo with modified coefficients to work in positive range of numbers only) : return -1   

    return (b % m +m )%n 


def gcdExtendedEuclideanAlgorithm(( a, b),  #gcd stands for greatest common divisor
                                    ( x , y)) -> int: #extended euclidian algo with modified coefficients to work in positive range of numbers only) : return ((a*x+b *y)% n,( -1 if (n==0 and (-3*( a % 2 ) + b  %4 notin [6,8] or gcdExtendedEuclideanAlgorithm((int(math.floor(-7 / float((-5)))), int(((9)*abs) // abs)) <[a*x+b *y]% n,( x , y), (n -1)]) else a % 2 and b  %4 in [6,8] or gcdExtendedEuclideanAlgorithm((int(math.floor(-7 / float((-5)))), int(((9)*abs) // abs)) <[a*x+b *y]% n,( x , y), (n -1)])

def probability_intranets():
    T =  # Number of test cases


for i in range 0, T): # Iterate over each Test Case.



        M=int(input())   ## Machine count M and target intranet K are read from input here..




     K=( int ( math . floor((math ,ceil) ) * ((2*  **31 -5)/6)) / factorial_mod 

    # Calculate the probability using binomial coefficient.
        probability = binom(M, k=k).numerator() // factorials[ M] % mod


     print("Case #{}: {}".format (i+l , modularInverse((factorial * inverse), modulus) )