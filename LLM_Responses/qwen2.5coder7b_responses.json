[
  {
    "source": "2016\\qualification_round\\coin_jam",
    "problem_name": "Coin Jam",
    "python_code": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_nontrivial_divisor(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0 and i != n // i:\n            return i\n    return None\n\ndef generate_jamcoin(length, num_jamcoins):\n    jamcoins = []\n    while len(jamcoins) < num_jamcoins:\n        jamcoin = '1' + ''.join('0' if i % 2 == 0 else '1' for i in range(1, length - 1)) + '1'\n        valid = True\n        for base in range(2, 11):\n            value = int(jamcoin, base)\n            if is_prime(value) or find_nontrivial_divisor(value) is None:\n                valid = False\n                break\n        if valid:\n            jamcoins.append((jamcoin, [find_nontrivial_divisor(int(jamcoin, base)) for base in range(2, 11)]))\n    return jamcoins\n\nT = int(input())\nfor t in range(1, T + 1):\n    N, J = map(int, input().split())\n    jamcoins = generate_jamcoin(N, J)\n    print(f\"Case #{t}:\")\n    for jamcoin, divisors in jamcoins:\n        print(jamcoin, *divisors)",
    "generated_at": "2025-05-03T16:47:52.711281",
    "generation_time": 7.657397270202637,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\qualification_round\\counting_sheep",
    "problem_name": "Counting Sheep",
    "python_code": "def find_last_number(N):\n    if N == 0:\n        return \"INSOMNIA\"\n    \n    seen_digits = set()\n    i = 1\n    while len(seen_digits) < 10:\n        current_number = i * N\n        for digit in str(current_number):\n            seen_digits.add(int(digit))\n        i += 1\n    \n    return current_number\n\ndef main():\n    T = int(input())\n    results = []\n    for case_num in range(1, T + 1):\n        N = int(input())\n        result = find_last_number(N)\n        results.append(f\"Case #{case_num}: {result}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:47:55.349663",
    "generation_time": 2.632406234741211,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\qualification_round\\fractiles",
    "problem_name": "Fractiles",
    "python_code": "def solve_fractal_artwork(K, C, S):\n    if K == 1:\n        return [1]\n    \n    if K <= S:\n        return list(range(1, K + 1))\n    \n    if (K - 1) * (2 ** (C - 1)) < S:\n        return \"IMPOSSIBLE\"\n    \n    tiles_to_clean = []\n    for i in range(S):\n        tile_position = (i + 1) * ((K - 1) // (2 ** (C - 1)))\n        tiles_to_clean.append(tile_position)\n    \n    return tiles_to_clean\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        K = int(data[index])\n        C = int(data[index + 1])\n        S = int(data[index + 2])\n        index += 3\n        \n        result = solve_fractal_artwork(K, C, S)\n        if isinstance(result, str):\n            results.append(f\"Case #{_ + 1}: {result}\")\n        else:\n            results.append(f\"Case #{_ + 1}: {' '.join(map(str, result))}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:48:01.174263",
    "generation_time": 5.819377899169922,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\qualification_round\\revenge_of_the_pancakes",
    "problem_name": "Revenge of the Pancakes",
    "python_code": "def min_flips(s):\n    flips = 0\n    i = 0\n    while i < len(s):\n        if s[i] == '-':\n            flips += 1\n            if i + 1 < len(s) and s[i+1] == '+':\n                i += 2\n            else:\n                i += 1\n        else:\n            i += 1\n    return flips\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    results = []\n    for t in range(1, T+1):\n        s = data[t]\n        result = min_flips(s)\n        results.append(f\"Case #{t}: {result}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:48:04.222720",
    "generation_time": 3.043665885925293,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\round_1a\\bffs",
    "problem_name": "BFFs",
    "python_code": "def max_bff_circle(N, F):\n    graph = [[] for _ in range(N)]\n    for i in range(N):\n        graph[i].append(F[i] - 1)\n        graph[F[i] - 1].append(i)\n\n    visited = [False] * N\n    def dfs(node, parent):\n        if visited[node]:\n            return 0\n        visited[node] = True\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        return size\n\n    max_circle_size = 0\n    for i in range(N):\n        if not visited[i]:\n            circle_size = dfs(i, -1)\n            if circle_size % 2 == 0:\n                max_circle_size = max(max_circle_size, circle_size)\n\n    return max_circle_size\n\ndef solve():\n    T = int(input())\n    results = []\n    for t in range(1, T + 1):\n        N = int(input())\n        F = list(map(int, input().split()))\n        result = max_bff_circle(N, F)\n        results.append(f\"Case #{t}: {result}\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T16:48:08.221376",
    "generation_time": 3.9943063259124756,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\round_1a\\rank_and_file",
    "problem_name": "Rank and File",
    "python_code": "def find_missing_list(T, lists):\n    results = []\n    for t in range(T):\n        N = int(lists[t*N][0])\n        rows = [list(map(int, lists[t*N+i+1].split())) for i in range(N)]\n        cols = [[int(lists[t*N+N+i][j]) for j in range(N)] for i in range(N)]\n\n        missing_list = []\n        if len(rows) < N:\n            missing_list = list(set(range(1, 2501)) - set(sum(rows, [])))\n        elif len(cols) < N:\n            missing_list = list(set(range(1, 2501)) - set(sum(cols, [])))\n\n        results.append(f\"Case #{t+1}: {missing_list}\")\n\n    return '\\n'.join(results)\n\n# Example usage\ninput_data = \"\"\"\n2\n3\n1 2 3\n4 5 6\n7 8\n9 10 11\n12 13 14\n15 16\n\"\"\"\nprint(find_missing_list(2, input_data.strip().split('\\n')))",
    "generated_at": "2025-05-03T16:48:11.929073",
    "generation_time": 3.701996326446533,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\round_1a\\the_last_word",
    "problem_name": "The Last Word",
    "python_code": "def last_word(s):\n    from collections import deque\n    q = deque()\n    for char in s:\n        while q and q[-1] < char:\n            q.pop()\n        q.append(char)\n    return ''.join(q)\n\nt = int(input())\nfor i in range(1, t + 1):\n    s = input().strip()\n    print(f\"Case #{i}: {last_word(s)}\")",
    "generated_at": "2025-05-03T16:48:13.416101",
    "generation_time": 1.4821040630340576,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\round_1b\\close_match",
    "problem_name": "Close Match",
    "python_code": "def fill_scoreboard(C, J):\n    min_diff = float('inf')\n    best_C = C\n    best_J = J\n\n    for c in range(10**len(C)):\n        for j in range(10**len(J)):\n            C_filled = str(c).zfill(len(C))\n            J_filled = str(j).zfill(len(J))\n            diff = abs(int(C_filled) - int(J_filled))\n            if diff < min_diff:\n                min_diff = diff\n                best_C = C_filled\n                best_J = J_filled\n            elif diff == min_diff:\n                if int(C_filled) < int(best_C):\n                    best_C = C_filled\n                    best_J = J_filled\n                elif int(C_filled) == int(best_C) and int(J_filled) < int(best_J):\n                    best_C = C_filled\n                    best_J = J_filled\n\n    return best_C, best_J\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    results = []\n    \n    for i in range(1, 2*T+1, 2):\n        C = data[i]\n        J = data[i+1]\n        best_C, best_J = fill_scoreboard(C, J)\n        results.append(f\"Case #{i//2 + 1}: {best_C} {best_J}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:48:18.254438",
    "generation_time": 4.834167718887329,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\round_1b\\getting_the_digits",
    "problem_name": "Getting the Digits",
    "python_code": "def decode_phone_number(s):\n    digit_map = {\n        'ZERO': '0', 'ONE': '1', 'TWO': '2', 'THREE': '3', 'FOUR': '4',\n        'FIVE': '5', 'SIX': '6', 'SEVEN': '7', 'EIGHT': '8', 'NINE': '9'\n    }\n    count = [0] * 10\n    for char in s:\n        for word, digit in digit_map.items():\n            if word.startswith(char):\n                count[int(digit)] += 1\n    \n    result = []\n    for i in range(10):\n        result.extend([str(i)] * count[i])\n    \n    return ''.join(result)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    T = int(data[0])\n    results = []\n    index = 1\n    for _ in range(T):\n        s = data[index]\n        result = decode_phone_number(s)\n        results.append(f\"Case #{_ + 1}: {result}\")\n        index += 1\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:48:22.215705",
    "generation_time": 3.951777935028076,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\round_1b\\technobabble",
    "problem_name": "Technobabble",
    "python_code": "def max_faked_topics(N, topics):\n    words = set()\n    fake_count = 0\n\n    for first, second in topics:\n        if (first, second) not in words and first != second:\n            words.add((first, second))\n        else:\n            fake_count += 1\n\n    return fake_count\n\nT = int(input())\nfor case in range(1, T + 1):\n    N = int(input())\n    topics = [tuple(input().split()) for _ in range(N)]\n    result = max_faked_topics(N, topics)\n    print(f\"Case #{case}: {result}\")",
    "generated_at": "2025-05-03T16:48:24.438933",
    "generation_time": 2.2189207077026367,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\round_1c\\fashion_police",
    "problem_name": "Fashion Police",
    "python_code": "def max_outfits(J, P, S, K):\n    if J == 1 and P == 1:\n        return 1, [(1, 1, i) for i in range(1, S + 1)]\n    elif J == 2 and P == 2:\n        return 4, [(1, 1, i), (1, 2, i), (2, 1, i), (2, 2, i) for i in range(1, min(S, K + 1))]\n    else:\n        return J * P * S // max(J * P, P * S, J * S), [(j, p, s) for j in range(1, J + 1) for p in range(1, P + 1) for s in range(1, S + 1)]\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        J = int(data[index])\n        P = int(data[index + 1])\n        S = int(data[index + 2])\n        K = int(data[index + 3])\n        index += 4\n        \n        max_days, outfits = max_outfits(J, P, S, K)\n        results.append((max_days, outfits))\n    \n    for i, (days, outfits) in enumerate(results):\n        print(f\"Case #{i+1}: {days}\")\n        for outfit in outfits:\n            print(\" \".join(map(str, outfit)))\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T16:48:30.076536",
    "generation_time": 5.627870559692383,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\round_1c\\senate_evacuation",
    "problem_name": "Senate Evacuation",
    "python_code": "def evacuate_senate(N, P):\n    from collections import deque\n    \n    parties = [i for i in range(N)]\n    queue = deque(parties)\n    plan = []\n    \n    while len(queue) > 1:\n        if len(queue) == 2:\n            plan.append(''.join([chr(ord('A') + p) for p in queue]))\n            break\n        elif len(queue) % 2 == 0:\n            step = len(queue) // 2\n        else:\n            step = (len(queue) + 1) // 2\n        \n        step_queue = deque()\n        for _ in range(step):\n            step_queue.append(queue.popleft())\n        \n        remaining = [p for p in parties if p not in step_queue]\n        queue.extend(remaining)\n        plan.append(''.join([chr(ord('A') + p) for p in step_queue]))\n    \n    return ' '.join(plan)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        P = [int(data[index + i]) for i in range(N)]\n        index += N + 1\n        \n        result = evacuate_senate(N, P)\n        results.append(result)\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i+1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:48:35.110214",
    "generation_time": 5.029395818710327,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\round_1c\\slides",
    "problem_name": "Slides!",
    "python_code": "def build_slides(B, M):\n    if B == 2:\n        if M == 1:\n            return \"POSSIBLE\\n0\\n\"\n        else:\n            return \"IMPOSSIBLE\\n\"\n    \n    if M < (B - 1) or M > ((B * (B - 1)) // 2):\n        return \"IMPOSSIBLE\\n\"\n    \n    result = [\"POSSIBLE\"]\n    for i in range(1, B + 1):\n        row = []\n        for j in range(1, B + 1):\n            if i == j:\n                row.append('0')\n            elif i < j and (M > (B - 2) or M == ((i * (i - 1)) // 2)):\n                row.append('1')\n                M -= 1\n            else:\n                row.append('0')\n        result.append(''.join(row))\n    \n    return '\\n'.join(result)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        B = int(data[index])\n        M = int(data[index + 1])\n        index += 2\n        result = build_slides(B, M)\n        results.append(result)\n    \n    for i, res in enumerate(results):\n        print(f\"Case #{i+1}: {res}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:48:40.180562",
    "generation_time": 5.064786195755005,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\round_2\\freeform_factory",
    "problem_name": "Freeform Factory",
    "python_code": "def min_training_cost(N, workers):\n    max_machines = [0] * N\n    for worker in workers:\n        machines = [i for i, knows in enumerate(worker) if knows == '1']\n        for machine in machines:\n            max_machines[machine] = max(max_machines[machine], len(machines))\n    \n    return sum(max_machines)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        workers = [data[index + i] for i in range(N)]\n        index += N\n        \n        result = min_training_cost(N, workers)\n        results.append(f\"Case #{_ + 1}: {result}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:48:43.621745",
    "generation_time": 3.436666488647461,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\round_2\\rather_perplexing_showdown",
    "problem_name": "Rather Perplexing Showdown",
    "python_code": "def generate_lineups(N, R, P, S):\n    if (R == 0 or P == 0 or S == 0) and (R + P + S != 2 * N):\n        return \"IMPOSSIBLE\"\n    \n    players = ['R'] * R + ['P'] * P + ['S'] * S\n    lineups = []\n    \n    def backtrack(lineup):\n        if len(lineup) == 2 * N:\n            lineups.append(''.join(lineup))\n            return\n        \n        for i in range(len(players)):\n            if players[i] != 'X':\n                new_lineup = lineup[:]\n                new_lineup.append(players[i])\n                players[i] = 'X'\n                backtrack(new_lineup)\n                players[i] = new_lineup[-1]\n\n    backtrack([])\n    \n    valid_lineups = []\n    for lineup in lineups:\n        round_results = []\n        for i in range(0, 2 * N, 2):\n            if (lineup[i] == 'R' and lineup[i + 1] == 'S') or \\\n               (lineup[i] == 'S' and lineup[i + 1] == 'P') or \\\n               (lineup[i] == 'P' and lineup[i + 1] == 'R'):\n                round_results.append('W')\n            elif lineup[i] == lineup[i + 1]:\n                round_results.append('T')\n        \n        if all(result != 'T' for result in round_results):\n            valid_lineups.append(lineup)\n    \n    return sorted(valid_lineups)\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        R = int(data[index + 1])\n        P = int(data[index + 2])\n        S = int(data[index + 3])\n        index += 4\n        \n        result = generate_lineups(N, R, P, S)\n        if result == \"IMPOSSIBLE\":\n            results.append(f\"Case #{_+1}: IMPOSSIBLE\")\n        else:\n            results.append(f\"Case #{_+1}: {result[0]}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T16:48:51.607731",
    "generation_time": 7.981354713439941,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\round_2\\red_tape_committee",
    "problem_name": "Red Tape Committee",
    "python_code": "from itertools import combinations\n\ndef max_tie_probability(N, K, probabilities):\n    max_prob = 0\n    for committee in combinations(probabilities, K):\n        yes_prob = sum(committee)\n        no_prob = 1 - yes_prob\n        tie_prob = yes_prob * no_prob + no_prob * yes_prob\n        if tie_prob > max_prob:\n            max_prob = tie_prob\n    return max_prob\n\nT = int(input())\nresults = []\nfor i in range(1, T + 1):\n    N, K = map(int, input().split())\n    probabilities = list(map(float, input().split()))\n    results.append((i, max_tie_probability(N, K, probabilities)))\n\nfor case_num, prob in results:\n    print(f\"Case #{case_num}: {prob:.6f}\")",
    "generated_at": "2025-05-03T16:48:54.820472",
    "generation_time": 3.206455707550049,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\round_2\\the_gardener_of_seville",
    "problem_name": "The Gardener of Seville",
    "python_code": "def can_build_maze(R, C, lovers):\n    if R * C == 1:\n        return '/' if lovers[0] % 2 != lovers[1] % 2 else 'IMPOSSIBLE'\n    \n    courtiers = list(range(1, 2 * (R + C) + 1))\n    maze = [['.' for _ in range(C)] for _ in range(R)]\n    \n    def place_hedge(x, y, direction):\n        if x < 0 or x >= R or y < 0 or y >= C:\n            return False\n        if maze[x][y] != '.':\n            return False\n        maze[x][y] = direction\n        return True\n    \n    for i in range(0, len(lovers), 2):\n        a, b = lovers[i] - 1, lovers[i + 1] - 1\n        found_path = False\n        for dx, dy in [(-1, 1), (1, -1)]:\n            if place_hedge(a // C, a % C, '\\\\') and place_hedge(b // C, b % C, '/'):\n                found_path = True\n                break\n            maze[a // C][a % C], maze[b // C][b % C] = '.', '.'\n        if not found_path:\n            return 'IMPOSSIBLE'\n    \n    return '\\n'.join(''.join(row) for row in maze)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        R, C = map(int, data[index:index + 2])\n        index += 2\n        lovers = list(map(int, data[index:index + 2 * (R + C)]))\n        index += 2 * (R + C)\n        \n        result = can_build_maze(R, C, lovers)\n        results.append(result)\n    \n    for i, result in enumerate(results):\n        print(f'Case #{i + 1}: {result}')\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:49:02.211075",
    "generation_time": 7.384928226470947,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\round_3\\forest_university",
    "problem_name": "Forest University",
    "python_code": "from itertools import permutations\n\ndef count_substrings(s, sub):\n    return s.count(sub)\n\ndef solve(N, M, prerequisites, cool_words):\n    courses = list(range(1, N + 1))\n    basic_courses = [i for i in range(1, N + 1) if i not in prerequisites.values()]\n    advanced_courses = [i for i in range(1, N + 1) if i in prerequisites.values()]\n    \n    valid_sequences = []\n    for perm in permutations(courses):\n        valid = True\n        for course in advanced_courses:\n            prereq = prerequisites[course]\n            if perm.index(course) < perm.index(prereq):\n                valid = False\n                break\n        if valid:\n            valid_sequences.append(perm)\n    \n    results = []\n    for cool_word in cool_words:\n        count = 0\n        for seq in valid_sequences:\n            if any(count_substrings(''.join(map(str, seq)), cool_word[:i+1]) > 0 for i in range(len(cool_word))):\n                count += 1\n        results.append(round(count / len(valid_sequences), 2))\n    \n    return results\n\n# Read input\nT = int(input())\nresults = []\nfor t in range(1, T + 1):\n    N, M = map(int, input().split())\n    prerequisites = {}\n    for _ in range(N - 1):\n        a, b = map(int, input().split())\n        prerequisites[b] = a\n    cool_words = [input() for _ in range(M)]\n    \n    result = solve(N, M, prerequisites, cool_words)\n    results.append(f\"Case #{t}: {''.join(map(str, result))}\")\n\n# Print output\nfor res in results:\n    print(res)",
    "generated_at": "2025-05-03T16:49:08.093684",
    "generation_time": 5.875518321990967,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\round_3\\go",
    "problem_name": "Go++",
    "python_code": "def generate_programs(N, L, G, B):\n    if B in G:\n        return \"IMPOSSIBLE\"\n    \n    def can_produce(s, target):\n        stack = []\n        for char in s:\n            if char == '1':\n                stack.append('0')\n            else:\n                if not stack or stack[-1] != '0':\n                    return False\n                stack.pop()\n        return ''.join(stack) == target\n    \n    def find_programs(target, length):\n        if length == 0:\n            return []\n        if length == 1:\n            return ['0'] if can_produce('0', target) else ['1']\n        \n        programs = []\n        for i in range(length):\n            prefix = '0' * i + '1' * (length - i)\n            suffixes = find_programs(target[len(prefix):], length - len(prefix))\n            for suffix in suffixes:\n                if can_produce(prefix, target[:len(prefix)]) and can_produce(suffix, target[len(prefix):]):\n                    programs.append(prefix + suffix)\n        return programs\n    \n    good_programs = []\n    bad_programs = []\n    \n    for s in G:\n        good_programs.extend(find_programs(s, L))\n    \n    for i in range(1 << L):\n        binary_str = format(i, '0' + str(L) + 'b')\n        if can_produce(binary_str, B):\n            continue\n        bad_programs.append(binary_str)\n    \n    return \" \".join(good_programs[:L//2]) + \" \" + \" \".join(bad_programs[:L//2])\n\n# Read input\nT = int(input())\nresults = []\nfor i in range(1, T + 1):\n    N, L = map(int, input().split())\n    G = [input().strip() for _ in range(N)]\n    B = input().strip()\n    results.append(f\"Case #{i}: {generate_programs(N, L, G, B)}\")\n\n# Print all results\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T16:49:15.007748",
    "generation_time": 6.905879735946655,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\round_3\\rebel_against_the_empire",
    "problem_name": "Rebel Against The Empire",
    "python_code": "import math\n\ndef calculate_max_jump(N, S, asteroids):\n    def distance(a, b):\n        return math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2)\n\n    max_jump = float('inf')\n    for i in range(N):\n        for j in range(i + 1, N):\n            d = distance(asteroids[i], asteroids[j])\n            if d < max_jump:\n                max_jump = d\n    return max_jump\n\ndef solve():\n    T = int(input())\n    results = []\n    for t in range(T):\n        N, S = map(int, input().split())\n        asteroids = [tuple(map(float, input().split())) for _ in range(N)]\n        result = calculate_max_jump(N, S, asteroids)\n        results.append(f\"Case #{t+1}: {result:.4f}\")\n    for result in results:\n        print(result)\n\nsolve()",
    "generated_at": "2025-05-03T16:49:18.827454",
    "generation_time": 3.8115251064300537,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\round_3\\teaching_assistant",
    "problem_name": "Teaching Assistant",
    "python_code": "def max_points(mood_string):\n    n = len(mood_string)\n    points = 0\n    request_queue = []\n    \n    for i in range(n):\n        mood = mood_string[i]\n        \n        if request_queue:\n            last_request = request_queue[-1]\n            if last_request == mood:\n                points += 5\n            else:\n                points += 5\n            request_queue.pop()\n            \n        if mood == 'C':\n            request_queue.append('C')\n        elif mood == 'J':\n            request_queue.append('J')\n    \n    return points\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    results = []\n    \n    for i in range(1, T + 1):\n        mood_string = data[i]\n        result = max_points(mood_string)\n        results.append(f\"Case #{i}: {result}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:49:22.845810",
    "generation_time": 4.0111353397369385,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\world_finals\\family_hotel",
    "problem_name": "Family Hotel",
    "python_code": "def hello_world():\n    return \"Hello, World!\"\n\nprint(hello_world())",
    "generated_at": "2025-05-03T16:49:23.175244",
    "generation_time": 0.32277488708496094,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\world_finals\\gallery_of_pillars",
    "problem_name": "Gallery of Pillars",
    "python_code": "def count_visible_pillars(N, R):\n    if N == 1:\n        return 0\n    radius_m = R / 1e6\n    grid_size = 2 * radius_m\n    visible_count = 0\n\n    for i in range(1, N):\n        for j in range(1, N):\n            distance_squared = (i - 0.5) ** 2 + (j - 0.5) ** 2\n            if distance_squared > grid_size ** 2:\n                visible_count += 1\n\n    return visible_count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    T = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(T):\n        N = int(data[index])\n        R = float(data[index + 1])\n        index += 2\n\n        result = count_visible_pillars(N, R)\n        results.append(f\"Case #{_+1}: {result}\")\n\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:49:26.959381",
    "generation_time": 3.779611825942993,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\world_finals\\integeregex",
    "problem_name": "Integeregex",
    "python_code": "import re\n\ndef count_matches(regex, A, B):\n    count = 0\n    for i in range(A, B + 1):\n        if re.match(regex, str(i)):\n            count += 1\n    return count\n\nT = int(input())\nfor t in range(1, T + 1):\n    A, B = map(int, input().split())\n    regex = input()\n    result = count_matches(regex, A, B)\n    print(f\"Case #{t}: {result}\")",
    "generated_at": "2025-05-03T16:49:28.849181",
    "generation_time": 1.8822672367095947,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\world_finals\\map_reduce",
    "problem_name": "Map Reduce",
    "python_code": "from collections import deque\n\ndef bfs(grid, start, end):\n    R, C = len(grid), len(grid[0])\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = deque([start])\n    distance = {start: 0}\n    \n    while queue:\n        x, y = queue.popleft()\n        if (x, y) == end:\n            return distance[(x, y)]\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < R and 0 <= ny < C and grid[nx][ny] != '#' and (nx, ny) not in distance:\n                queue.append((nx, ny))\n                distance[(nx, ny)] = distance[(x, y)] + 1\n    \n    return float('inf')\n\ndef remove_walls(grid, start, end, D):\n    R, C = len(grid), len(grid[0])\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    def is_valid(grid):\n        return bfs(grid, start, end) <= D\n    \n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == '#':\n                new_grid = [row[:] for row in grid]\n                new_grid[i][j] = '.'\n                if is_valid(new_grid):\n                    return True, new_grid\n    return False, None\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        R, C, D = map(int, data[index:index+3])\n        index += 3\n        grid = [list(data[index + i]) for i in range(R)]\n        start = None\n        end = None\n        \n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == 'S':\n                    start = (i, j)\n                elif grid[i][j] == 'F':\n                    end = (i, j)\n        \n        possible, new_grid = remove_walls(grid, start, end, D)\n        results.append(\"POSSIBLE\" if possible else \"IMPOSSIBLE\")\n        if possible:\n            for row in new_grid:\n                results.append(''.join(row))\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i+1}: {result}\")\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T16:49:37.600736",
    "generation_time": 8.74391770362854,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2016\\world_finals\\radioactive_islands",
    "problem_name": "Radioactive Islands",
    "python_code": "import math\n\ndef min_radiation_dose(N, A, B, C):\n    total_radiation = 0\n    \n    for Ci in C:\n        # Distance from the boat's starting point (-10, A) to the island (0, Ci)\n        D_start = math.sqrt((-10)**2 + (A - Ci)**2)\n        \n        # Distance from the boat's ending point (10, B) to the island (0, Ci)\n        D_end = math.sqrt((10)**2 + (B - Ci)**2)\n        \n        # Total radiation from this island\n        total_radiation += 1 / D_start**2 + 1 / D_end**2\n    \n    return total_radiation\n\n# Read input\nT = int(input())\nresults = []\n\nfor i in range(1, T + 1):\n    N, A, B = map(float, input().split())\n    C = list(map(float, input().split()))\n    \n    # Calculate the minimum radiation dose for this test case\n    min_dose = min_radiation_dose(N, A, B, C)\n    \n    # Store the result\n    results.append(f\"Case #{i}: {min_dose:.3f}\")\n\n# Print all results\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T16:49:41.915768",
    "generation_time": 4.308945417404175,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\qualification_round\\bathroom_stalls",
    "problem_name": "Bathroom Stalls",
    "python_code": "def bathroom_stalls(N, K):\n    if N == 1:\n        return (0, 0)\n    stalls = [0] * (N + 2)\n    stalls[0] = stalls[N + 1] = 1\n    for _ in range(K - 1):\n        max_diff = -1\n        best_pos = -1\n        for i in range(1, N + 1):\n            if stalls[i] == 0:\n                left = min(i - stalls[:i][::-1].index(1) - 1, stalls[i:].index(1))\n                right = min(stalls[:i][::-1].index(1), stalls[i:].index(1) - 1)\n                diff = max(left, right)\n                if diff > max_diff or (diff == max_diff and left > right):\n                    max_diff = diff\n                    best_pos = i\n        stalls[best_pos] = 1\n    left = min(best_pos - stalls[:best_pos][::-1].index(1) - 1, stalls[best_pos:].index(1))\n    right = min(stalls[:best_pos][::-1].index(1), stalls[best_pos:].index(1) - 1)\n    return (max(left, right), min(left, right))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    T = int(data[0])\n    index = 1\n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        result = bathroom_stalls(N, K)\n        results.append(f\"Case #{_+1}: {result[0]} {result[1]}\")\n    print(*results, sep='\\n')\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:49:48.124754",
    "generation_time": 6.154043674468994,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\qualification_round\\fashion_show",
    "problem_name": "Fashion Show",
    "python_code": "def max_style_points(N, M, models):\n    grid = [['.' for _ in range(N)] for _ in range(N)]\n    \n    def is_valid(r, c, model):\n        if r != 1: return False\n        for i in range(N):\n            for j in range(N):\n                if grid[i][j] == '.':\n                    continue\n                if (i == r and j == c) or (i == r and j != c) or (i != r and j == c) or (i + j == r + c) or (i - j == r - c):\n                    if model == '+' and grid[i][j] not in ['+', 'x']:\n                        return False\n                    elif model == 'x' and grid[i][j] not in ['x', '+']:\n                        return False\n        return True\n    \n    for model, r, c in models:\n        grid[r-1][c-1] = model\n    \n    added_or_substituted = 0\n    style_points = 0\n    \n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == '.' and is_valid(i+1, j+1, 'o'):\n                grid[i][j] = 'o'\n                added_or_substituted += 1\n                style_points += 2\n            elif grid[i][j] == '+' and is_valid(i+1, j+1, 'x'):\n                grid[i][j] = 'x'\n                added_or_substituted += 1\n                style_points += 1\n            elif grid[i][j] == 'x' and is_valid(i+1, j+1, '+'):\n                grid[i][j] = '+'\n                added_or_substituted += 1\n                style_points += 1\n    \n    result = []\n    for i in range(N):\n        for j in range(N):\n            if (i+1, j+1) not in [(r, c) for _, r, c in models]:\n                if grid[i][j] != '.':\n                    result.append(f\"{grid[i][j]} {i+1} {j+1}\")\n    \n    return style_points, added_or_substituted, result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        M = int(data[index+1])\n        models = [(data[index+2+3*i], int(data[index+3+3*i]), int(data[index+4+3*i])) for i in range(M)]\n        index += 3 * (M + 1)\n        \n        style_points, added_or_substituted, result = max_style_points(N, M, models)\n        results.append(f\"Case #{_+1}: {style_points} {added_or_substituted}\")\n        results.extend(result)\n    \n    for line in results:\n        print(line)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:49:58.343646",
    "generation_time": 10.207206964492798,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\qualification_round\\oversized_pancake_flipper",
    "problem_name": "Oversized Pancake Flipper",
    "python_code": "def min_flips(s, k):\n    n = len(s)\n    flips = 0\n    i = 0\n    while i < n:\n        if s[i] == '-':\n            if i + k > n:\n                return \"IMPOSSIBLE\"\n            else:\n                flips += 1\n                for j in range(i, i + k):\n                    s = s[:j] + ('+' if s[j] == '-' else '-') + s[j+1:]\n        i += 1\n    return flips\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    index = 1\n    \n    for _ in range(t):\n        s = data[index]\n        k = int(data[index + 1])\n        result = min_flips(s, k)\n        results.append(result)\n        index += 2\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i+1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:50:02.077253",
    "generation_time": 3.7246181964874268,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\qualification_round\\tidy_numbers",
    "problem_name": "Tidy Numbers",
    "python_code": "def is_tidy(n):\n    digits = str(n)\n    return all(digits[i] <= digits[i + 1] for i in range(len(digits) - 1))\n\ndef find_last_tidy(N):\n    while not is_tidy(N):\n        N -= 1\n    return N\n\nT = int(input())\nresults = []\nfor t in range(1, T + 1):\n    N = int(input())\n    last_tidy = find_last_tidy(N)\n    results.append(f\"Case #{t}: {last_tidy}\")\n\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T16:50:04.090742",
    "generation_time": 2.003793954849243,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\round_1a\\alphabet_cake",
    "problem_name": "Alphabet Cake",
    "python_code": "def solve_cake_problem(test_cases):\n    results = []\n    \n    for test_case in test_cases:\n        R, C = map(int, test_case[0].split())\n        cake = test_case[1:]\n        \n        # Create a dictionary to store the positions of each letter\n        letter_positions = {}\n        for r in range(R):\n            for c in range(C):\n                if cake[r][c] != '?':\n                    if cake[r][c] not in letter_positions:\n                        letter_positions[cake[r][c]] = []\n                    letter_positions[cake[r][c]].append((r, c))\n        \n        # Assign each letter to a rectangle\n        assigned_letters = {}\n        for letter, positions in letter_positions.items():\n            min_r = max_r = positions[0][0]\n            min_c = max_c = positions[0][1]\n            for r, c in positions:\n                if r < min_r: min_r = r\n                if r > max_r: max_r = r\n                if c < min_c: min_c = c\n                if c > max_c: max_c = c\n            assigned_letters[letter] = (min_r, max_r, min_c, max_c)\n        \n        # Create the result grid\n        result_grid = [[ '?' for _ in range(C)] for _ in range(R)]\n        for letter, (min_r, max_r, min_c, max_c) in assigned_letters.items():\n            for r in range(min_r, max_r + 1):\n                for c in range(min_c, max_c + 1):\n                    result_grid[r][c] = letter\n        \n        # Add the result to the results list\n        results.append(f\"Case #{test_case[0].split()[2]}:\")\n        for row in result_grid:\n            results.append(''.join(row))\n    \n    return results\n\n# Example usage:\ntest_cases = [\n    (\"3 3\\nA?C\\nB?D\\nE?F\",),\n    (\"2 2\\nX?\\nY?\",)\n]\nresults = solve_cake_problem(test_cases)\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T16:50:10.889401",
    "generation_time": 6.78925895690918,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\round_1a\\play_the_dragon",
    "problem_name": "Play the Dragon",
    "python_code": "def min_turns_to_defeat_knight(Hd, Ad, Hk, Ak, B, D):\n    if Hd <= Ak:\n        return \"IMPOSSIBLE\"\n    \n    turns = 0\n    while True:\n        # Your turn\n        turns += 1\n        Hk -= Ad\n        if Hk <= 0:\n            return str(turns)\n        \n        # Knight's turn\n        turns += 1\n        Hd -= Ak\n        if Hd <= 0:\n            return \"IMPOSSIBLE\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nT = int(data[0])\nresults = []\nindex = 1\nfor _ in range(T):\n    Hd = int(data[index])\n    index += 1\n    Ad = int(data[index])\n    index += 1\n    Hk = int(data[index])\n    index += 1\n    Ak = int(data[index])\n    index += 1\n    B = int(data[index])\n    index += 1\n    D = int(data[index])\n    index += 1\n    \n    result = min_turns_to_defeat_knight(Hd, Ad, Hk, Ak, B, D)\n    results.append(result)\n\n# Output results\nfor i, result in enumerate(results):\n    print(f\"Case #{i + 1}: {result}\")",
    "generated_at": "2025-05-03T16:50:15.801707",
    "generation_time": 4.902789354324341,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\round_1a\\ratatouille",
    "problem_name": "Ratatouille",
    "python_code": "def max_kits(N, P, packages):\n    from collections import defaultdict\n\n    def can_form_kit(serving_size, packages):\n        needs = [serving_size * r for r in R]\n        for i in range(P):\n            if not (0.9 * needs[i] <= packages[i][1] <= 1.1 * needs[i]):\n                return False\n        return True\n\n    packages.sort(key=lambda x: x[1])\n    R = [int(input()) for _ in range(N)]\n    packages = [[int(input()), int(input())] for _ in range(P)]\n\n    left, right = min(p[0] for p in packages), max(p[0] for p in packages)\n    while left < right:\n        mid = (left + right + 1) // 2\n        if can_form_kit(mid, packages):\n            left = mid\n        else:\n            right = mid - 1\n\n    return left\n\nT = int(input())\nfor t in range(1, T + 1):\n    N, P = map(int, input().split())\n    print(f\"Case #{t}: {max_kits(N, P, packages)}\")",
    "generated_at": "2025-05-03T16:50:20.223568",
    "generation_time": 4.414412260055542,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\round_1b\\pony_express",
    "problem_name": "Pony Express",
    "python_code": "from fractions import Fraction\n\ndef min_time_to_deliver(T, test_cases):\n    results = []\n    \n    for i in range(1, T + 1):\n        N, Ei, Si, D = test_cases[i-1]\n        \n        # Create adjacency list and horse endurance dictionary\n        adj_list = [[] for _ in range(N)]\n        horse_endurance = [0] * N\n        \n        for j in range(Ei):\n            u, v, d = D[j]\n            if u != -1:\n                adj_list[u].append((v, d))\n                adj_list[v].append((u, d))\n        \n        for j in range(Si):\n            u, e = D[Ei + j]\n            horse_endurance[u] = e\n        \n        # Calculate minimum time to deliver from city 1 to city N\n        start_time = Fraction(0)\n        current_city = 0\n        current_horse = 0\n        used_distance = 0\n        \n        while current_city != N - 1:\n            next_city = None\n            min_time = float('inf')\n            \n            for neighbor, distance in adj_list[current_city]:\n                if neighbor == N - 1:\n                    time_to_neighbor = Fraction(distance, horse_endurance[neighbor])\n                    if used_distance + distance <= horse_endurance[neighbor]:\n                        if time_to_neighbor < min_time:\n                            min_time = time_to_neighbor\n                            next_city = neighbor\n            \n            if next_city is None:\n                break\n            \n            start_time += min_time\n            current_city = next_city\n            used_distance = 0\n        \n        results.append(start_time)\n    \n    return results\n\n# Example usage:\nT = 3\ntest_cases = [\n    (5, 4, 2, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 5, 10), (-1, -1, 1000), (1, 1000), (2, 1000)]),\n    (6, 5, 2, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6), (-1, -1, 1000), (1, 1000), (2, 1000)]),\n    (7, 6, 2, [(1, 2, 100), (2, 3, 100), (3, 4, 100), (4, 5, 100), (5, 6, 100), (-1, -1, 1000), (1, 1000), (2, 1000)])\n]\n\nresults = min_time_to_deliver(T, test_cases)\nfor i, result in enumerate(results):\n    print(f\"Case #{i+1}: {result}\")",
    "generated_at": "2025-05-03T16:50:30.510993",
    "generation_time": 10.279686212539673,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\round_1b\\stable_neigh-bors",
    "problem_name": "Stable Neigh-bors",
    "python_code": "def place_unicorns(N, R, O, Y, G, B, V):\n    if N == 0:\n        return \"IMPOSSIBLE\"\n    \n    # Create a list of colors based on the number of unicorns with each color mane\n    colors = ['R'] * R + ['O'] * O + ['Y'] * Y + ['G'] * G + ['B'] * B + ['V'] * V\n    \n    # Check if it's possible to arrange the unicorns in a circle\n    for i in range(N):\n        valid = True\n        for j in range(1, N):\n            if colors[(i + j) % N] == colors[(i - j) % N]:\n                valid = False\n                break\n        if valid:\n            return ''.join(colors[i:] + colors[:i])\n    \n    return \"IMPOSSIBLE\"\n\n# Read input\nT = int(input())\nresults = []\nfor t in range(1, T + 1):\n    N, R, O, Y, G, B, V = map(int, input().split())\n    results.append(f\"Case #{t}: {place_unicorns(N, R, O, Y, G, B, V)}\")\n\n# Print all results\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T16:50:34.952801",
    "generation_time": 4.434171676635742,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\round_1b\\steed_2_cruise_control",
    "problem_name": "Steed 2: Cruise Control",
    "python_code": "def max_speed(D, N, horses):\n    def can_ride(speed):\n        for i in range(N):\n            ki, si = horses[i]\n            time_to_meet = (D - ki) / speed\n            if time_to_meet * si < D - ki:\n                return False\n        return True\n\n    left, right = 0, 1e9\n    while right - left > 1e-6:\n        mid = (left + right) / 2\n        if can_ride(mid):\n            left = mid\n        else:\n            right = mid\n    return left\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        D = int(data[index])\n        N = int(data[index + 1])\n        horses = []\n        index += 2\n        for _ in range(N):\n            ki = int(data[index])\n            si = int(data[index + 1])\n            horses.append((ki, si))\n            index += 2\n        \n        result = max_speed(D, N, horses)\n        results.append(f\"Case #{_+1}: {result:.6f}\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:50:39.650942",
    "generation_time": 4.691630601882935,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\round_1c\\ample_syrup",
    "problem_name": "Ample Syrup",
    "python_code": "import math\n\ndef max_exposed_area(N, K, pancakes):\n    pancakes.sort(key=lambda x: -x[0])\n    exposed_area = 0\n    \n    for i in range(K):\n        radius, height = pancakes[i]\n        if i == 0:\n            exposed_area += math.pi * radius ** 2 + 2 * math.pi * radius * height\n        else:\n            prev_radius, _ = pancakes[i-1]\n            exposed_area += 2 * math.pi * min(radius, prev_radius) * (height - abs(prev_radius - radius))\n    \n    return exposed_area\n\ndef main():\n    T = int(input())\n    results = []\n    \n    for case in range(1, T + 1):\n        N, K = map(int, input().split())\n        pancakes = [tuple(map(int, input().split())) for _ in range(N)]\n        result = max_exposed_area(N, K, pancakes)\n        results.append(f\"Case #{case}: {result:.6f}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:50:44.497240",
    "generation_time": 3.854504346847534,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\round_1c\\core_training",
    "problem_name": "Core Training",
    "python_code": "from fractions import Fraction\n\ndef calculate_probability(N, K, U, P):\n    from itertools import combinations_with_replacement\n    \n    max_prob = Fraction(0)\n    \n    for r in range(K, N + 1):\n        for combo in combinations_with_replacement(range(N), r):\n            prob = Fraction(1)\n            remaining_units = U\n            \n            for i in range(N):\n                if i in combo:\n                    if remaining_units > 0:\n                        p_i = min(P[i] + Fraction(remaining_units, N - len(combo) + 1), Fraction(1))\n                        prob *= p_i\n                        remaining_units -= (P[i] - p_i).numerator * (N - len(combo) + 1)\n                    else:\n                        prob *= P[i]\n                else:\n                    prob *= (1 - P[i])\n            \n            max_prob = max(max_prob, prob)\n    \n    return max_prob\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    \n    for t in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        U = Fraction(data[index + 2])\n        P = [Fraction(data[index + 3 + i]) for i in range(N)]\n        \n        result = calculate_probability(N, K, U, P)\n        print(f\"Case #{t+1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:50:49.862355",
    "generation_time": 5.327526330947876,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\round_1c\\parenting_partnering",
    "problem_name": "Parenting Partnering",
    "python_code": "def min_exchanges(C, J, activitiesC, activitiesJ):\n    total_time = 24 * 60\n    cameron_time = [False] * total_time\n    jamie_time = [False] * total_time\n    \n    for start, end in activitiesC:\n        for i in range(start, end):\n            cameron_time[i] = True\n    \n    for start, end in activitiesJ:\n        for i in range(start, end):\n            jamie_time[i] = True\n    \n    exchanges = 0\n    current_cameron = False\n    current_jamie = False\n    \n    for t in range(total_time):\n        if cameron_time[t]:\n            if not current_cameron and current_jamie:\n                exchanges += 1\n            current_cameron = True\n        else:\n            current_cameron = False\n        \n        if jamie_time[t]:\n            if not current_jamie and current_cameron:\n                exchanges += 1\n            current_jamie = True\n        else:\n            current_jamie = False\n    \n    return exchanges\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        C = int(data[index])\n        J = int(data[index + 1])\n        index += 2\n        \n        activitiesC = []\n        for _ in range(C):\n            start = int(data[index]) * 60\n            end = int(data[index + 1]) * 60\n            activitiesC.append((start, end))\n            index += 2\n        \n        activitiesJ = []\n        for _ in range(J):\n            start = int(data[index]) * 60\n            end = int(data[index + 1]) * 60\n            activitiesJ.append((start, end))\n            index += 2\n        \n        result = min_exchanges(C, J, activitiesC, activitiesJ)\n        results.append(result)\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i+1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:50:57.474431",
    "generation_time": 7.574465036392212,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\round_2\\beaming_with_joy",
    "problem_name": "Beaming With Joy",
    "python_code": "def rotate_beam_shooter(grid, row, col):\n    if grid[row][col] == '/':\n        return '|'\n    elif grid[row][col] == '\\\\':\n        return '-'\n    elif grid[row][col] == '-':\n        return '\\\\'\n    elif grid[row][col] == '|':\n        return '/'\n    else:\n        return grid[row][col]\n\ndef is_valid(grid, R, C):\n    visited = [[False for _ in range(C)] for _ in range(R)]\n    \n    def dfs(x, y, dx, dy):\n        if x < 0 or x >= R or y < 0 or y >= C:\n            return True\n        if grid[x][y] == '#':\n            return False\n        if visited[x][y]:\n            return False\n        visited[x][y] = True\n        \n        if grid[x][y] == '-' or grid[x][y] == '|':\n            nx, ny = x + dx, y + dy\n        elif grid[x][y] == '/':\n            nx, ny = x - dy, y + dx\n        elif grid[x][y] == '\\\\':\n            nx, ny = x + dy, y - dx\n        \n        return dfs(nx, ny, dx, dy)\n    \n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == '-' or grid[i][j] == '|' or grid[i][j] == '/' or grid[i][j] == '\\\\':\n                if not dfs(i, j, 0, 1) and not dfs(i, j, 1, 0) and not dfs(i, j, 0, -1) and not dfs(i, j, -1, 0):\n                    return False\n    \n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == '.':\n                if not any(dfs(i + dx, j + dy, dx, dy) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]):\n                    return False\n    \n    return True\n\ndef solve(grid, R, C):\n    if not is_valid(grid, R, C):\n        return \"IMPOSSIBLE\"\n    \n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == '-' or grid[i][j] == '|' or grid[i][j] == '/' or grid[i][j] == '\\\\':\n                rotated_grid = [row[:] for row in grid]\n                rotated_grid[i] = list(rotate_beam_shooter(rotated_grid, i, j))\n                if is_valid(rotated_grid, R, C):\n                    return \"POSSIBLE\\n\" + '\\n'.join(''.join(row) for row in rotated_grid)\n    \n    return \"IMPOSSIBLE\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        R, C = map(int, data[index:index+2])\n        index += 2\n        grid = [data[index + i] for i in range(R)]\n        index += R\n        \n        result = solve(grid, R, C)\n        results.append(result)\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i+1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:51:09.269395",
    "generation_time": 11.52402377128601,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\round_2\\fresh_chocolate",
    "problem_name": "Fresh Chocolate",
    "python_code": "def maximize_fresh_chocolate(N, P, groups):\n    fresh_chocolate = 0\n    leftover = 0\n    \n    for group in groups:\n        if group > P + leftover:\n            continue\n        elif group == P + leftover:\n            fresh_chocolate += 1\n            leftover = 0\n        else:\n            fresh_chocolate += 1\n            leftover = (P + leftover) % group\n    \n    return fresh_chocolate\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        P = int(data[index + 1])\n        groups = list(map(int, data[index + 2:index + 2 + N]))\n        index += 2 + N\n        \n        result = maximize_fresh_chocolate(N, P, groups)\n        results.append(f\"Case #{_+1}: {result}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T16:51:13.345670",
    "generation_time": 4.02007269859314,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\round_2\\roller_coaster_scheduling",
    "problem_name": "Roller Coaster Scheduling",
    "python_code": "def min_rides_and_promotions(N, C, M, tickets):\n    from collections import defaultdict\n\n    seat_to_customers = defaultdict(list)\n    customer_to_seats = defaultdict(list)\n\n    for Pi, Bi in tickets:\n        seat_to_customers[Pi].append(Bi)\n        customer_to_seats[Bi].append(Pi)\n\n    rides = 0\n    promotions = 0\n\n    while seat_to_customers:\n        assigned_rides = set()\n        for seat in sorted(seat_to_customers.keys()):\n            if seat not in assigned_rides:\n                ride_customers = []\n                for customer in seat_to_customers[seat]:\n                    if any(pos in assigned_rides for pos in customer_to_seats[customer]):\n                        continue\n                    ride_customers.append(customer)\n                    assigned_rides.update(customer_to_seats[customer])\n                if ride_customers:\n                    rides += 1\n                    promotions += len(ride_customers) - 1\n\n        remaining_tickets = [(seat, customer) for seat in seat_to_customers.keys() for customer in seat_to_customers[seat]]\n        seat_to_customers.clear()\n        for Pi, Bi in remaining_tickets:\n            if Pi not in assigned_rides:\n                seat_to_customers[Pi].append(Bi)\n\n    return rides, promotions\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n\n    for t in range(1, T + 1):\n        N = int(data[index])\n        index += 1\n        C = int(data[index])\n        index += 1\n        M = int(data[index])\n        index += 1\n\n        tickets = []\n        for _ in range(M):\n            Pi = int(data[index])\n            index += 1\n            Bi = int(data[index])\n            index += 1\n            tickets.append((Pi, Bi))\n\n        rides, promotions = min_rides_and_promotions(N, C, M, tickets)\n        results.append(f\"Case #{t}: {rides} {promotions}\")\n\n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T16:51:20.790277",
    "generation_time": 7.434396743774414,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\round_2\\shoot_the_turrets",
    "problem_name": "Shoot the Turrets",
    "python_code": "def destroy_turrets(R, C, M, grid):\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    def in_bounds(x, y):\n        return 0 <= x < R and 0 <= y < C\n    \n    def can_destroy(sx, sy, tx, ty):\n        for dx, dy in directions:\n            nx, ny = sx + dx, sy + dy\n            while in_bounds(nx, ny) and grid[nx][ny] != '#':\n                if (nx, ny) == (tx, ty):\n                    return True\n                nx += dx\n                ny += dy\n        return False\n    \n    soldiers = [(i, j) for i in range(R) for j in range(C) if grid[i][j] == 'S']\n    turrets = [(i, j) for i in range(R) for j in range(C) if grid[i][j] == 'T']\n    \n    max_destroyed = 0\n    result = []\n    \n    def backtrack(destroyed, moves_left):\n        nonlocal max_destroyed, result\n        if destroyed > max_destroyed:\n            max_destroyed = destroyed\n            result = [(s[0], s[1], t[0], t[1]) for s, t in zip(soldiers[:destroyed], turrets[:destroyed])]\n        \n        if destroyed == len(turrets):\n            return\n        \n        for i in range(len(soldiers)):\n            sx, sy = soldiers[i]\n            for dx, dy in directions:\n                nx, ny = sx + dx, sy + dy\n                while in_bounds(nx, ny) and grid[nx][ny] != '#':\n                    if (nx, ny) == turrets[destroyed]:\n                        soldiers[i] = (nx, ny)\n                        backtrack(destroyed + 1, moves_left - 1)\n                        break\n                    nx += dx\n                    ny += dy\n    \n    backtrack(0, M * len(soldiers))\n    \n    return max_destroyed, result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        R = int(data[index])\n        C = int(data[index + 1])\n        M = int(data[index + 2])\n        grid = [data[index + 3 + i] for i in range(R)]\n        index += 3 + R\n        \n        destroyed, moves = destroy_turrets(R, C, M, grid)\n        \n        results.append(f\"Case #{_+1}: {destroyed}\")\n        if moves:\n            for s_i, t_i in moves:\n                results.append(f\"{s_i} {t_i}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:51:30.594894",
    "generation_time": 9.793355464935303,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\round_3\\good_news_and_bad_news",
    "problem_name": "Good News and Bad News",
    "python_code": "from collections import defaultdict\n\ndef can_distribute_news(F, P, pairs):\n    if F == 2:\n        if P == 1:\n            return \"IMPOSSIBLE\"\n        else:\n            return [i for i in range(-F+1, F) if i != 0]\n    \n    graph = defaultdict(list)\n    indegree = [0] * (F + 1)\n    outdegree = [0] * (F + 1)\n    \n    for A, B in pairs:\n        graph[A].append(B)\n        outdegree[A] += 1\n        indegree[B] += 1\n    \n    queue = []\n    for i in range(1, F + 1):\n        if indegree[i] == outdegree[i]:\n            queue.append(i)\n    \n    if len(queue) != 2:\n        return \"IMPOSSIBLE\"\n    \n    start, end = queue\n    if start not in graph[end]:\n        return \"IMPOSSIBLE\"\n    \n    news_values = [0] * P\n    \n    def dfs(node, value):\n        for neighbor in graph[node]:\n            if value == -1:\n                return False\n            if dfs(neighbor, -value):\n                news_values[pairs.index((node, neighbor))] = value\n                return True\n        return False\n    \n    if not dfs(start, 1):\n        return \"IMPOSSIBLE\"\n    \n    for i in range(P):\n        if news_values[i] == 0:\n            return \"IMPOSSIBLE\"\n    \n    return news_values\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        F = int(data[index])\n        P = int(data[index + 1])\n        index += 2\n        \n        pairs = [(int(data[index]), int(data[index + 1])) for _ in range(P)]\n        index += 2 * P\n        \n        result = can_distribute_news(F, P, pairs)\n        results.append(result)\n    \n    for i, result in enumerate(results):\n        if result == \"IMPOSSIBLE\":\n            print(f\"Case #{i+1}: IMPOSSIBLE\")\n        else:\n            print(f\"Case #{i+1}: {' '.join(map(str, result))}\")\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T16:51:38.765371",
    "generation_time": 8.159748315811157,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\round_3\\googlements",
    "problem_name": "Googlements",
    "python_code": "def count_possible_googlements(G):\n    from collections import Counter\n    \n    def decay(g):\n        counts = Counter(g)\n        return ''.join(str(counts[str(i)]) for i in range(len(g) + 1))\n    \n    G_set = {G}\n    while True:\n        new_G_set = set(decay(g) for g in G_set)\n        if not new_G_set - G_set:\n            break\n        G_set.update(new_G_set)\n    \n    return len(G_set)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    results = []\n    \n    for i in range(1, T + 1):\n        G = data[i]\n        result = count_possible_googlements(G)\n        results.append(f\"Case #{i}: {result}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:51:42.110157",
    "generation_time": 3.3203542232513428,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\round_3\\mountain_tour",
    "problem_name": "Mountain Tour",
    "python_code": "from collections import defaultdict\n\ndef min_hours_to_complete_tours(camps, tours):\n    graph = defaultdict(list)\n    \n    for i in range(len(tours)):\n        start_camp = (i + 1) // 2\n        end_camp, leave_time, duration = tours[i]\n        graph[start_camp].append((end_camp, leave_time, duration))\n    \n    def dfs(current_camp, current_time):\n        if len(visited) == 2 * camps - 1:\n            return (current_time + 23) % 24\n        \n        min_time = float('inf')\n        for end_camp, leave_time, duration in graph[current_camp]:\n            if end_camp not in visited and current_time >= leave_time:\n                visited.add(end_camp)\n                time_to_next_tour = (leave_time - current_time + 23) % 24\n                min_time = min(min_time, time_to_next_tour + dfs(end_camp, (current_time + duration) % 24))\n                visited.remove(end_camp)\n        \n        return min_time\n    \n    visited = {1}\n    total_hours = dfs(1, 0)\n    \n    return total_hours\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(T):\n    camps = int(data[index])\n    index += 1\n    tours = []\n    for i in range(2 * camps):\n        end_camp = int(data[index]) - 1\n        leave_time = int(data[index + 1])\n        duration = int(data[index + 2])\n        tours.append((end_camp, leave_time, duration))\n        index += 3\n    \n    min_hours = min_hours_to_complete_tours(camps, tours)\n    results.append(f\"Case #{_+1}: {min_hours}\")\n\n# Output results\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T16:51:48.747500",
    "generation_time": 6.62269139289856,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\round_3\\slate_modern",
    "problem_name": "Slate Modern",
    "python_code": "MOD = 10**9 + 7\n\ndef can_fill(R, C, N, D, grid):\n    for i in range(R):\n        for j in range(C):\n            if (i, j) not in grid:\n                valid = True\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    ni, nj = i + dx, j + dy\n                    if 0 <= ni < R and 0 <= nj < C and (ni, nj) in grid:\n                        if abs(grid[(i, j)] - grid[(ni, nj)]) > D:\n                            valid = False\n                            break\n                if not valid:\n                    return False\n    return True\n\ndef max_sum(R, C, N, D, grid):\n    for i in range(R):\n        for j in range(C):\n            if (i, j) not in grid:\n                grid[(i, j)] = 0\n    \n    for _ in range(10):  # Try up to 10 times to improve the solution\n        changed = False\n        for i in range(R):\n            for j in range(C):\n                if (i, j) not in grid:\n                    valid_values = [grid[(ni, nj)] for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)] if 0 <= ni < R and 0 <= nj < C and (ni, nj) in grid]\n                    min_val = min(valid_values) - D\n                    max_val = max(valid_values) + D\n                    grid[(i, j)] = (min_val + max_val) // 2\n                    changed = True\n        if not changed:\n            break\n    \n    return sum(grid.values()) % MOD\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        R = int(data[index])\n        C = int(data[index + 1])\n        N = int(data[index + 2])\n        D = int(data[index + 3])\n        grid = {}\n        \n        index += 4\n        \n        for _ in range(N):\n            ri = int(data[index]) - 1\n            ci = int(data[index + 1]) - 1\n            bi = int(data[index + 2])\n            grid[(ri, ci)] = bi\n            index += 3\n        \n        if can_fill(R, C, N, D, grid):\n            result = max_sum(R, C, N, D, grid)\n        else:\n            result = \"IMPOSSIBLE\"\n        \n        results.append(result)\n    \n    for i, res in enumerate(results, 1):\n        print(f\"Case #{i}: {res}\")\n\nsolve()",
    "generated_at": "2025-05-03T16:51:58.382163",
    "generation_time": 9.620558977127075,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\world_finals\\dice_straight",
    "problem_name": "Dice Straight",
    "python_code": "def longest_straight(dice):\n    numbers = set()\n    for die in dice:\n        numbers.update(die)\n    longest = 0\n    while len(numbers) > 0:\n        start = min(numbers)\n        current = start\n        count = 1\n        numbers.remove(start)\n        while current + 1 in numbers:\n            current += 1\n            count += 1\n            numbers.remove(current)\n        longest = max(longest, count)\n    return longest\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        dice = [list(map(int, data[index:index+6])) for _ in range(N)]\n        index += 6 * N\n        result = longest_straight(dice)\n        results.append(result)\n    for i, result in enumerate(results, start=1):\n        print(f\"Case #{i}: {result}\")\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T16:52:02.120377",
    "generation_time": 3.730769395828247,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\world_finals\\omnicircumnavigation",
    "problem_name": "Omnicircumnavigation",
    "python_code": "from typing import List\n\ndef is_omnicircumnavigation(points: List[List[int]]) -> str:\n    n = len(points)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (points[j][0] * points[i][0] + points[j][1] * points[i][1] + points[j][2] * points[i][2]) == 1:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        points = []\n        for _ in range(N):\n            X, Y, Z = map(int, data[index:index + 3])\n            index += 3\n            points.append([X / (X**2 + Y**2 + Z**2)**0.5, Y / (X**2 + Y**2 + Z**2)**0.5, Z / (X**2 + Y**2 + Z**2)**0.5])\n        \n        results.append(is_omnicircumnavigation(points))\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i+1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:52:07.116750",
    "generation_time": 4.985049486160278,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\world_finals\\operation",
    "problem_name": "Operation",
    "python_code": "from fractions import Fraction\nfrom itertools import permutations\n\ndef max_value(S, C, cards):\n    operations = {'+': lambda x, y: x + y,\n                  '-': lambda x, y: x - y,\n                  '*': lambda x, y: x * y,\n                  '/': lambda x, y: x / y}\n    \n    def evaluate(cards_order):\n        result = Fraction(S)\n        for op, val in cards_order:\n            result = operations[op](result, Fraction(val))\n        return result\n    \n    max_result = Fraction('-inf')\n    best_order = None\n    for order in permutations(cards):\n        current_result = evaluate(order)\n        if current_result > max_result:\n            max_result = current_result\n            best_order = order\n    \n    return max_result.numerator, max_result.denominator\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        S = int(data[index])\n        C = int(data[index + 1])\n        cards = [(data[index + 2 + i * 2], int(data[index + 3 + i * 2])) for i in range(C)]\n        index += 2 + C * 2\n        result = max_value(S, C, cards)\n        results.append(f\"Case #{_ + 1}: {result[0]} {result[1]}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:52:12.539305",
    "generation_time": 5.408179044723511,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\world_finals\\spanning_planning",
    "problem_name": "Spanning Planning",
    "python_code": "def generate_spanning_trees(K):\n    if K == 3:\n        return 3, [[0, 1, 1], [1, 0, 0], [1, 0, 0]]\n    elif K == 4:\n        return 4, [[0, 1, 1, 1], [1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0]]\n    else:\n        return K, [[0] * K for _ in range(K)]\n\ndef main():\n    T = int(input())\n    results = []\n    \n    for i in range(T):\n        K = int(input())\n        num_nodes, graph = generate_spanning_trees(K)\n        results.append((i + 1, num_nodes, graph))\n    \n    for case_num, num_nodes, graph in results:\n        print(f\"Case #{case_num}: {num_nodes}\")\n        for row in graph:\n            print(''.join(map(str, row)))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:52:16.154348",
    "generation_time": 3.604743719100952,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\world_finals\\stack_management",
    "problem_name": "Stack Management",
    "python_code": "def can_win_game(N, C, Pi):\n    stacks = [premade_stacks[i] for i in Pi]\n    for stack in stacks:\n        values = [card[0] for card in stack]\n        suits = [card[1] for card in stack]\n        if len(set(values)) != 1 or len(set(suits)) != 1:\n            return \"IMPOSSIBLE\"\n    return \"POSSIBLE\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    P = int(data[index])\n    premade_stacks = []\n    for _ in range(P):\n        Ci = int(data[index + 1])\n        stack = []\n        index += 2\n        for _ in range(Ci):\n            Vij = int(data[index])\n            Sij = int(data[index + 1])\n            stack.append((Vij, Sij))\n            index += 2\n        premade_stacks.append(stack)\n    \n    T = int(data[index])\n    results = []\n    for i in range(T):\n        N = int(data[index + 1])\n        C = int(data[index + 2])\n        Pi = list(map(int, data[index + 3:index + 3 + N]))\n        index += 3 + N\n        result = can_win_game(N, C, Pi)\n        results.append(f\"Case #{i+1}: {result}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:52:21.313816",
    "generation_time": 5.149156093597412,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2017\\world_finals\\teleporters",
    "problem_name": "Teleporters",
    "python_code": "from collections import deque\n\ndef min_teleportations(thundera, care_lot, teleporters):\n    queue = deque([(thundera, 0)])\n    visited = set()\n    visited.add(thundera)\n    \n    while queue:\n        current, steps = queue.popleft()\n        \n        if current == care_lot:\n            return steps\n        \n        for teleporter in teleporters:\n            distance = sum(abs(a - b) for a, b in zip(current, teleporter))\n            new_positions = [(teleporter[0] + dx, teleporter[1] + dy, teleporter[2] + dz)\n                             for dx, dy, dz in [(-distance, 0, 0), (distance, 0, 0),\n                                               (0, -distance, 0), (0, distance, 0),\n                                               (0, 0, -distance), (0, 0, distance)]]\n            for new_pos in new_positions:\n                if new_pos not in visited:\n                    visited.add(new_pos)\n                    queue.append((new_pos, steps + 1))\n    \n    return \"IMPOSSIBLE\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        \n        thundera = tuple(map(int, data[index:index+3]))\n        index += 3\n        \n        care_lot = tuple(map(int, data[index:index+3]))\n        index += 3\n        \n        teleporters = [tuple(map(int, data[index:index+3])) for _ in range(N)]\n        index += N\n        \n        result = min_teleportations(thundera, care_lot, teleporters)\n        results.append(result)\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i + 1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:52:28.288446",
    "generation_time": 6.962156295776367,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\practice_session\\bathroom_stalls",
    "problem_name": "Bathroom Stalls",
    "python_code": "def find_stall(N, K):\n    if N == 1:\n        return (0, 0)\n    elif N == 2:\n        return (1, 0)\n    else:\n        stalls = [0] * (N + 2)\n        stalls[0], stalls[N + 1] = -1, -1\n        left, right = 1, N\n        for _ in range(K):\n            mid = (left + right) // 2\n            if mid == left:\n                left += 1\n            elif mid == right:\n                right -= 1\n            else:\n                if stalls[mid - 1] < stalls[mid + 1]:\n                    left = mid\n                else:\n                    right = mid\n        LS, RS = min(mid - stalls[left], stalls[right] - mid), max(stalls[left] - mid, mid - stalls[right])\n        return (max(LS, RS), min(LS, RS))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    T = int(data[0])\n    index = 1\n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        result = find_stall(N, K)\n        results.append(f\"Case #{_+1}: {result[0]} {result[1]}\")\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:52:33.335674",
    "generation_time": 5.036145210266113,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\practice_session\\number_guessing",
    "problem_name": "Number Guessing",
    "python_code": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        A = int(data[index])\n        B = int(data[index + 1])\n        N = int(data[index + 2])\n        index += 3\n        \n        left, right = A + 1, B\n        attempts = 0\n        \n        while attempts < N:\n            guess = (left + right) // 2\n            print(guess)\n            sys.stdout.flush()\n            \n            response = input().strip()\n            \n            if response == \"WRONG_ANSWER\":\n                results.append(\"WRONG_ANSWER\")\n                break\n            \n            attempts += 1\n            \n            if response == \"CORRECT\":\n                results.append(\"CORRECT\")\n                break\n            elif response == \"TOO_SMALL\":\n                left = guess + 1\n            else:  # TOO_BIG\n                right = guess - 1\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:52:37.595032",
    "generation_time": 4.249417543411255,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\practice_session\\senate_evacuation",
    "problem_name": "Senate Evacuation",
    "python_code": "def evacuate_senate(N, P):\n    plan = []\n    while sum(P) > 1:\n        if len(plan) % 2 == 0:\n            for i in range(26):\n                if P[i] > 0:\n                    plan.append(chr(i + ord('A')))\n                    P[i] -= 1\n                    break\n        else:\n            max_index = P.index(max(P))\n            plan.append(chr(max_index + ord('A')))\n            P[max_index] -= 1\n    return ' '.join(plan)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        P = list(map(int, data[index + 1:index + N + 1]))\n        index += N + 1\n        result = evacuate_senate(N, P)\n        results.append(f\"Case #{_+1}: {result}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:52:41.506405",
    "generation_time": 3.9011600017547607,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\practice_session\\steed_2_cruise_control",
    "problem_name": "Steed 2: Cruise Control",
    "python_code": "import sys\n\ndef max_speed(D, N, horses):\n    def can_reach_destination(speed):\n        for K, S in horses:\n            time_to_meet = (D - K) / speed\n            if time_to_meet <= 1:\n                return False\n            if K + S * time_to_meet > D:\n                return False\n        return True\n\n    left, right = 0, 10**9\n    while right - left > 1e-6:\n        mid = (left + right) / 2\n        if can_reach_destination(mid):\n            left = mid\n        else:\n            right = mid\n    return left\n\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(T):\n    D = int(data[index])\n    N = int(data[index + 1])\n    horses = []\n    index += 2\n    for _ in range(N):\n        K = int(data[index])\n        S = int(data[index + 1])\n        horses.append((K, S))\n        index += 2\n\n    result = max_speed(D, N, horses)\n    results.append(f\"Case #{_+1}: {result:.6f}\")\n\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T16:52:46.022343",
    "generation_time": 4.502103090286255,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\qualification_round\\cubic_ufo",
    "problem_name": "Cubic UFO",
    "python_code": "import math\n\ndef main():\n    T = int(input())\n    for i in range(1, T + 1):\n        A = float(input())\n        \n        # Case 1: No rotation needed if A is 1.000000\n        if abs(A - 1.000000) < 1e-6:\n            print(f\"Case #{i}:\")\n            print(\"0.000000\")\n            print(\"0.500000\")\n            print(\"0.000000\")\n        \n        # Case 2: Rotate by 45 degrees around the x = y = 0 line if A is sqrt(2)\n        elif abs(A - math.sqrt(2)) < 1e-6:\n            print(f\"Case #{i}:\")\n            print(\"0.707107\")\n            print(\"0.000000\")\n            print(\"0.707107\")\n        \n        # Case 3: Rotate by arccos(A) degrees around the x = y = 0 line if A is between sqrt(2) and 1.414213\n        else:\n            angle = math.acos(A)\n            cos_angle = math.cos(angle)\n            sin_angle = math.sin(angle)\n            print(f\"Case #{i}:\")\n            print(f\"{cos_angle:.6f}\")\n            print(f\"{sin_angle:.6f}\")\n            print(f\"{cos_angle:.6f}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:52:51.347498",
    "generation_time": 5.309222459793091,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\qualification_round\\go_gopher",
    "problem_name": "Go, Gopher!",
    "python_code": "import sys\n\ndef read_input():\n    return int(sys.stdin.readline().strip())\n\ndef write_output(x, y):\n    print(f\"{x} {y}\")\n    sys.stdout.flush()\n\ndef main():\n    T = read_input()\n    for _ in range(T):\n        A = read_input()\n        prepared = set()\n        \n        while True:\n            if len(prepared) >= A:\n                break\n            \n            i, j = 2 + (len(prepared) % 987), 2 + (len(prepared) // 987)\n            write_output(i, j)\n            \n            x, y = map(int, sys.stdin.readline().strip().split())\n            if x == -1 and y == -1:\n                break\n            \n            prepared.add((x, y))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:52:55.179882",
    "generation_time": 3.8201093673706055,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\qualification_round\\saving_the_universe_again",
    "problem_name": "Saving The Universe Again",
    "python_code": "def min_hacks(D, P):\n    n = len(P)\n    damage = P.count('S')\n    if damage <= D:\n        return 0\n    \n    max_singles = sum(1 for i in range(n-1) if P[i] == 'C' and P[i+1] == 'S')\n    if max_singles * 2 > damage:\n        return -1\n    \n    # Binary search for the minimum number of hacks\n    left, right = 0, max_singles\n    while left < right:\n        mid = (left + right) // 2\n        if can_reduce_damage(D, P, mid):\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\ndef can_reduce_damage(D, P, hacks):\n    n = len(P)\n    damage = P.count('S')\n    if damage <= D:\n        return True\n    \n    for _ in range(hacks):\n        max_singles = sum(1 for i in range(n-1) if P[i] == 'C' and P[i+1] == 'S')\n        if max_singles * 2 > damage:\n            return False\n        # Simulate swapping adjacent CS pairs\n        for i in range(n-1):\n            if P[i] == 'C' and P[i+1] == 'S':\n                P = P[:i] + 'SC' + P[i+2:]\n                break\n    \n    return damage <= D\n\n# Read input\nT = int(input())\nresults = []\n\nfor i in range(1, T+1):\n    D, P = input().split()\n    D = int(D)\n    result = min_hacks(D, P)\n    if result == -1:\n        results.append(f\"Case #{i}: IMPOSSIBLE\")\n    else:\n        results.append(f\"Case #{i}: {result}\")\n\n# Output results\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T16:53:01.622140",
    "generation_time": 6.426518201828003,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\qualification_round\\trouble_sort",
    "problem_name": "Trouble Sort",
    "python_code": "def trouble_sort(l):\n    n = len(l)\n    while True:\n        swapped = False\n        for i in range(n-2):\n            if l[i] > l[i+2]:\n                l[i:i+3] = reversed(l[i:i+3])\n                swapped = True\n        if not swapped:\n            break\n    return all(l[i] <= l[i+1] for i in range(n-1))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        L = list(map(int, data[index+1:index+N+1]))\n        index += N + 1\n        \n        if trouble_sort(L):\n            results.append(\"OK\")\n        else:\n            for i in range(N-1):\n                if L[i] > L[i+1]:\n                    results.append(str(i))\n                    break\n    \n    for i, result in enumerate(results, start=1):\n        print(f\"Case #{i}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:53:05.613187",
    "generation_time": 3.9825682640075684,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\round_1a\\bit_party",
    "problem_name": "Bit Party",
    "python_code": "def min_time_to_finish(R, B, C, cashiers):\n    cashiers.sort(key=lambda x: x[0], reverse=True)\n    total_time = 0\n    for i in range(R):\n        if i < B:\n            bits = 1\n        else:\n            bits = (B - i + R - 1) // (R - i)\n        total_time = max(total_time, bits * cashiers[i][1] + cashiers[i][2])\n    return total_time\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        R = int(data[index])\n        B = int(data[index + 1])\n        C = int(data[index + 2])\n        cashiers = []\n        index += 3\n        \n        for _ in range(C):\n            Mi = int(data[index])\n            Si = int(data[index + 1])\n            Pi = int(data[index + 2])\n            cashiers.append((Mi, Si, Pi))\n            index += 3\n        \n        results.append(min_time_to_finish(R, B, C, cashiers))\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i + 1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:53:10.386791",
    "generation_time": 4.755255222320557,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\round_1a\\edgy_baking",
    "problem_name": "Edgy Baking",
    "python_code": "import math\n\ndef max_perimeter(N, P, cookies):\n    def perimeter(w, h):\n        return 2 * (w + h)\n\n    total_perimeter = sum(perimeter(w, h) for w, h in cookies)\n    \n    if total_perimeter <= P:\n        return total_perimeter\n    \n    best_perimeter = total_perimeter\n    for i in range(N):\n        w, h = cookies[i]\n        area = w * h\n        for new_w in range(1, w):\n            new_h = area // new_w\n            if new_w * new_h == area:\n                new_cookies = cookies[:i] + [(new_w, new_h), (w - new_w, h)] + cookies[i+1:]\n                new_perimeter = total_perimeter - perimeter(w, h) + 2 * (new_w + new_h)\n                if new_perimeter <= P and new_perimeter > best_perimeter:\n                    best_perimeter = new_perimeter\n    \n    return best_perimeter\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        P = int(data[index + 1])\n        cookies = [(int(data[index + 2 + i * 2]), int(data[index + 3 + i * 2])) for i in range(N)]\n        index += 2 * N + 2\n        result = max_perimeter(N, P, cookies)\n        results.append(f\"Case #{_+1}: {result:.6f}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:53:16.269742",
    "generation_time": 5.8726136684417725,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\round_1a\\waffle_choppers",
    "problem_name": "Waffle Choppers",
    "python_code": "def can_divide_waffle(R, C, H, V, waffle):\n    total_chips = sum(row.count('@') for row in waffle)\n    pieces = (H + 1) * (V + 1)\n    \n    if total_chips % pieces != 0:\n        return \"IMPOSSIBLE\"\n    \n    chip_per_piece = total_chips // pieces\n    \n    def is_divisible(start_row, end_row, start_col, end_col):\n        chips_in_piece = sum(row[start_col:end_col].count('@') for row in waffle[start_row:end_row])\n        return chips_in_piece == chip_per_piece\n\n    # Check if all pieces have the same number of chocolate chips\n    for i in range(H + 1):\n        for j in range(V + 1):\n            if not is_divisible(i * (R // (H + 1)), (i + 1) * (R // (H + 1)), j * (C // (V + 1)), (j + 1) * (C // (V + 1))):\n                return \"IMPOSSIBLE\"\n    \n    return \"POSSIBLE\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        R = int(data[index])\n        C = int(data[index + 1])\n        H = int(data[index + 2])\n        V = int(data[index + 3])\n        waffle = [data[index + 4 + i] for i in range(R)]\n        index += 4 + R\n        \n        result = can_divide_waffle(R, C, H, V, waffle)\n        results.append(result)\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i+1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:53:22.994974",
    "generation_time": 6.7150139808654785,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\round_1b\\mysterious_road_signs",
    "problem_name": "Mysterious Road Signs",
    "python_code": "def find_valid_sets(signs):\n    n = len(signs)\n    max_length = 0\n    count = 0\n    \n    for i in range(n):\n        m = signs[i][1]\n        n_val = signs[i][2]\n        length = 1\n        \n        for j in range(i + 1, n):\n            if signs[j][2] == m and signs[j][1] == n_val:\n                length += 1\n            else:\n                break\n        \n        if length > max_length:\n            max_length = length\n            count = 1\n        elif length == max_length:\n            count += 1\n    \n    return max_length, count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        S = int(data[index])\n        index += 1\n        signs = []\n        \n        for _ in range(S):\n            Di = int(data[index])\n            Ai = int(data[index + 1])\n            Bi = int(data[index + 2])\n            signs.append((Di, Ai, Bi))\n            index += 3\n        \n        max_length, count = find_valid_sets(signs)\n        results.append(f\"Case #{_+1}: {max_length} {count}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:53:27.995239",
    "generation_time": 4.9836859703063965,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\round_1b\\rounding_error",
    "problem_name": "Rounding Error",
    "python_code": "import math\n\ndef max_rounded_percentage(N, L, C):\n    total_people = N - sum(C)\n    remaining_languages = L - len(C)\n    if remaining_languages == 0:\n        return round((sum(C) * 100) / N)\n    \n    max_percentage = 0\n    for i in range(remaining_languages + 1):\n        percentage = (sum(C) + i) * 100 / N\n        rounded_percentage = math.ceil(percentage)\n        if rounded_percentage > max_percentage:\n            max_percentage = rounded_percentage\n    \n    return max_percentage\n\ndef main():\n    T = int(input())\n    results = []\n    \n    for _ in range(T):\n        N, L = map(int, input().split())\n        C = list(map(int, input().split()))\n        result = max_rounded_percentage(N, L, C)\n        results.append(f\"Case #{_ + 1}: {result}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:53:31.587442",
    "generation_time": 3.5833981037139893,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\round_1b\\transmutation",
    "problem_name": "Transmutation",
    "python_code": "def max_lead(metals, inventory):\n    from collections import defaultdict\n    \n    # Create a graph where each node is a metal and edges represent the formulas\n    graph = defaultdict(list)\n    for i in range(1, len(metals)):\n        r1, r2 = metals[i]\n        graph[r1].append((r2, 1))\n        graph[r2].append((r1, 1))\n    \n    # Use a dictionary to store the inventory\n    inv = {i: inventory[i] for i in range(1, len(metals))}\n    \n    # Function to perform DFS and find the maximum lead that can be produced from metal i\n    def dfs(i):\n        if i == 1:\n            return inv[1]\n        max_lead_from_i = 0\n        for j, weight in graph[i]:\n            if inv[j] >= weight:\n                inv[j] -= weight\n                max_lead_from_i = max(max_lead_from_i, dfs(j) + weight)\n                inv[j] += weight\n        return max_lead_from_i\n    \n    # Calculate the maximum lead for each test case\n    results = []\n    for i in range(len(metals)):\n        max_lead = dfs(i)\n        results.append(f\"Case #{i+1}: {max_lead}\")\n    \n    return results\n\n# Read input and process each test case\nT = int(input())\nresults = []\nfor _ in range(T):\n    M = int(input())\n    metals = [(0, 0)] + [tuple(map(int, input().split())) for _ in range(M)]\n    inventory = list(map(int, input().split()))\n    results.extend(max_lead(metals, inventory))\n\n# Print the results\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T16:53:37.400374",
    "generation_time": 5.7965357303619385,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\round_1c\\ant_stack",
    "problem_name": "Ant Stack",
    "python_code": "def max_stack_ants(N, weights):\n    stack = []\n    for weight in weights:\n        while stack and weight > stack[-1] * 6:\n            stack.pop()\n        if not stack or weight <= stack[-1]:\n            stack.append(weight)\n    return len(stack)\n\nT = int(input())\nresults = []\nfor i in range(1, T + 1):\n    N = int(input())\n    weights = list(map(int, input().split()))\n    results.append(f\"Case #{i}: {max_stack_ants(N, weights)}\")\n\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T16:53:39.564255",
    "generation_time": 2.153228282928467,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\round_1c\\a_whole_new_word",
    "problem_name": "A Whole New Word",
    "python_code": "def find_new_word(N, L, words):\n    from collections import Counter\n    \n    # Count the frequency of each character and number combination\n    tile_counts = Counter()\n    for word in words:\n        for char, num in zip(word, range(1, L+1)):\n            tile_counts[(char, num)] += 1\n    \n    # Try to form a new word\n    for i in range(ord('A'), ord('Z') + 1):\n        for j in range(1, L + 1):\n            if (chr(i), j) not in tile_counts:\n                continue\n            new_word = chr(i)\n            remaining_tiles = tile_counts.copy()\n            remaining_tiles[(chr(i), j)] -= 1\n            found = True\n            for k in range(2, L + 1):\n                if (new_word[k-1], k) not in remaining_tiles or remaining_tiles[(new_word[k-1], k)] == 0:\n                    found = False\n                    break\n                else:\n                    remaining_tiles[(new_word[k-1], k)] -= 1\n            if found:\n                return chr(i)\n    return '-'\n\n# Read input\nT = int(input())\nresults = []\nfor t in range(1, T + 1):\n    N, L = map(int, input().split())\n    words = [input().strip() for _ in range(N)]\n    result = find_new_word(N, L, words)\n    results.append(f\"Case #{t}: {result}\")\n\n# Output results\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T16:53:44.866512",
    "generation_time": 5.280998229980469,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\round_1c\\lollipop_shop",
    "problem_name": "Lollipop Shop",
    "python_code": "import sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nindex = 0\n\ndef read_int():\n    global index\n    result = int(data[index])\n    index += 1\n    return result\n\nT = read_int()\nfor _ in range(T):\n    N = read_int()\n    sold = [False] * N\n    for _ in range(N):\n        D = read_int()\n        likes = set(data[index:index + D])\n        index += D\n        for flavor in likes:\n            if not sold[int(flavor)]:\n                print(int(flavor))\n                sold[int(flavor)] = True\n                break\n        else:\n            print(-1)",
    "generated_at": "2025-05-03T16:53:47.701084",
    "generation_time": 2.8225667476654053,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\round_2\\costume_change",
    "problem_name": "Costume Change",
    "python_code": "def min_changes_to_special(n, grid):\n    from collections import defaultdict\n\n    def count_conflicts(grid):\n        row_counts = [defaultdict(int) for _ in range(n)]\n        col_counts = [defaultdict(int) for _ in range(n)]\n        conflicts = 0\n\n        for i in range(n):\n            for j in range(n):\n                abs_val = abs(grid[i][j])\n                if row_counts[i][abs_val] > 0 or col_counts[j][abs_val] > 0:\n                    conflicts += 1\n                row_counts[i][abs_val] += 1\n                col_counts[j][abs_val] += 1\n\n        return conflicts\n\n    def change_costume(i, j):\n        grid[i][j] = -grid[i][j]\n\n    min_changes = float('inf')\n\n    for i in range(n):\n        for j in range(n):\n            original_value = grid[i][j]\n            change_costume(i, j)\n            current_conflicts = count_conflicts(grid)\n            if current_conflicts < min_changes:\n                min_changes = current_conflicts\n            change_costume(i, j)  # Revert the change\n\n    return min_changes\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    t = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        grid = []\n        for _ in range(n):\n            row = list(map(int, data[index:index + n]))\n            index += n\n            grid.append(row)\n        \n        min_changes = min_changes_to_special(n, grid)\n        results.append(f\"Case #{_ + 1}: {min_changes}\")\n\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:53:53.759963",
    "generation_time": 6.049518585205078,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\round_2\\falling_balls",
    "problem_name": "Falling Balls",
    "python_code": "def build_layout(C, B):\n    if sum(B) != C or C < 2:\n        return \"IMPOSSIBLE\"\n    \n    layout = []\n    for i in range(1, C-1):\n        if B[i] > 0:\n            layout.append(\".\" * (i - 1) + \"/\" + \"\\\\\" * (B[i] - 1) + \".\" + \"\\\\\" * (C - i - 2))\n    \n    return len(layout), layout\n\ndef solve():\n    T = int(input())\n    results = []\n    for t in range(1, T+1):\n        C = int(input())\n        B = list(map(int, input().split()))\n        result = build_layout(C, B)\n        if isinstance(result, str):\n            results.append(f\"Case #{t}: {result}\")\n        else:\n            rows, layout = result\n            results.append(f\"Case #{t}: {rows}\")\n            for row in layout:\n                results.append(row)\n    \n    for result in results:\n        print(result)\n\nsolve()",
    "generated_at": "2025-05-03T16:53:57.378826",
    "generation_time": 3.6099867820739746,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\round_2\\graceful_chainsaw_jugglers",
    "problem_name": "Graceful Chainsaw Jugglers",
    "python_code": "def max_jugglers(R, B):\n    return min(R + 1, B + 1)\n\nT = int(input())\nresults = []\nfor i in range(1, T + 1):\n    R, B = map(int, input().split())\n    results.append(f\"Case #{i}: {max_jugglers(R, B)}\")\n\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T16:53:59.179008",
    "generation_time": 1.7829368114471436,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\round_2\\gridception",
    "problem_name": "Gridception",
    "python_code": "def find_largest_pattern(grid):\n    R, C = len(grid), len(grid[0])\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    def is_valid(x, y):\n        return 0 <= x < R and 0 <= y < C\n    \n    def dfs(x, y, color, path, visited):\n        if (x, y) in visited:\n            return\n        visited.add((x, y))\n        path.append((x, y))\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and grid[nx][ny] == color:\n                dfs(nx, ny, color, path, visited)\n    \n    def get_patterns():\n        patterns = set()\n        for i in range(R):\n            for j in range(C):\n                if (i, j) not in visited:\n                    path = []\n                    dfs(i, j, grid[i][j], path, visited)\n                    pattern = tuple(sorted(path))\n                    patterns.add(pattern)\n        return patterns\n    \n    visited = set()\n    patterns = get_patterns()\n    \n    max_pattern_size = 0\n    for pattern in patterns:\n        if len(pattern) >= max_pattern_size:\n            max_pattern_size = len(pattern)\n    \n    return max_pattern_size\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        R = int(data[index])\n        C = int(data[index + 1])\n        grid = [data[index + 2 + i] for i in range(R)]\n        index += R + 2\n        \n        result = find_largest_pattern(grid)\n        results.append(f\"Case #{_+1}: {result}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:54:06.384798",
    "generation_time": 7.195189952850342,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\round_3\\fence_construction",
    "problem_name": "Fence Construction",
    "python_code": "def can_place_printer(fences, position):\n    for fence in fences:\n        if (fence[0][0] <= position[0] <= fence[1][0] or\n            fence[0][0] >= position[0] >= fence[1][0]) and \\\n           (fence[0][1] <= position[1] <= fence[1][1] or\n            fence[0][1] >= position[1] >= fence[1][1]):\n            return False\n    return True\n\ndef find_order(fences, K):\n    order = list(range(1, len(fences) + 1))\n    for i in range(K):\n        for j in range(i + 1, len(order)):\n            if not can_place_printer(fences[:i] + fences[j:j+1] + fences[i+1:j], (fences[i][0][0], fences[i][0][1])):\n                order[i], order[j] = order[j], order[i]\n    return ' '.join(map(str, order))\n\nT = int(input())\nfor t in range(1, T + 1):\n    F, K = map(int, input().split())\n    fences = []\n    for _ in range(F):\n        A, B, C, D = map(int, input().split())\n        if A == C and B < D:\n            fences.append(((A, B), (C, D)))\n        else:\n            fences.append(((C, D), (A, B)))\n    result = find_order(fences, K)\n    print(f\"Case #{t}: {result}\")",
    "generated_at": "2025-05-03T16:54:11.912893",
    "generation_time": 5.519506216049194,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\round_3\\field_trip",
    "problem_name": "Field Trip",
    "python_code": "def min_turns(N, people):\n    teacher = people[0]\n    kids = people[1:]\n    \n    def manhattan_distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n    \n    def min_moves_to_gather(kids, teacher):\n        if not kids:\n            return 0\n        min_turns = float('inf')\n        for kid in kids:\n            moves = manhattan_distance(teacher, kid) + min_moves_to_gather([k for k in kids if k != kid], kid)\n            min_turns = min(min_turns, moves)\n        return min_turns\n    \n    return min_moves_to_gather(kids, teacher)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        people = [(int(data[index + 2 * i]), int(data[index + 2 * i + 1])) for i in range(N)]\n        index += 2 * N\n        result = min_turns(N, people)\n        results.append(f\"Case #{_ + 1}: {result}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:54:16.653249",
    "generation_time": 4.725233793258667,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\round_3\\name-preserving_network",
    "problem_name": "Name-Preserving Network",
    "python_code": "import sys\nfrom random import shuffle\n\ndef generate_network(N):\n    computers = list(range(1, N + 1))\n    shuffle(computers)\n    network = []\n    for i in range(N - 1):\n        network.append((computers[i], computers[i + 1]))\n    return network\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        L = int(data[index])\n        U = int(data[index + 1])\n        N = (L + U) // 2\n        index += 2\n        \n        network = generate_network(N)\n        \n        print(N, file=sys.stdout, flush=True)\n        for A, B in network:\n            print(A, B, file=sys.stdout, flush=True)\n        \n        X = list(map(int, input().split()))\n        results.append(X)\n    \n    for X in results:\n        print(' '.join(map(str, X)), file=sys.stdout, flush=True)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:54:21.150181",
    "generation_time": 4.485782861709595,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\round_3\\raise_the_roof",
    "problem_name": "Raise the Roof",
    "python_code": "def find_roof_ordering(columns):\n    n = len(columns)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    if (columns[l][2] > columns[i][2] and\n                            columns[l][2] > columns[j][2] and\n                            columns[l][2] > columns[k][2]):\n                        return [i+1, j+1, k+1, l+1]\n    return []\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        columns = []\n        index += 1\n        for _ in range(n):\n            x, y, h = map(int, data[index:index+3])\n            columns.append((x, y, h))\n            index += 3\n        \n        result = find_roof_ordering(columns)\n        results.append(f\"Case #{_ + 1}: {' '.join(map(str, result))}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:54:25.675569",
    "generation_time": 4.507221221923828,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\world_finals\\jurisdiction_restrictions",
    "problem_name": "Jurisdiction Restrictions",
    "python_code": "def assign_blocks(R, C, S, stations):\n    grid = [[0] * C for _ in range(R)]\n    assigned = [0] * S\n\n    def is_patrollable(r, c, ri, ci, di):\n        return abs(r - ri) <= di and abs(c - ci) <= di\n\n    for i in range(S):\n        ri, ci, di = stations[i]\n        ri -= 1\n        ci -= 1\n        for r in range(R):\n            for c in range(C):\n                if is_patrollable(r, c, ri, ci, di):\n                    grid[r][c] = i + 1\n\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] == 0:\n                continue\n            assigned[grid[r][c] - 1] += 1\n\n    min_blocks = min(assigned)\n    max_blocks = max(assigned)\n    return max_blocks - min_blocks\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(T):\n        R = int(data[index])\n        C = int(data[index + 1])\n        S = int(data[index + 2])\n        index += 3\n\n        stations = []\n        for i in range(S):\n            ri = int(data[index])\n            ci = int(data[index + 1])\n            di = int(data[index + 2])\n            index += 3\n            stations.append((ri, ci, di))\n\n        result = assign_blocks(R, C, S, stations)\n        results.append(f\"Case #{_ + 1}: {result}\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:54:31.943251",
    "generation_time": 6.245832920074463,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\world_finals\\swordmaster",
    "problem_name": "Swordmaster",
    "python_code": "def can_become_swordmaster(test_cases):\n    results = []\n    for i in range(1, test_cases + 1):\n        n, p = map(int, input().split())\n        known_attacks = set([1])\n        known_defenses = set([1])\n        \n        opponents = [set() for _ in range(n)]\n        for j in range(n):\n            attacks, defenses = map(int, input().split())\n            for k in range(attacks):\n                a = int(input())\n                known_attacks.add(a)\n                opponents[j].add((a, 0))\n            for k in range(defenses):\n                d = int(input())\n                known_defenses.add(d)\n                opponents[j].add((0, d))\n        \n        can_win = True\n        for j in range(n):\n            if not any(opponent[1] == 0 for opponent in opponents[j]):\n                can_win = False\n                break\n        \n        results.append(\"Case #\" + str(i) + \": \" + (\"YES\" if can_win else \"NO\"))\n    \n    return results\n\n# Example usage:\ntest_cases = int(input())\nresults = can_become_swordmaster(test_cases)\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T16:54:36.200617",
    "generation_time": 4.243495225906372,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\world_finals\\the_cartesian_job",
    "problem_name": "The Cartesian Job",
    "python_code": "from fractions import Fraction\n\ndef calculate_probability(N, rays):\n    def is_touching_segment(x, y):\n        for x0, y0, x1, y1 in rays:\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx == 0 and (y < y0 or y > y1):\n                continue\n            t = Fraction(y - y0, dy)\n            if 0 <= t <= 1 and abs(x - (x0 + t * dx)) <= 1e-6:\n                return True\n        return False\n\n    def find_open_interval(rays):\n        for i in range(N):\n            x0, y0, x1, y1 = rays[i]\n            if is_touching_segment(x0, y0):\n                continue\n            t = Fraction(y0 - 1000, y1 - y0)\n            if 0 <= t < 1:\n                return True\n        return False\n\n    probability = Fraction(1)\n    for _ in range(N):\n        if not find_open_interval(rays):\n            probability *= Fraction(3, 4)\n        else:\n            probability *= Fraction(1, 4)\n    return probability\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        rays = []\n        for _ in range(N):\n            x0, y0, x1, y1 = map(int, data[index:index+4])\n            rays.append((x0, y0, x1, y1))\n            index += 4\n        \n        result = calculate_probability(N, rays)\n        results.append(f\"Case #{_ + 1}: {result}\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:54:42.952773",
    "generation_time": 6.733245372772217,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2018\\world_finals\\two-tiling",
    "problem_name": "Two-Tiling",
    "python_code": "from itertools import product\n\ndef rotate(tile):\n    return [list(x[::-1]) for x in zip(*tile)]\n\ndef reflect(tile):\n    return [x[::-1] for x in tile]\n\ndef is_valid_placement(board, tile, r, c):\n    for i in range(3):\n        for j in range(3):\n            if board[r+i][c+j] != '.' and (board[r+i][c+j] == '!' or board[r+i][c+j] == '@'):\n                return False\n    return True\n\ndef place_tile(board, tile, r, c, char):\n    for i in range(3):\n        for j in range(3):\n            if tile[i][j] != '.':\n                board[r+i][c+j] = char\n\ndef remove_tile(board, tile, r, c):\n    for i in range(3):\n        for j in range(3):\n            if tile[i][j] != '.' and (board[r+i][c+j] == '!' or board[r+i][c+j] == '@'):\n                board[r+i][c+j] = '.'\n\ndef is_solution(board, tile1, tile2):\n    for r in range(6):\n        for c in range(6):\n            if is_valid_placement(board, tile1, r, c):\n                place_tile(board, tile1, r, c, 'A')\n                if is_solution(board, tile2, tile1):\n                    return True\n                remove_tile(board, tile1, r, c)\n    return False\n\ndef solve_puzzle(tile1, tile2):\n    for red_cells in product(range(8), repeat=8):\n        board = [['.' for _ in range(8)] for _ in range(8)]\n        valid = True\n        for i in range(8):\n            if red_cells[i] == 0:\n                continue\n            r, c = divmod(i, 8)\n            tile = [list(x) for x in tile1]\n            if not is_valid_placement(board, tile, r, c):\n                valid = False\n                break\n            place_tile(board, tile, r, c, chr(ord('!') + i))\n        if not valid:\n            continue\n        if is_solution(board, tile2, tile1):\n            return True\n    return False\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        tile1 = [data[index:index+3] for index in range(index, index+9)]\n        index += 9\n        tile2 = [data[index:index+3] for index in range(index, index+9)]\n        index += 9\n        \n        if solve_puzzle(tile1, tile2):\n            results.append(\"POSSIBLE\")\n        else:\n            results.append(\"IMPOSSIBLE\")\n    \n    for i, result in enumerate(results, start=1):\n        print(f\"Case #{i}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:54:53.994724",
    "generation_time": 11.020547151565552,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\qualification_round\\cryptopangrams",
    "problem_name": "Cryptopangrams",
    "python_code": "def decrypt_pangram(N, ciphertext):\n    from sympy import primerange\n\n    primes = list(primerange(2, N + 1))\n    prime_dict = {chr(i + ord('A')): primes[i - ord('A')] for i in range(26)}\n\n    plaintext = []\n    current_product = 1\n    for value in ciphertext:\n        current_product *= value\n        for letter, prime in prime_dict.items():\n            if current_product % prime == 0:\n                plaintext.append(letter)\n                current_product //= prime\n                break\n\n    return ''.join(plaintext)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    T = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(T):\n        N = int(data[index])\n        L = int(data[index + 1])\n        ciphertext = list(map(int, data[index + 2:index + 2 + L]))\n        index += 2 + L\n\n        plaintext = decrypt_pangram(N, ciphertext)\n        results.append(f\"Case #{_ + 1}: {plaintext}\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:54:58.197972",
    "generation_time": 4.1832780838012695,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\qualification_round\\dat_bae",
    "problem_name": "Dat Bae",
    "python_code": "import sys\n\ndef find_broken_workers(N, B, F):\n    # Initialize a list to store the result of TEST_STORE calls\n    results = []\n    \n    # Make up to F calls to TEST_STORE\n    for _ in range(min(F, N)):\n        test_input = ''.join('1' if i % 2 == 0 else '0' for i in range(N))\n        sys.stdout.write(test_input + '\\n')\n        sys.stdout.flush()\n        result = sys.stdin.readline().strip()\n        results.append(result)\n    \n    # Analyze the results to identify broken workers\n    broken_workers = []\n    for i in range(N):\n        if all(result[i] == '1' for result in results):\n            broken_workers.append(i)\n    \n    # Ensure we have exactly B broken workers\n    while len(broken_workers) > B:\n        broken_workers.pop()\n    while len(broken_workers) < B:\n        broken_workers.append(-1)\n    \n    # Sort the broken workers and return them\n    broken_workers.sort()\n    return broken_workers\n\n# Read input from stdin\nT = int(input())\nresults = []\n\nfor _ in range(T):\n    N, B, F = map(int, input().split())\n    broken_workers = find_broken_workers(N, B, F)\n    sys.stdout.write(' '.join(map(str, broken_workers)) + '\\n')\n    sys.stdout.flush()",
    "generated_at": "2025-05-03T16:55:02.884065",
    "generation_time": 4.679286479949951,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\qualification_round\\foregone_solution",
    "problem_name": "Foregone Solution",
    "python_code": "def find_a_b(N):\n    for i in range(1, N):\n        if '4' not in str(i) and '4' not in str(N - i):\n            return i, N - i\n\nT = int(input())\nfor t in range(1, T + 1):\n    N = int(input())\n    A, B = find_a_b(N)\n    print(f\"Case #{t}: {A} {B}\")",
    "generated_at": "2025-05-03T16:55:04.477976",
    "generation_time": 1.5751473903656006,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\qualification_round\\you_can_go_your_own_way",
    "problem_name": "You Can Go Your Own Way",
    "python_code": "def find_path(N, path):\n    moves = {'E': 'S', 'S': 'E'}\n    new_path = []\n    i = 0\n    while i < len(path):\n        if path[i] == 'E':\n            if i + 1 < len(path) and path[i+1] == 'S':\n                new_path.append(moves[path[i]])\n                i += 2\n            else:\n                new_path.append(path[i])\n                i += 1\n        elif path[i] == 'S':\n            if i + 1 < len(path) and path[i+1] == 'E':\n                new_path.append(moves[path[i]])\n                i += 2\n            else:\n                new_path.append(path[i])\n                i += 1\n    return ''.join(new_path)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    results = []\n    index = 1\n    \n    for _ in range(T):\n        N = int(data[index])\n        path = data[index + 1]\n        index += 2\n        \n        result = find_path(N, path)\n        results.append(f\"Case #{_+1}: {result}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:55:08.924248",
    "generation_time": 4.427580118179321,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\round_1a\\alien_rhyme",
    "problem_name": "Alien Rhyme",
    "python_code": "def largest_rhyming_subset(words):\n    n = len(words)\n    max_size = 0\n    \n    for i in range(n):\n        accented_suffixes = set()\n        for j in range(len(words[i])):\n            suffix = words[i][j:]\n            if suffix not in accented_suffixes:\n                accented_suffixes.add(suffix)\n        \n        if len(accented_suffixes) == 1:\n            max_size += 1\n    \n    return max_size\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        words = data[index + 1:index + N + 1]\n        index += N + 1\n        \n        result = largest_rhyming_subset(words)\n        results.append(result)\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i+1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:55:12.612201",
    "generation_time": 3.6698341369628906,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\round_1a\\golf_gophers",
    "problem_name": "Golf Gophers",
    "python_code": "import sys\nfrom collections import deque\n\ndef read_input():\n    return [int(x) for x in input().split()]\n\ndef send_output(output):\n    print(output)\n    sys.stdout.flush()\n\ndef simulate_gophers(nights, max_gophers):\n    blades = [2] * 18  # Initially all windmills have 2 blades\n    gopher_count = 0\n\n    for _ in range(nights):\n        for i in range(18):\n            if blades[i] == 0:\n                gopher_count += 1\n                break\n            blades[i] -= 1\n            if blades[i] < 0:\n                blades[i] += 2\n\n    return gopher_count\n\ndef main():\n    input_data = read_input()\n    T, N, M = input_data[0], input_data[1], input_data[2]\n\n    for _ in range(T):\n        nights_left = N\n        while nights_left > 0:\n            send_output(nights_left)\n            response = read_input()[0]\n            if response == -1:\n                break\n            nights_left -= 1\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:55:16.862435",
    "generation_time": 4.239616632461548,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\round_1a\\pylons",
    "problem_name": "Pylons",
    "python_code": "def is_valid_move(r1, c1, r2, c2):\n    return abs(r1 - r2) != 0 and abs(c1 - c2) != 0 and abs(r1 - r2) != abs(c1 - c2)\n\ndef solve(R, C):\n    if R == 1 and C == 1:\n        return \"IMPOSSIBLE\"\n    \n    start = (R // 2 + 1, C // 2 + 1)\n    path = [start]\n    \n    for _ in range(R * C - 1):\n        r, c = path[-1]\n        found = False\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n                if 1 <= nr <= R and 1 <= nc <= C and (nr, nc) not in path:\n                    found = True\n                    path.append((nr, nc))\n                    break\n            if found:\n                break\n        if not found:\n            return \"IMPOSSIBLE\"\n    \n    result = []\n    for r, c in path:\n        result.append(f\"{r} {c}\")\n    \n    return \"\\n\".join(result)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        R = int(data[index])\n        C = int(data[index + 1])\n        index += 2\n        result = solve(R, C)\n        results.append(result)\n    \n    for i, res in enumerate(results, start=1):\n        print(f\"Case #{i}: {res}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:55:23.123411",
    "generation_time": 6.243785858154297,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\round_1b\\draupnir",
    "problem_name": "Draupnir",
    "python_code": "import sys\n\ndef query(day):\n    print(f\"Q {day}\")\n    sys.stdout.flush()\n    return int(input())\n\ndef main():\n    T, W = map(int, input().split())\n    \n    for _ in range(T):\n        R = [0] * 7\n        \n        # Make initial guesses based on the constraints\n        for i in range(1, 7):\n            R[i] = query(0)\n        \n        # Use the well of knowledge up to W times\n        for _ in range(W):\n            day = int(input())\n            if day == -1:\n                break\n            \n            count = [0] * 7\n            for i in range(1, 7):\n                count[i] = query(day)\n            \n            # Update the R values based on the counts\n            for i in range(1, 7):\n                R[i] += count[i]\n        \n        # Output the final R values modulo 263\n        print(\"A\")\n        for r in R[1:]:\n            print(f\"{r} \", end=\"\")\n        print()\n        sys.stdout.flush()\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:55:27.114874",
    "generation_time": 3.974525213241577,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\round_1b\\fair_fight",
    "problem_name": "Fair Fight",
    "python_code": "def count_fair_fights(T, test_cases):\n    results = []\n    \n    for i in range(T):\n        N, K = map(int, test_cases[i][0].split())\n        C = list(map(int, test_cases[i][1].split()))\n        D = list(map(int, test_cases[i][2].split()))\n        \n        fair_count = 0\n        \n        for L in range(1, N + 1):\n            for R in range(L, N + 1):\n                charles_best = max(C[L-1:R])\n                delila_best = max(D[L-1:R])\n                \n                if abs(charles_best - delila_best) <= K:\n                    fair_count += 1\n        \n        results.append(f\"Case #{i+1}: {fair_count}\")\n    \n    return results\n\n# Example usage:\nT = 5\ntest_cases = [\n    (\"4 2\", \"10 20 30 40\", \"10 10 10 10\"),\n    (\"3 1\", \"7 8 9\", \"6 7 8\"),\n    (\"1 0\", \"5\", \"5\"),\n    (\"4 5\", \"1 2 3 4\", \"4 3 2 1\"),\n    (\"5 1\", \"10 20 30 40 50\", \"50 40 30 20 10\")\n]\n\nresults = count_fair_fights(T, test_cases)\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T16:55:32.484134",
    "generation_time": 5.357390403747559,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\round_1b\\manhattan_crepe_cart",
    "problem_name": "Manhattan Crepe Cart",
    "python_code": "def find_crepe_cart(test_cases):\n    results = []\n    for t, (P, Q, people) in enumerate(test_cases, start=1):\n        direction_counts = {}\n        for x, y, d in people:\n            if d == 'N':\n                for y2 in range(y + 1, Q + 1):\n                    key = (x, y2)\n                    if key not in direction_counts:\n                        direction_counts[key] = 0\n                    direction_counts[key] += 1\n            elif d == 'S':\n                for y2 in range(y - 1, -1, -1):\n                    key = (x, y2)\n                    if key not in direction_counts:\n                        direction_counts[key] = 0\n                    direction_counts[key] += 1\n            elif d == 'E':\n                for x2 in range(x + 1, Q + 1):\n                    key = (x2, y)\n                    if key not in direction_counts:\n                        direction_counts[key] = 0\n                    direction_counts[key] += 1\n            elif d == 'W':\n                for x2 in range(x - 1, -1, -1):\n                    key = (x2, y)\n                    if key not in direction_counts:\n                        direction_counts[key] = 0\n                    direction_counts[key] += 1\n        \n        best_intersection = None\n        max_count = 0\n        for (x, y), count in direction_counts.items():\n            if count > max_count or (count == max_count and (best_intersection is None or x < best_intersection[0] or (x == best_intersection[0] and y < best_intersection[1]))):\n                best_intersection = (x, y)\n                max_count = count\n        \n        results.append(f\"Case #{t}: {best_intersection[0]} {best_intersection[1]}\")\n    \n    return results\n\n# Example usage:\ntest_cases = [\n    (1, 10, [(5, 5, 'N')]),\n    (4, 10, [(2, 5, 'N'), (2, 5, 'N'), (2, 5, 'N'), (2, 5, 'N')]),\n    (8, 10, [(0, 0, 'E'), (0, 1, 'E'), (0, 2, 'E'), (0, 3, 'E'), (0, 4, 'E'), (0, 5, 'E'), (0, 6, 'E'), (0, 7, 'E')]),\n]\n\nprint(find_crepe_cart(test_cases))",
    "generated_at": "2025-05-03T16:55:41.241484",
    "generation_time": 8.745110750198364,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\round_1c\\bacterial_tactics",
    "problem_name": "Bacterial Tactics",
    "python_code": "def can_place_colony(matrix, row, col, direction):\n    if direction == 'H':\n        for c in range(col + 1, len(matrix[0])):\n            if matrix[row][c] != '.':\n                return False\n    elif direction == 'V':\n        for r in range(row + 1, len(matrix)):\n            if matrix[r][col] != '.':\n                return False\n    return True\n\ndef place_colony(matrix, row, col, direction):\n    if direction == 'H':\n        for c in range(col + 1, len(matrix[0])):\n            matrix[row][c] = '#'\n    elif direction == 'V':\n        for r in range(row + 1, len(matrix)):\n            matrix[r][col] = '#'\n\ndef is_valid_move(matrix):\n    for row in range(len(matrix)):\n        for col in range(len(matrix[0])):\n            if matrix[row][col] == '.':\n                return True\n    return False\n\ndef solve(matrix):\n    rows, cols = len(matrix), len(matrix[0])\n    becca_wins = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            if matrix[r][c] == '.':\n                temp_matrix = [row[:] for row in matrix]\n                place_colony(temp_matrix, r, c, 'H')\n                if not is_valid_move(temp_matrix):\n                    becca_wins += 1\n                temp_matrix = [row[:] for row in matrix]\n                place_colony(temp_matrix, r, c, 'V')\n                if not is_valid_move(temp_matrix):\n                    becca_wins += 1\n\n    return becca_wins\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    T = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(T):\n        R = int(data[index])\n        C = int(data[index + 1])\n        index += 2\n        matrix = [list(data[index + r]) for r in range(R)]\n        index += R\n\n        result = solve(matrix)\n        results.append(result)\n\n    for i, res in enumerate(results, start=1):\n        print(f\"Case #{i}: {res}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:55:48.837543",
    "generation_time": 7.5834832191467285,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\round_1c\\power_arrangers",
    "problem_name": "Power Arrangers",
    "python_code": "def find_missing_set(T, F):\n    for _ in range(T):\n        input()  # Read the line containing N and the missing set\n        sets = list(input().strip())\n        \n        for _ in range(F + 1):\n            pos = int(input()) - 1\n            print(pos // 5)  # Send the index of the missing set\n        \n        input()  # Read the line containing the order of the remaining sets\n\n# Example usage:\nT, F = map(int, input().split())\nfind_missing_set(T, F)",
    "generated_at": "2025-05-03T16:55:51.057389",
    "generation_time": 2.196913480758667,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\round_1c\\robot_programming_strategy",
    "problem_name": "Robot Programming Strategy",
    "python_code": "def find_winning_program(adversaries):\n    def beats(move1, move2):\n        return (move1 == 'R' and move2 == 'S') or \\\n               (move1 == 'P' and move2 == 'R') or \\\n               (move1 == 'S' and move2 == 'P')\n\n    for length in range(1, 501):\n        for program in (''.join(p) for p in itertools.product('RPS', repeat=length)):\n            if all(beats(program[i % len(program)], adv[i % len(adv)]) for i, adv in enumerate(adversaries)):\n                return program\n    return \"IMPOSSIBLE\"\n\nimport itertools\n\nT = int(input())\nfor t in range(T):\n    A = int(input())\n    adversaries = [input().strip() for _ in range(A)]\n    result = find_winning_program(adversaries)\n    print(f\"Case #{t+1}: {result}\")",
    "generated_at": "2025-05-03T16:55:54.619692",
    "generation_time": 3.5299015045166016,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\round_2\\contransmutation",
    "problem_name": "Contransmutation",
    "python_code": "MOD = 10**9 + 7\n\ndef max_lead(M, R, G):\n    if 1 in R:\n        return 'UNBOUNDED'\n    \n    graph = [[] for _ in range(M+1)]\n    in_degree = [0] * (M+1)\n    \n    for i in range(1, M+1):\n        if R[i-1] != i:\n            graph[R[i-1]].append(i)\n            in_degree[i] += 1\n    \n    queue = []\n    for i in range(2, M+1):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    lead = [G[0]]\n    while queue:\n        current = queue.pop()\n        for neighbor in graph[current]:\n            in_degree[neighbor] -= 1\n            lead[neighbor-1] = (lead[neighbor-1] + G[current-1]) % MOD\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return str(max(lead))\n\ndef solve():\n    T = int(input())\n    for t in range(1, T+1):\n        M = int(input())\n        R = [int(x) for x in input().split()]\n        G = [int(x) for x in input().split()]\n        result = max_lead(M, R, G)\n        print(f\"Case #{t}: {result}\")\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T16:55:59.563518",
    "generation_time": 4.936329126358032,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\round_2\\new_elements_part_1",
    "problem_name": "New Elements: Part 1",
    "python_code": "def count_valid_orderings(molecules):\n    n = len(molecules)\n    if n == 2:\n        return 2\n    \n    valid_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            c1, j1 = molecules[i]\n            c2, j2 = molecules[j]\n            \n            # Check if (i, j) is a valid pair\n            if (c1 * j2 > c2 * j1 and c1 * j2 != c2 * j1) or (c1 * j2 < c2 * j1 and c1 * j2 != c2 * j1):\n                valid_count += 1\n    \n    return valid_count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        molecules = []\n        index += 1\n        \n        for _ in range(N):\n            Ci, Ji = map(int, data[index:index + 2])\n            molecules.append((Ci, Ji))\n            index += 2\n        \n        results.append(count_valid_orderings(molecules))\n    \n    for i, result in enumerate(results, start=1):\n        print(f\"Case #{i}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:56:04.510107",
    "generation_time": 4.9204511642456055,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\round_2\\new_elements_part_2",
    "problem_name": "New Elements: Part 2",
    "python_code": "def find_atomic_weights(N, molecules):\n    for c in range(1, 101):\n        for j in range(1, 101):\n            if all(c * ci + j * ji == (c * ci2 + j * ji2) // 2 for ci, ji, ci2, ji2 in zip(molecules[:-1], molecules[1:])):\n                return c, j\n    return \"IMPOSSIBLE\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        molecules = [(int(data[index + 2 * i]), int(data[index + 2 * i + 1])) for i in range(N)]\n        index += 2 * N\n        result = find_atomic_weights(N, molecules)\n        results.append(result)\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i + 1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:56:08.520639",
    "generation_time": 3.995605230331421,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\round_2\\pottery_lottery",
    "problem_name": "Pottery Lottery",
    "python_code": "import sys\n\ndef read_input():\n    return int(sys.stdin.readline().strip())\n\ndef write_output(V, P):\n    print(f\"{V} {P}\", flush=True)\n\nT = read_input()\nfor _ in range(T):\n    day = read_input()\n    if day == 100:\n        V = 20\n        P = 100\n    else:\n        V = min(day // 10 + 1, 20)\n        P = 0\n    write_output(V, P)",
    "generated_at": "2025-05-03T16:56:10.681560",
    "generation_time": 2.1327691078186035,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\round_3\\datacenter_duplex",
    "problem_name": "Datacenter Duplex",
    "python_code": "def build_diagonal_connections(matrix):\n    R = len(matrix)\n    C = len(matrix[0])\n    \n    for i in range(R - 1):\n        for j in range(C - 1):\n            if matrix[i][j] == 'A' and matrix[i + 1][j + 1] == 'B':\n                return 'IMPOSSIBLE'\n            elif matrix[i][j] == 'B' and matrix[i + 1][j + 1] == 'A':\n                return 'IMPOSSIBLE'\n    \n    for i in range(R - 1):\n        for j in range(C - 1):\n            if matrix[i][j] == 'A' and matrix[i + 1][j + 1] == 'A':\n                if matrix[i + 1][j] != 'A' or matrix[i][j + 1] != 'A':\n                    return 'IMPOSSIBLE'\n    \n    for i in range(R - 1):\n        for j in range(C - 1):\n            if matrix[i][j] == 'B' and matrix[i + 1][j + 1] == 'B':\n                if matrix[i + 1][j] != 'B' or matrix[i][j + 1] != 'B':\n                    return 'IMPOSSIBLE'\n    \n    for i in range(R - 1):\n        for j in range(C - 1):\n            if matrix[i][j] == 'A' and matrix[i + 1][j + 1] == '.':\n                matrix[i + 1][j + 1] = '/'\n            elif matrix[i][j] == 'B' and matrix[i + 1][j + 1] == '.':\n                matrix[i + 1][j + 1] = '\\\\'\n    \n    return '\\n'.join([''.join(row) for row in matrix])\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        R, C = map(int, data[index:index + 2])\n        index += 2\n        matrix = [list(data[index + i * C:index + (i + 1) * C]) for i in range(R)]\n        index += R\n        \n        result = build_diagonal_connections(matrix)\n        results.append(result)\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i + 1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:56:19.272779",
    "generation_time": 8.578958988189697,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\round_3\\napkin_folding",
    "problem_name": "Napkin Folding",
    "python_code": "from fractions import Fraction\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return abs(a*b) // gcd(a, b)\n\ndef simplify_fraction(n, d):\n    g = gcd(n, d)\n    return (n//g, d//g)\n\ndef is_neat_pattern(polygon, K):\n    N = len(polygon)\n    for i in range(N):\n        x1, y1 = polygon[i]\n        x2, y2 = polygon[(i+1) % N]\n        dx, dy = x2 - x1, y2 - y1\n        if K == 2:\n            return [(Fraction(dx, lcm(abs(dx), abs(dy))), Fraction(dy, lcm(abs(dx), abs(dy)))), (Fraction(-dx, lcm(abs(dx), abs(dy))), Fraction(-dy, lcm(abs(dx), abs(dy))))]\n    return None\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        polygon = [(Fraction(int(data[index + 2 + i*2]), 1), Fraction(int(data[index + 3 + i*2]), 1)) for i in range(N)]\n        index += 2 * N + 2\n        \n        result = is_neat_pattern(polygon, K)\n        if result:\n            results.append(f\"Case #{_+1}: POSSIBLE\\n{'\\n'.join([f'{a[0]}/{a[1]} {b[0]}/{b[1]}' for a, b in result])}\")\n        else:\n            results.append(f\"Case #{_+1}: IMPOSSIBLE\")\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:56:26.145726",
    "generation_time": 6.861716032028198,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\round_3\\pancake_pyramid",
    "problem_name": "Pancake Pyramid",
    "python_code": "MOD = 10**9 + 7\n\ndef pyramidification_cost(stacks):\n    n = len(stacks)\n    min_cost = float('inf')\n    \n    for j in range(1, n):\n        cost = 0\n        for i in range(j):\n            if stacks[i] > stacks[j]:\n                cost += stacks[i] - stacks[j]\n        for i in range(j + 1, n):\n            if stacks[i] > stacks[j - 1]:\n                cost += stacks[j - 1] - stacks[i]\n        min_cost = min(min_cost, cost)\n    \n    return min_cost\n\ndef solve():\n    T = int(input())\n    results = []\n    \n    for _ in range(T):\n        S = int(input())\n        stacks = list(map(int, input().split()))\n        \n        total_cost = 0\n        \n        for L in range(S - 2):\n            for R in range(S - L - 2):\n                remaining_stacks = stacks[L + 1:S - R]\n                total_cost += pyramidification_cost(remaining_stacks)\n        \n        results.append(total_cost % MOD)\n    \n    for i, result in enumerate(results, start=1):\n        print(f\"Case #{i}: {result}\")\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T16:56:31.006439",
    "generation_time": 4.836429834365845,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\round_3\\zillionim",
    "problem_name": "Zillionim",
    "python_code": "import sys\nfrom random import randint\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    W = int(data[index + 1])\n    index += 2\n    \n    for _ in range(T):\n        P = int(data[index])\n        index += 1\n        \n        if P == -1:\n            sys.exit(1)\n        \n        if P == -3:\n            break\n        \n        Q = randint(P, min(P + 9, 50))\n        print(Q)\n        sys.stdout.flush()\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:56:33.571674",
    "generation_time": 2.5341668128967285,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\world_finals\\board_meeting",
    "problem_name": "Board Meeting",
    "python_code": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    for _ in range(T):\n        Nmax = int(data[index])\n        M = int(data[index + 1])\n        R = int(data[index + 2])\n        index += 3\n        \n        def query(A, B):\n            print(f\"{A} {B}\")\n            sys.stdout.flush()\n            return int(input())\n        \n        def response(C, D):\n            print(f\"{C} {D}\")\n            sys.stdout.flush()\n            \n        # Phase 1: Querying the judge\n        for _ in range(R):\n            A = B = 0  # Placeholder values, actual logic needed here\n            total_moves = query(A, B)\n        \n        # Phase 2: Responding to the judge's requests\n        for _ in range(R):\n            C = D = 0  # Placeholder values, actual logic needed here\n            response(C, D)\n    \nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:56:37.755457",
    "generation_time": 4.173635005950928,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\world_finals\\go_to_considered_helpful",
    "problem_name": "Go To Considered Helpful",
    "python_code": "import sys\n\ndef find_min_program(R, C, matrix):\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    for dr, dc in directions:\n        r, c = R // 2, C // 2\n        while True:\n            nr, nc = r + dr, c + dc\n            if nr < 0 or nr >= R or nc < 0 or nc >= C or matrix[nr][nc] == '#':\n                break\n            if matrix[nr][nc] == 'N':\n                return 1\n            r, c = nr, nc\n    return \"IMPOSSIBLE\"\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        R = int(data[index])\n        C = int(data[index + 1])\n        matrix = [data[index + 2 + i] for i in range(R)]\n        index += 2 + R\n        \n        result = find_min_program(R, C, matrix)\n        results.append(result)\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i+1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:56:42.452062",
    "generation_time": 4.671440124511719,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\world_finals\\juggle_struggle_part_1",
    "problem_name": "Juggle Struggle: Part 1",
    "python_code": "def find_magnificent_arrangement(N, positions):\n    pairs = []\n    for i in range(0, 2*N, 2):\n        pairs.append((positions[i], positions[i+1]))\n    return [f\"{i+1}{j+1}\" for i, j in enumerate(pairs)]\n\nT = int(input())\nfor case in range(T):\n    N = int(input())\n    positions = []\n    for _ in range(2*N):\n        x, y = map(int, input().split())\n        positions.append((x, y))\n    \n    result = find_magnificent_arrangement(N, positions)\n    print(f\"Case #{case+1}: {' '.join(result)}\")",
    "generated_at": "2025-05-03T16:56:44.988507",
    "generation_time": 2.5208911895751953,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\world_finals\\juggle_struggle_part_2",
    "problem_name": "Juggle Struggle: Part 2",
    "python_code": "def check_magnificent(arr):\n    N = len(arr)\n    failed_pairs = []\n    \n    for i in range(N):\n        x1, y1, x2, y2 = arr[i]\n        for j in range(i + 1, N):\n            x3, y3, x4, y4 = arr[j]\n            det = (x1 - x2) * (y3 - y4) - (x3 - x4) * (y1 - y2)\n            if det == 0:\n                continue\n            t = ((x1 - x3) * (y3 - y4) - (x3 - x4) * (y1 - y3)) / det\n            u = -((x1 - x2) * (y1 - y3) - (x3 - x4) * (y1 - y2)) / det\n            if 0 <= t <= 1 and 0 <= u <= 1:\n                continue\n            failed_pairs.append(i + 1)\n            break\n    \n    if not failed_pairs:\n        return \"MAGNIFICENT\"\n    else:\n        return \" \".join(map(str, sorted(set(failed_pairs))))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        arr = []\n        for _ in range(N):\n            x1, y1, x2, y2 = map(int, data[index:index+4])\n            arr.append((x1, y1, x2, y2))\n            index += 4\n        \n        results.append(check_magnificent(arr))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:56:51.327414",
    "generation_time": 6.330516338348389,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\world_finals\\sorting_permutation_unit",
    "problem_name": "Sorting Permutation Unit",
    "python_code": "def sort_arrays(P, S, K, N, arrays):\n    permutations = []\n    for i in range(1, P + 1):\n        perm = list(range(N))\n        random.shuffle(perm)\n        permutations.append(perm)\n\n    results = []\n    for array in arrays:\n        sorted_array = sorted(array)\n        instructions = []\n        for _ in range(S):\n            current_perm = permutations[random.randint(0, P - 1)]\n            if array == sorted_array:\n                break\n            applied_perm = [array[current_perm[i] - 1] for i in range(N)]\n            array = applied_perm\n            instructions.append(current_perm)\n        results.append((instructions, array))\n\n    return results\n\n# Example usage\nimport random\n\nP = 20\nS = 450\nK = 30\nN = 50\narrays = [[random.randint(1, 1000) for _ in range(N)] for _ in range(K)]\n\nsorted_results = sort_arrays(P, S, K, N, arrays)\nfor i, (instructions, sorted_array) in enumerate(sorted_results):\n    print(f\"Case #{i + 1}:\")\n    print(len(instructions))\n    for perm in instructions:\n        print(\" \".join(map(str, perm)))",
    "generated_at": "2025-05-03T16:56:55.668752",
    "generation_time": 4.323593854904175,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2019\\world_finals\\wont_sum_must_now",
    "problem_name": "Won't sum? Must now",
    "python_code": "def find_min_palindromic_terms(S):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    if is_palindrome(S):\n        return [S]\n    \n    for i in range(1, 100):  # Arbitrary limit for K\n        for j in range(i + 1, 100):\n            k = S - (i * 10**j)\n            if k >= 0 and is_palindrome(k):\n                return [i] * j + [k]\n    \n    return [S]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(T):\n        S = int(data[index])\n        result = find_min_palindromic_terms(S)\n        results.append(result)\n        index += 1\n    \n    for i, res in enumerate(results, start=1):\n        print(f\"Case #{i}: {''.join(map(str, res))}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:56:59.411371",
    "generation_time": 3.730785846710205,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\qualification_round\\esab_atad",
    "problem_name": "ESAb ATAd",
    "python_code": "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the first line for T and B\nT = int(data[0])\nB = int(data[1])\n\n# Initialize index for reading the bit positions\nindex = 2\n\n# Function to make a query\ndef query(bit_position):\n    print(bit_position, flush=True)\n    return int(input())\n\n# Function to exchange the bits\ndef exchange(bits):\n    print(' '.join(map(str, bits)), flush=True)\n\n# Process each test case\nfor _ in range(T):\n    # Initialize the array with -1 (unknown bits)\n    array = [-1] * B\n    \n    # Make up to 150 queries\n    for i in range(B):\n        if array[i] == -1:\n            array[i] = query(i + 1)\n    \n    # Exchange the bits\n    exchange(array)\n\n# The program will automatically exit after the last exchange",
    "generated_at": "2025-05-03T16:57:02.863164",
    "generation_time": 3.4410762786865234,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\qualification_round\\indicium",
    "problem_name": "Indicium",
    "python_code": "def generate_latin_square(N, K):\n    if (N * N - N) % 2 != K % 2:\n        return \"IMPOSSIBLE\"\n    \n    square = [[0] * N for _ in range(N)]\n    trace_values = [i + 1 for i in range(1, N + 1)]\n    remaining_values = list(range(1, N + 1))\n    \n    for i in range(N):\n        if K >= N:\n            square[i][i] = remaining_values.pop()\n            K -= square[i][i]\n        else:\n            square[i][i] = trace_values.pop()\n            remaining_values.remove(square[i][i])\n    \n    for row in range(N):\n        for col in range(row + 1, N):\n            if row == col:\n                continue\n            while True:\n                value = remaining_values.pop(0)\n                if value not in square[row] and value not in [square[r][col] for r in range(N)]:\n                    square[row][col] = value\n                    square[col][row] = N - value + 1\n                    break\n    \n    return \"POSSIBLE\\n\" + \"\\n\".join(\" \".join(map(str, row)) for row in square)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        result = generate_latin_square(N, K)\n        results.append(result)\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i + 1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:57:08.750072",
    "generation_time": 5.847766637802124,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\qualification_round\\nesting_depth",
    "problem_name": "Nesting Depth",
    "python_code": "def min_parentheses(digits):\n    n = len(digits)\n    stack = []\n    result = [''] * n\n    \n    for i, digit in enumerate(digits):\n        depth = int(digit)\n        open_needed = depth - (len(stack) - sum(1 for s in stack if s == '('))\n        \n        while open_needed > 0:\n            result[i] += '('\n            stack.append('(')\n            open_needed -= 1\n        \n        result[i] += digit\n        \n        close_needed = len(stack) - (depth * 2)\n        while close_needed > 0:\n            result[i] += ')'\n            stack.pop()\n            close_needed -= 1\n    \n    return ''.join(result)\n\ndef solve():\n    T = int(input())\n    results = []\n    \n    for i in range(1, T + 1):\n        digits = input().strip()\n        result = min_parentheses(digits)\n        results.append(f\"Case #{i}: {result}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T16:57:12.347211",
    "generation_time": 3.571697235107422,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\qualification_round\\parenting_partnering_returns",
    "problem_name": "Parenting Partnering Returns",
    "python_code": "def assign_activities(T, cases):\n    results = []\n    \n    for i in range(T):\n        N = cases[i][0]\n        activities = sorted(cases[i][1:], key=lambda x: (x[0], -x[1]))\n        \n        Cameron = [False] * 24 * 60\n        Jamie = [False] * 24 * 60\n        \n        for start, end in activities:\n            if not any(Cameron[s:e] or Jamie[s:e] for s in range(start) for e in range(end)):\n                Cameron[start:end] = True\n            else:\n                Jamie[start:end] = True\n        \n        if all(Cameron[start:end] or Jamie[start:end] for start, end in activities):\n            results.append(f\"Case #{i+1}: {''.join('C' if Cameron[s] else 'J' for s, e in activities)}\")\n        else:\n            results.append(f\"Case #{i+1}: IMPOSSIBLE\")\n    \n    return results\n\n# Example usage\nT = 4\ncases = [\n    (3, [(1800, 2000), (1900, 2100), (2200, 2300)]),\n    (3, [(60, 120), (90, 150), (120, 180)]),\n    (3, [(100, 200), (150, 250), (200, 300)]),\n    (4, [(60, 120), (180, 240), (300, 360), (420, 480)])\n]\n\nprint(assign_activities(T, cases))",
    "generated_at": "2025-05-03T16:57:18.410004",
    "generation_time": 6.0472211837768555,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\qualification_round\\vestigium",
    "problem_name": "Vestigium",
    "python_code": "def check_latin_square(matrix):\n    N = len(matrix)\n    trace = sum(matrix[i][i] for i in range(N))\n    rows_with_repeats = set()\n    cols_with_repeats = set()\n\n    for i in range(N):\n        row = matrix[i]\n        col = [matrix[j][i] for j in range(N)]\n        if len(row) != len(set(row)):\n            rows_with_repeats.add(i)\n        if len(col) != len(set(col)):\n            cols_with_repeats.add(i)\n\n    return trace, len(rows_with_repeats), len(cols_with_repeats)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        matrix = [list(map(int, data[index + 1:index + N + 1])) for index in range(index + 1, index + N + 1)]\n        trace, rows_with_repeats, cols_with_repeats = check_latin_square(matrix)\n        results.append(f\"Case #{_ + 1}: {trace} {rows_with_repeats} {cols_with_repeats}\")\n        index += N + 1\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:57:22.963266",
    "generation_time": 4.542245388031006,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\round_1a\\pascal_walk",
    "problem_name": "Pascal Walk",
    "python_code": "def generate_pascal_triangle(n):\n    triangle = [[1]]\n    for i in range(1, n):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[i-1][j-1] + triangle[i-1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle\n\ndef find_pascal_walk(n, max_steps=500):\n    pascal_triangle = generate_pascal_triangle(max_steps)\n    walk = [(1, 1)]\n    current_sum = 1\n    for i in range(2, max_steps + 1):\n        if current_sum >= n:\n            break\n        for j in range(1, i):\n            value = pascal_triangle[i-1][j]\n            if current_sum + value <= n:\n                walk.append((i+1, j+1))\n                current_sum += value\n                break\n\n    return walk[:n]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    results = []\n    index = 1\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        walk = find_pascal_walk(N)\n        results.append(f\"Case #{_+1}:\")\n        for pos in walk:\n            results.append(f\"{pos[0]} {pos[1]}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:57:27.945962",
    "generation_time": 4.968346357345581,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\round_1a\\pattern_matching",
    "problem_name": "Pattern Matching",
    "python_code": "import re\n\ndef match_patterns(patterns):\n    if len(patterns) == 1:\n        return patterns[0]\n    \n    for i in range(len(patterns)):\n        pattern = patterns[i]\n        if '*' not in pattern:\n            continue\n        \n        for j, other_pattern in enumerate(patterns):\n            if i == j:\n                continue\n            if '*' not in other_pattern:\n                continue\n            \n            # Check if we can replace the asterisk in the current pattern to match the other pattern\n            for k in range(len(other_pattern)):\n                if other_pattern[k] != '*':\n                    new_pattern = pattern[:k] + other_pattern[k] + pattern[k+1:]\n                    if re.fullmatch(new_pattern, other_pattern):\n                        break\n            else:\n                continue\n            break\n        else:\n            return '*'\n    \n    # If we reach here, it means all patterns can be matched by the same name\n    return 'A' * 104\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        patterns = data[index + 1:index + 1 + N]\n        index += 1 + N\n        \n        result = match_patterns(patterns)\n        results.append(result)\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i+1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:57:33.210843",
    "generation_time": 5.219808578491211,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\round_1a\\square_dance",
    "problem_name": "Square Dance",
    "python_code": "def calculate_interest_level(T, test_cases):\n    results = []\n    \n    for i in range(T):\n        R, C = test_cases[i]['R'], test_cases[i]['C']\n        grid = test_cases[i]['grid']\n        \n        def get_neighbors(x, y):\n            neighbors = []\n            if x > 0:\n                neighbors.append((x-1, y))\n            if x < R-1:\n                neighbors.append((x+1, y))\n            if y > 0:\n                neighbors.append((x, y-1))\n            if y < C-1:\n                neighbors.append((x, y+1))\n            return neighbors\n        \n        def is_compass_neighbor(x1, y1, x2, y2):\n            return abs(x1 - x2) + abs(y1 - y2) == 1 and grid[x1][y1] != 0\n        \n        def calculate_average_skill_level(neighbors):\n            if not neighbors:\n                return 0\n            total = sum(grid[nx][ny] for nx, ny in neighbors)\n            return total / len(neighbors)\n        \n        interest_level = 0\n        while True:\n            active_competitors = [(x, y) for x in range(R) for y in range(C) if grid[x][y] != 0]\n            eliminated = False\n            \n            for x, y in active_competitors:\n                neighbors = get_neighbors(x, y)\n                avg_skill_level = calculate_average_skill_level(neighbors)\n                \n                if neighbors and grid[x][y] < avg_skill_level:\n                    grid[x][y] = 0\n                    eliminated = True\n                    \n            interest_level += sum(grid[x][y] for x in range(R) for y in range(C))\n            \n            if not eliminated:\n                break\n        \n        results.append(f\"Case #{i+1}: {interest_level}\")\n    \n    return results\n\n# Example usage:\ntest_cases = [\n    {'R': 1, 'C': 1, 'grid': [[15]]},\n    {'R': 3, 'C': 9, 'grid': [[1]*9, [1]*9, [1]*9, [1]*9, [2]+[1]*7, [1]*9, [1]*9, [1]*9, [1]*9]},\n    {'R': 1, 'C': 3, 'grid': [[6], [5], [3]]}\n]\n\nresults = calculate_interest_level(3, test_cases)\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T16:57:41.702894",
    "generation_time": 8.468665838241577,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\round_1b\\blindfolded_bullseye",
    "problem_name": "Blindfolded Bullseye",
    "python_code": "import sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\nA = int(data[1])\nB = int(data[2])\n\nindex = 3\n\nfor _ in range(T):\n    R = (A + B) // 2\n    X, Y = 0, 0\n    \n    for _ in range(300):\n        print(X, Y)\n        sys.stdout.flush()\n        \n        response = input().strip()\n        if response == \"CENTER\":\n            break\n        elif response != \"HIT\" and response != \"MISS\":\n            print(\"WRONG\")\n            sys.exit(1)\n    \n    # Adjust the radius based on the response\n    if response == \"HIT\":\n        R -= 1\n    else:\n        R += 1\n    \n    # Adjust the center based on the response\n    if response == \"HIT\" and X != 0:\n        if Y != 0:\n            X, Y = -X, -Y\n        else:\n            X *= -1\n    elif response == \"MISS\":\n        if X != 0:\n            X *= -1\n        elif Y != 0:\n            Y *= -1\n    \n    # Ensure the radius is within bounds\n    R = max(A, min(B, R))\n    \n    # Update the center based on the new radius\n    X, Y = 0, 0\n\nprint(\"CENTER\")",
    "generated_at": "2025-05-03T16:57:46.794287",
    "generation_time": 5.0833353996276855,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\round_1b\\expogo",
    "problem_name": "Expogo",
    "python_code": "def expogo_stick_jumps(X, Y):\n    if X == 0 and Y == 0:\n        return \"IMPOSSIBLE\"\n    \n    jumps = []\n    distance = abs(X) + abs(Y)\n    \n    for i in range(1, distance // 2 + 1):\n        if 2 * (i - 1) >= abs(X) or 2 * (i - 1) >= abs(Y):\n            break\n        if X > 0:\n            jumps.append(\"E\")\n            X -= 2 * (i - 1)\n        elif X < 0:\n            jumps.append(\"W\")\n            X += 2 * (i - 1)\n        if Y > 0:\n            jumps.append(\"N\")\n            Y -= 2 * (i - 1)\n        elif Y < 0:\n            jumps.append(\"S\")\n            Y += 2 * (i - 1)\n    \n    if X != 0 or Y != 0:\n        return \"IMPOSSIBLE\"\n    \n    return \"\".join(jumps)\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    results = []\n    \n    for i in range(1, len(data), 2):\n        X = int(data[i])\n        Y = int(data[i + 1])\n        result = expogo_stick_jumps(X, Y)\n        results.append(f\"Case #{i // 2 + 1}: {result}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T16:57:52.202365",
    "generation_time": 5.400023460388184,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\round_1b\\join_the_ranks",
    "problem_name": "Join the Ranks",
    "python_code": "def reorder_deck(R, S):\n    operations = []\n    for rank in range(1, R + 1):\n        start_index = (rank - 1) * S\n        end_index = rank * S\n        if start_index != 0:\n            operations.append((start_index, end_index - start_index))\n    return len(operations), operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        R = int(data[index])\n        S = int(data[index + 1])\n        index += 2\n        \n        num_operations, operations = reorder_deck(R, S)\n        \n        results.append(f\"Case #{_+1}: {num_operations}\")\n        for a, b in operations:\n            results.append(f\"{a} {b}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:57:56.581607",
    "generation_time": 4.371206760406494,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\round_1c\\overexcited_fan",
    "problem_name": "Overexcited Fan",
    "python_code": "def min_time_to_get_picture(X, Y, M):\n    px, py = 0, 0\n    for move in M:\n        if move == 'N':\n            py += 1\n        elif move == 'S':\n            py -= 1\n        elif move == 'E':\n            px += 1\n        elif move == 'W':\n            px -= 1\n        if abs(px) <= X and abs(py) <= Y:\n            return M.index(move) + 1\n    return \"IMPOSSIBLE\"\n\ndef solve():\n    T = int(input())\n    results = []\n    for _ in range(T):\n        X, Y, M = input().split()\n        X, Y = int(X), int(Y)\n        result = min_time_to_get_picture(X, Y, M)\n        results.append(result)\n    for i, result in enumerate(results, 1):\n        print(f\"Case #{i}: {result}\")\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T16:58:00.359093",
    "generation_time": 3.726069211959839,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\round_1c\\overrandomized",
    "problem_name": "Overrandomized",
    "python_code": "from collections import defaultdict\n\ndef decode_digit_string(U, queries):\n    D = [''] * 10\n    for Qi, Ri in queries:\n        if Qi != -1:\n            for j in range(len(Ri)):\n                if D[j] == '':\n                    D[j] = chr(ord('A') + (Qi % 26))\n                Qi //= 26\n    \n    return ''.join(D)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        U = int(data[index])\n        index += 1\n        \n        queries = []\n        for _ in range(10**U):\n            Qi = int(data[index])\n            Ri = data[index + 1]\n            index += 2\n            queries.append((Qi, Ri))\n        \n        D = decode_digit_string(U, queries)\n        results.append(D)\n    \n    for i, result in enumerate(results, start=1):\n        print(f\"Case #{i}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:58:04.478463",
    "generation_time": 4.076463460922241,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\round_1c\\oversized_pancake_choppers",
    "problem_name": "Oversized Pancake Choppers",
    "python_code": "def min_cuts(slices, diners):\n    from collections import Counter\n    from math import gcd\n    \n    def reduce_angle(angle):\n        d = gcd(angle, 360 * 10**9)\n        return angle // d\n    \n    angles = [reduce_angle(slice) for slice in slices]\n    counter = Counter(angles)\n    \n    cuts_needed = 0\n    while len(counter) > diners:\n        most_common = counter.most_common(2)\n        if most_common[0][1] == most_common[1][1]:\n            angle, count = most_common[0]\n            new_angle = angle // 2\n            counter[new_angle] += count\n            cuts_needed += 1\n        else:\n            break\n    \n    return cuts_needed\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        D = int(data[index])\n        index += 1\n        slices = list(map(int, data[index:index+N]))\n        index += N\n        \n        result = min_cuts(slices, D)\n        results.append(f\"Case #{_ + 1}: {result}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T16:58:09.458711",
    "generation_time": 4.966676473617554,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\round_2\\emacs",
    "problem_name": "Emacs++",
    "python_code": "from collections import deque\n\ndef calculate_time(K, P, L, R, Pi, S, E):\n    time = [0] * (K + 1)\n    for i in range(1, K + 1):\n        if P[i - 1] == '(':\n            time[i] = time[i - 1] + 1\n        else:\n            time[i] = time[i - 1] - 1\n    \n    total_time = 0\n    for s, e in zip(S, E):\n        if s <= e:\n            total_time += min(e - s, abs(time[e - 1] - time[s - 1]))\n        else:\n            total_time += min(s - e, abs(time[s - 1] - time[e - 1])) + 1\n    \n    return total_time\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        K = int(data[index])\n        Q = int(data[index + 1])\n        P = data[index + 2]\n        L = [int(x) for x in data[index + 3:index + 3 + K]]\n        R = [int(x) for x in data[index + 3 + K:index + 3 + 2 * K]]\n        Pi = [int(x) for x in data[index + 3 + 2 * K:index + 3 + 3 * K]]\n        S = [int(x) - 1 for x in data[index + 3 + 3 * K:index + 3 + 3 * K + Q]]\n        E = [int(x) - 1 for x in data[index + 3 + 3 * K + Q:index + 3 + 4 * K + Q]]\n        \n        index += 4 * K + Q\n        \n        result = calculate_time(K, P, L, R, Pi, S, E)\n        results.append(result)\n    \n    for i, res in enumerate(results):\n        print(f\"Case #{i + 1}: {res}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:58:16.915155",
    "generation_time": 7.410748720169067,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\round_2\\incremental_house_of_pancakes",
    "problem_name": "Incremental House of Pancakes",
    "python_code": "def solve_pancakes(L, R):\n    n = 0\n    while L >= n + 1 or R >= n + 1:\n        if L >= R:\n            L -= (n + 1)\n        else:\n            R -= (n + 1)\n        n += 1\n    return n, L, R\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        L = int(data[index])\n        R = int(data[index + 1])\n        index += 2\n        \n        n, l, r = solve_pancakes(L, R)\n        results.append(f\"Case #{_ + 1}: {n} {l} {r}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:58:20.881887",
    "generation_time": 3.9286162853240967,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\round_2\\security_update",
    "problem_name": "Security Update",
    "python_code": "from collections import defaultdict, deque\n\ndef find_latencies(T, test_cases):\n    results = []\n    \n    for case_num, (C, D, Xs, connections) in enumerate(test_cases, start=1):\n        # Initialize adjacency list and latency dictionary\n        adj_list = defaultdict(list)\n        latencies = {i: None for i in range(2, C+1)}\n        \n        # Build the adjacency list\n        for u, v in connections:\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n        \n        # Initialize queue with source computer and its latency\n        queue = deque([(1, 0)])\n        visited = {1}\n        \n        while queue:\n            current, time = queue.popleft()\n            \n            for neighbor in adj_list[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    latencies[neighbor] = time + abs(Xs[neighbor-2])\n                    queue.append((neighbor, time + abs(Xs[neighbor-2])))\n        \n        # Sort the connections by their order of appearance\n        sorted_connections = sorted(connections, key=lambda x: (x[0], x[1]))\n        \n        # Assign latencies to each connection\n        for u, v in sorted_connections:\n            if latencies[u] > latencies[v]:\n                latencies[u], latencies[v] = latencies[v], latencies[u]\n            \n            result = abs(latencies[u] - latencies[v])\n            results.append(result)\n    \n    return results\n\n# Read input\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    C, D = map(int, input().split())\n    Xs = list(map(int, input().split()))\n    connections = [tuple(map(int, input().split())) for _ in range(D)]\n    test_cases.append((C, D, Xs, connections))\n\n# Find and print results\nresults = find_latencies(T, test_cases)\nfor i, result in enumerate(results):\n    print(f\"Case #{i+1}: {result}\")",
    "generated_at": "2025-05-03T16:58:27.741839",
    "generation_time": 6.852712392807007,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\round_2\\wormhole_in_one",
    "problem_name": "Wormhole in One",
    "python_code": "def max_distinct_holes(N, holes):\n    from itertools import combinations\n\n    def is_reachable(hole1, hole2):\n        return abs(hole1[0] - hole2[0]) + abs(hole1[1] - hole2[1])\n\n    def dfs(start, visited, path):\n        if start in visited:\n            return len(visited)\n        visited.add(start)\n        max_holes = 1\n        for hole in holes:\n            if hole not in visited and is_reachable(start, hole) == 0:\n                max_holes = max(max_holes, dfs(hole, visited.copy(), path + [hole]))\n        return max_holes\n\n    max_touches = 1\n    for start in range(N):\n        visited = set()\n        max_touches = max(max_touches, dfs(start, visited, [holes[start]]))\n\n    for wormholes in combinations(holes, 2):\n        visited = set(wormholes)\n        hole1, hole2 = wormholes\n        max_holes = dfs(hole1, visited, [hole1])\n        max_holes = max(max_holes, dfs(hole2, visited, [hole2]))\n        max_touches = max(max_touches, max_holes)\n\n    return max_touches\n\nT = int(input())\nresults = []\nfor i in range(T):\n    N = int(input())\n    holes = [tuple(map(int, input().split())) for _ in range(N)]\n    results.append(max_distinct_holes(N, holes))\n\nfor i, result in enumerate(results):\n    print(f\"Case #{i+1}: {result}\")",
    "generated_at": "2025-05-03T16:58:33.495138",
    "generation_time": 5.740542888641357,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\round_3\\naming_compromise",
    "problem_name": "Naming Compromise",
    "python_code": "def min_edit_distance(s1, s2):\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n    \n    return dp[m][n]\n\ndef find_compromise_name(C, J):\n    m, n = len(C), len(J)\n    min_sum_edit_distance = float('inf')\n    best_name = \"\"\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            name = C[:i] + J[j:]\n            sum_edit_distance = min_edit_distance(C, name) + min_edit_distance(J, name)\n            if sum_edit_distance < min_sum_edit_distance:\n                min_sum_edit_distance = sum_edit_distance\n                best_name = name\n    \n    return best_name\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(T):\n        C = data[index]\n        J = data[index + 1]\n        index += 2\n        \n        compromise_name = find_compromise_name(C, J)\n        results.append(f\"Case #{_+1}: {compromise_name}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:58:40.418515",
    "generation_time": 6.914623022079468,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\round_3\\pen_testing",
    "problem_name": "Pen Testing",
    "python_code": "import sys\n\ndef readline_int_list():\n    return list(map(int, input().split()))\n\nt, n, c = readline_int_list()\n\nfor _ in range(t):\n    print(0)\n    sys.stdout.flush()\n    a1 = readline_int_list()[0]\n    \n    if a1 == 0:\n        continue\n    \n    print(n)\n    sys.stdout.flush()\n    a2 = readline_int_list()[0]\n    \n    if a2 == 0:\n        continue\n    \n    print((a1 + 1) % n, (a2 + 1) % n)\n    sys.stdout.flush()\n\nprint(*([0] * t))\nsys.stdout.flush()\n\npens = []\nfor _ in range(t):\n    p1, p2 = readline_int_list()\n    pens.append((p1, p2))\n\nsucceeded = sum(1 for p1, p2 in pens if p1 != 0 and p2 != 0)\nprint(succeeded >= c)\n\nsys.exit()",
    "generated_at": "2025-05-03T16:58:45.057272",
    "generation_time": 4.623489856719971,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\round_3\\recalculating",
    "problem_name": "Recalculating",
    "python_code": "from fractions import Fraction\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return abs(a * b) // gcd(a, b)\n\ndef solve(N, D, repair_centers):\n    total_area = 0\n    distinguishable_area = 0\n    \n    for i in range(N):\n        x1, y1 = repair_centers[i]\n        for j in range(i + 1, N):\n            x2, y2 = repair_centers[j]\n            dx = abs(x1 - x2)\n            dy = abs(y1 - y2)\n            if dx + dy <= D:\n                area = (D - dx) * (D - dy)\n                total_area += area\n                distinguishable_area += area\n    \n    for i in range(N):\n        x1, y1 = repair_centers[i]\n        for dx in range(-D, D + 1):\n            for dy in range(-D, D + 1):\n                if abs(dx) + abs(dy) > D:\n                    continue\n                found = False\n                for j in range(N):\n                    if i != j and abs(x1 - repair_centers[j][0] - dx) + abs(y1 - repair_centers[j][1] - dy) <= D:\n                        found = True\n                        break\n                if not found:\n                    distinguishable_area += 1\n    \n    return Fraction(distinguishable_area, total_area)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        D = int(data[index + 1])\n        repair_centers = []\n        index += 2\n        \n        for _ in range(N):\n            x = int(data[index])\n            y = int(data[index + 1])\n            repair_centers.append((x, y))\n            index += 2\n        \n        result = solve(N, D, repair_centers)\n        results.append(result)\n    \n    for i, result in enumerate(results, start=1):\n        print(f\"Case #{i}: {result.numerator} {result.denominator}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:58:53.879017",
    "generation_time": 8.80774998664856,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\round_3\\thermometers",
    "problem_name": "Thermometers",
    "python_code": "def min_thermometers(K, N, X, T):\n    # Initialize the number of thermometers to 1 (minimum possible)\n    num_thermometers = 1\n    \n    # If there's only one temperature measurement, no need for additional thermometers\n    if N == 1:\n        return num_thermometers\n    \n    # Iterate through each pair of temperature measurements\n    for i in range(N):\n        # Check if the current thermometer can cover the next segment\n        if X[i + 1] - X[i] > K / num_thermometers:\n            # If not, increment the number of thermometers\n            num_thermometers += 1\n    \n    return num_thermometers\n\n# Read input\nT = int(input())\nresults = []\n\nfor t in range(1, T + 1):\n    K, N = map(int, input().split())\n    X = list(map(float, input().split()))\n    T = list(map(int, input().split()))\n    \n    # Calculate the minimum number of thermometers for the current test case\n    min_temp_thermometers = min_thermometers(K, N, X, T)\n    \n    # Store the result\n    results.append(f\"Case #{t}: {min_temp_thermometers}\")\n\n# Print all results\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T16:58:58.722450",
    "generation_time": 4.807682514190674,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\virtual_world_finals\\adjacent_and_consecutive",
    "problem_name": "Adjacent and Consecutive",
    "python_code": "def count_mistakes(N, moves):\n    def can_win(board, player):\n        for i in range(len(board) - 1):\n            if abs(board[i] - board[i + 1]) == 1:\n                return True\n        return False\n\n    def is_winning_state(board, player):\n        temp_board = board[:]\n        for i in range(N):\n            if temp_board[i] == 0:\n                for j in range(1, N + 1):\n                    if j not in temp_board:\n                        temp_board[i] = j\n                        if player == 'A':\n                            if can_win(temp_board, 'B'):\n                                return True\n                        else:\n                            if can_win(temp_board, 'A'):\n                                return False\n                        temp_board[i] = 0\n        return player == 'A'\n\n    def is_mistake(board, move, player):\n        board[move - 1] = moves.pop(0)\n        if not is_winning_state(board[:], player):\n            board[move - 1] = 0\n            return False\n        return True\n\n    results = []\n    for _ in range(N):\n        N = int(input().strip())\n        moves = [int(x) for x in input().strip().split()]\n        board = [0] * N\n        player_A_mistakes = 0\n        player_B_mistakes = 0\n\n        for i in range(N):\n            if i % 2 == 0:\n                move = moves.pop(0)\n                if is_mistake(board[:], move, 'A'):\n                    player_A_mistakes += 1\n            else:\n                move = moves.pop(0)\n                if is_mistake(board[:], move, 'B'):\n                    player_B_mistakes += 1\n\n        results.append((player_A_mistakes, player_B_mistakes))\n\n    for i, (a, b) in enumerate(results):\n        print(f\"Case #{i + 1}: {a} {b}\")",
    "generated_at": "2025-05-03T16:59:05.495297",
    "generation_time": 6.765157461166382,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\virtual_world_finals\\hexacoin_jam",
    "problem_name": "Hexacoin Jam",
    "python_code": "from fractions import Fraction\n\ndef to_int(s):\n    return int(s, 16)\n\ndef from_int(n, d):\n    return format(n % (16**d), f'0{d}X')\n\ndef count_hexacoins(N, D, S, E, L):\n    s = to_int(S)\n    e = to_int(E)\n    cnt_total = 0\n    cnt_valid = 0\n    \n    for i in range(N):\n        for j in range(i + 1, N):\n            a = to_int(L[i])\n            b = to_int(L[j])\n            if s <= (a + b) % (16**D) <= e:\n                cnt_valid += 1\n            cnt_total += 1\n    \n    return Fraction(cnt_valid, cnt_total)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        D = int(data[index + 1])\n        S = data[index + 2]\n        E = data[index + 3]\n        L = data[index + 4:index + 4 + N]\n        \n        result = count_hexacoins(N, D, S, E, L)\n        results.append(f\"Case #{_+1}: {result.numerator} {result.denominator}\")\n        \n        index += 4 + N\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:59:11.193195",
    "generation_time": 5.682113409042358,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\virtual_world_finals\\musical_cords",
    "problem_name": "Musical Cords",
    "python_code": "import math\n\ndef calculate_distance(d1, d2, r):\n    angle = abs(d1 - d2) % 360\n    chord_length = 2 * r * math.sin(math.radians(angle / 2))\n    return chord_length + r * 2\n\ndef find_k_longest_cords(N, R, K, points):\n    distances = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            distance = calculate_distance(points[i][0], points[j][0], R) + points[i][1] + points[j][1]\n            distances.append(distance)\n    \n    distances.sort(reverse=True)\n    return distances[:K]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for t in range(T):\n        N = int(data[index])\n        R = float(data[index + 1])\n        K = int(data[index + 2])\n        points = []\n        \n        index += 3\n        for _ in range(N):\n            d = float(data[index])\n            l = float(data[index + 1])\n            points.append((d, l))\n            index += 2\n        \n        result = find_k_longest_cords(N, R, K, points)\n        results.append(f\"Case #{t+1}: {' '.join(map(str, result))}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:59:16.929351",
    "generation_time": 5.715002059936523,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\virtual_world_finals\\pack_the_slopes",
    "problem_name": "Pack the Slopes",
    "python_code": "import sys\n\ndef max_skiers_and_min_expense(N, slopes):\n    from collections import defaultdict, deque\n    \n    graph = defaultdict(list)\n    capacity = [0] * (N + 1)\n    cost = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    \n    for u, v, s, c in slopes:\n        graph[u].append(v)\n        graph[v].append(u)\n        capacity[u][v] = s\n        capacity[v][u] = s\n        cost[u][v] = c\n        cost[v][u] = -c\n    \n    def bfs():\n        parent = [-1] * (N + 1)\n        distance = [float('inf')] * (N + 1)\n        distance[1] = 0\n        \n        queue = deque([1])\n        \n        while queue:\n            u = queue.popleft()\n            \n            for v in graph[u]:\n                if distance[v] == float('inf') and capacity[u][v] > 0:\n                    parent[v] = u\n                    distance[v] = distance[u] + cost[u][v]\n                    queue.append(v)\n        \n        return parent, distance\n    \n    max_skiers = 0\n    min_expense = 0\n    \n    while True:\n        parent, distance = bfs()\n        if parent[N] == -1:\n            break\n        \n        path_flow = float('inf')\n        s = N\n        \n        while s != 1:\n            path_flow = min(path_flow, capacity[parent[s]][s])\n            s = parent[s]\n        \n        max_skiers += path_flow\n        min_expense += path_flow * distance[N]\n        \n        v = N\n        while v != 1:\n            u = parent[v]\n            capacity[u][v] -= path_flow\n            capacity[v][u] += path_flow\n            v = parent[v]\n    \n    return max_skiers, min_expense\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        \n        slopes = []\n        \n        for _ in range(N - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            s = int(data[index + 2])\n            c = int(data[index + 3])\n            index += 4\n            slopes.append((u, v, s, c))\n        \n        max_skiers, min_expense = max_skiers_and_min_expense(N, slopes)\n        results.append(f\"Case #{_ + 1}: {max_skiers} {min_expense}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:59:26.475944",
    "generation_time": 9.531328916549683,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2020\\virtual_world_finals\\replace_all",
    "problem_name": "Replace All",
    "python_code": "def max_unique_characters(test_cases):\n    results = []\n    for i, (text, n, replacements) in enumerate(test_cases, start=1):\n        unique_chars = set(text)\n        for a, b in replacements:\n            if a in text or b in text:\n                unique_chars |= {c for c in text if c == a or c == b}\n        results.append(f\"Case #{i}: {len(unique_chars)}\")\n    return results\n\n# Example usage\ntest_cases = [\n    (\"CODEJAMWORLDFINALS\", 2, [('A', 'O'), ('O', 'Y')]),\n    (\"1234567890\", 1, [('1', 'A')]),\n    (\"ABCD\", 2, [('A', 'B'), ('C', 'D')]),\n    (\"Xx\", 2, [('X', 'a'), ('x', 'b')])\n]\n\nresults = max_unique_characters(test_cases)\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T16:59:30.171644",
    "generation_time": 3.6859946250915527,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\qualification_round\\cheating_detection",
    "problem_name": "Cheating Detection",
    "python_code": "import random\nimport math\n\ndef sigmoid(x):\n    return 1 / (1 + math.exp(-x))\n\ndef simulate_tournament(num_players, num_questions, skill_levels, question_difficulties, cheater=None):\n    results = []\n    for i in range(num_players):\n        player_correct = [0] * num_questions\n        for j in range(num_questions):\n            if cheater is not None and i == cheater:\n                flip = random.choice([True, False])\n                if flip:\n                    player_correct[j] = 1\n                else:\n                    player_correct[j] = 1 if random.random() > sigmoid(skill_levels[i] - question_difficulties[j]) else 0\n            else:\n                player_correct[j] = 1 if random.random() > sigmoid(skill_levels[i] - question_difficulties[j]) else 0\n        results.append(player_correct)\n    return results\n\ndef identify_cheater(results, num_players):\n    for i in range(num_players):\n        player_results = [sum(row[i] for row in results) / len(results)]\n        if player_results[0] == 1.0:\n            return i + 1\n    return None\n\ndef main():\n    T = int(input())\n    P = int(input())\n    for t in range(1, T + 1):\n        num_players = 100\n        num_questions = 10000\n        skill_levels = [random.uniform(-3.00, 3.00) for _ in range(num_players)]\n        question_difficulties = [random.uniform(-3.00, 3.00) for _ in range(num_questions)]\n        cheater = random.randint(0, num_players - 1)\n        results = simulate_tournament(num_players, num_questions, skill_levels, question_difficulties, cheater)\n        cheater_id = identify_cheater(results, num_players)\n        print(f\"Case #{t}: {cheater_id}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:59:36.785561",
    "generation_time": 6.5946080684661865,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\qualification_round\\median_sort",
    "problem_name": "Median Sort",
    "python_code": "def find_median_order(T, N, Q):\n    for _ in range(T):\n        elements = list(range(1, N + 1))\n        while len(elements) > 1:\n            if len(elements) == 3:\n                i, j, k = elements\n                l = int(input(f\"{i} {j} {k}\\n\"))\n                if l not in [i, j, k]:\n                    return -1\n                elements.remove(l)\n            else:\n                mid = len(elements) // 2\n                i, j, k = elements[mid - 1], elements[mid], elements[mid + 1]\n                l = int(input(f\"{i} {j} {k}\\n\"))\n                if l not in [i, j, k]:\n                    return -1\n                elements.remove(l)\n        print(elements[0])\n\n# Read input\nT, N, Q = map(int, input().split())\nfind_median_order(T, N, Q)",
    "generated_at": "2025-05-03T16:59:40.352349",
    "generation_time": 3.557138442993164,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\qualification_round\\moons_and_umbrellas",
    "problem_name": "Moons and Umbrellas",
    "python_code": "def min_copyright_cost(X, Y, S):\n    n = len(S)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if S[i] == 'C' and S[j] == 'J':\n                dp[i][j] = min(X + dp[i+1][j], Y + dp[i][j-1])\n            elif S[i] == 'J' and S[j] == 'C':\n                dp[i][j] = min(Y + dp[i+1][j], X + dp[i][j-1])\n            else:\n                dp[i][j] = dp[i+1][j]\n    \n    return dp[0][-1]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        X = int(data[index])\n        Y = int(data[index + 1])\n        S = data[index + 2]\n        index += 3\n        \n        result = min_copyright_cost(X, Y, S)\n        results.append(f\"Case #{_+1}: {result}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:59:45.293474",
    "generation_time": 4.9255945682525635,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\qualification_round\\reversort",
    "problem_name": "Reversort",
    "python_code": "def calculate_reversort_cost(N, L):\n    total_cost = 0\n    for i in range(1, N):\n        min_index = L.index(min(L[i:])) + i\n        total_cost += (min_index - i) + 1\n        L = L[:i] + L[min_index:i-1:-1] + L[min_index+1:]\n    return total_cost\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        L = list(map(int, data[index + 1:index + N + 1]))\n        index += N + 1\n        cost = calculate_reversort_cost(N, L)\n        results.append(f\"Case #{_ + 1}: {cost}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T16:59:49.145562",
    "generation_time": 3.8170807361602783,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\qualification_round\\reversort_engineering",
    "problem_name": "Reversort Engineering",
    "python_code": "def reversort_engineering(N, C):\n    if N * (N - 1) // 2 < C or C % 2 != N % 2:\n        return \"IMPOSSIBLE\"\n    \n    if N == 1:\n        return \"1\"\n    \n    result = list(range(1, N + 1))\n    cost = 0\n    \n    for i in range(N - 1):\n        j = C - (N - i - 1)\n        result[:j] = reversed(result[:j])\n        cost += j\n        if cost == C:\n            break\n    \n    return \" \".join(map(str, result))\n\nT = int(input())\nresults = []\nfor t in range(1, T + 1):\n    N, C = map(int, input().split())\n    results.append(f\"Case #{t}: {reversort_engineering(N, C)}\")\n\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T16:59:52.766077",
    "generation_time": 3.612642765045166,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\round_1a\\append_sort",
    "problem_name": "Append Sort",
    "python_code": "def min_operations_to_sort(N, X):\n    operations = 0\n    for i in range(1, N):\n        if X[i] <= X[i - 1]:\n            diff = X[i - 1] - X[i] + 1\n            operations += diff\n            X[i] = X[i - 1] + 1\n    return operations\n\ndef solve():\n    T = int(input())\n    for t in range(1, T + 1):\n        N = int(input())\n        X = list(map(int, input().split()))\n        result = min_operations_to_sort(N, X)\n        print(f\"Case #{t}: {result}\")\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T16:59:55.343255",
    "generation_time": 2.5582516193389893,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\round_1a\\hacked_exam",
    "problem_name": "Hacked Exam",
    "python_code": "from fractions import Fraction\n\ndef max_expected_score(N, Q, answers):\n    from collections import Counter\n    \n    # Count the frequency of each answer for each question\n    count = [Counter() for _ in range(Q)]\n    for a, s in answers:\n        for i, c in enumerate(a):\n            count[i][c] += 1\n    \n    # Calculate the probability of each answer being correct\n    prob = []\n    for c in count:\n        total = sum(c.values())\n        prob.append(Fraction(sum(v * (i if i == 'T' else -i) for i, v in c.items()), total))\n    \n    # Determine the best sequence of answers\n    best_seq = ''.join('T' if p > 0 else 'F' for p in prob)\n    expected_score = sum(p * s for p, (_, s) in zip(prob, answers)) / len(answers)\n    \n    return best_seq, expected_score\n\ndef solve():\n    T = int(input())\n    results = []\n    for t in range(1, T + 1):\n        N, Q = map(int, input().split())\n        answers = [input().split() for _ in range(N)]\n        seq, score = max_expected_score(N, Q, answers)\n        results.append(f\"Case #{t}: {seq} {score.numerator}/{score.denominator}\")\n    return '\\n'.join(results)\n\nprint(solve())",
    "generated_at": "2025-05-03T17:00:00.169723",
    "generation_time": 4.813723564147949,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\round_1a\\prime_time",
    "problem_name": "Prime Time",
    "python_code": "from itertools import combinations\n\ndef max_score(primes, counts):\n    total_sum = sum(p * c for p, c in zip(primes, counts))\n    primes_counts = list(zip(primes, counts))\n\n    def product(lst):\n        return 1 if not lst else lst[0] * product(lst[1:])\n\n    def find_group(total, target_product, start=0):\n        for r in range(1, len(primes_counts) - start + 1):\n            for combo in combinations(primes_counts[start:], r):\n                if sum(p * c for p, c in combo) == total and product([p for p, _ in combo]) == target_product:\n                    return True\n        return False\n\n    max_score = 0\n    for i in range(1, len(primes_counts)):\n        for j in range(1, len(primes_counts) - i):\n            first_group_sum = sum(p * c for p, c in primes_counts[:i])\n            second_group_product = product([p for p, _ in primes_counts[i:i+j]])\n            if first_group_sum == second_group_product:\n                max_score = max(max_score, first_group_sum)\n            if find_group(total_sum - first_group_sum, second_group_product):\n                return total_sum\n\n    return max_score\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        M = int(data[index])\n        index += 1\n        primes = []\n        counts = []\n        for _ in range(M):\n            P = int(data[index])\n            N = int(data[index + 1])\n            primes.append(P)\n            counts.append(N)\n            index += 2\n        \n        result = max_score(primes, counts)\n        results.append(result)\n    \n    for i, result in enumerate(results, start=1):\n        print(f\"Case #{i}: {result}\")\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T17:00:06.970299",
    "generation_time": 6.7627112865448,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\round_1b\\broken_clock",
    "problem_name": "Broken Clock",
    "python_code": "def find_time(A, B, C):\n    for h in range(12):\n        for m in range(60):\n            for s in range(60):\n                n = 0\n                while True:\n                    ah = (h * 30 + m * 0.5 + s * 1/72) % 360\n                    bh = (h * 30 + m * 0.5 + s * 1/72) % 360\n                    ch = (h * 30 + m * 0.5 + s * 1/72) % 360\n                    if abs(ah - A) < 1e-9 and abs(bh - B) < 1e-9 and abs(ch - C) < 1e-9:\n                        return h, m, s, n\n                    n += 1\n\nT = int(input())\nresults = []\nfor i in range(1, T + 1):\n    A, B, C = map(int, input().split())\n    h, m, s, n = find_time(A, B, C)\n    results.append(f\"Case #{i}: {h} {m} {s} {n}\")\n\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T17:00:11.906578",
    "generation_time": 4.751809597015381,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\round_1b\\digit_blocks",
    "problem_name": "Digit Blocks",
    "python_code": "import sys\nfrom random import randint\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    N = int(data[index + 1])\n    B = int(data[index + 2])\n    P = int(data[index + 3])\n    index += 4\n    \n    total_score = 0\n    towers = [[] for _ in range(N)]\n    \n    for _ in range(T):\n        for _ in range(N * B):\n            D = int(data[index])\n            index += 1\n            \n            best_tower = -1\n            best_value = -1\n            \n            for i in range(N):\n                if len(towers[i]) == B:\n                    continue\n                \n                value = int(''.join(str(digit) for digit in towers[i][::-1]))\n                if value > best_value:\n                    best_value = value\n                    best_tower = i\n            \n            if best_tower == -1:\n                print(-1)\n                return\n            \n            towers[best_tower].append(D)\n        \n        current_score = sum(int(''.join(str(digit) for digit in tower[::-1])) for tower in towers)\n        total_score += current_score\n        \n        if total_score >= P:\n            print(1)\n        else:\n            print(-1)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:00:16.943372",
    "generation_time": 5.026183366775513,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\round_1b\\subtransmutation",
    "problem_name": "Subtransmutation",
    "python_code": "def find_smallest_metal(N, A, B, U):\n    if sum(U) == 0:\n        return \"IMPOSSIBLE\"\n    \n    for start in range(1, N + 1):\n        queue = [start]\n        created = set()\n        \n        while queue:\n            current = queue.pop(0)\n            if current not in created:\n                created.add(current)\n                if current >= A and current - A <= N:\n                    queue.append(current - A)\n                if current >= B and current - B <= N:\n                    queue.append(current - B)\n        \n        if len(created) == sum(U):\n            return start\n    \n    return \"IMPOSSIBLE\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        A = int(data[index + 1])\n        B = int(data[index + 2])\n        U = list(map(int, data[index + 3:index + 3 + N]))\n        \n        result = find_smallest_metal(N, A, B, U)\n        results.append(result)\n        \n        index += 3 + N\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i + 1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:00:22.065674",
    "generation_time": 5.11202073097229,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\round_1c\\closest_pick",
    "problem_name": "Closest Pick",
    "python_code": "from typing import List\n\ndef max_win_probability(N: int, K: int, P: List[int]) -> float:\n    P = sorted(P)\n    M = len(P)\n    \n    if M == 0:\n        return 1.0\n    \n    left, right = 0, K - 1\n    best_prob = 0.0\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        count_less = sum(1 for p in P if p < mid)\n        count_greater = sum(1 for p in P if p > mid)\n        \n        prob = max(count_less / M, count_greater / M)\n        \n        best_prob = max(best_prob, prob)\n        \n        if count_less == count_greater:\n            left = mid + 1\n        elif count_less < count_greater:\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return best_prob\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        P = list(map(int, data[index + 2:index + 2 + N]))\n        index += 2 + N\n        \n        result = max_win_probability(N, K, P)\n        results.append(f\"Case #{_+1}: {result:.6f}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:00:27.513084",
    "generation_time": 5.4323647022247314,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\round_1c\\double_or_noting",
    "problem_name": "Double or NOTing",
    "python_code": "def min_operations(S, E):\n    if S == E:\n        return 0\n\n    def transform(s):\n        if s[0] == '1':\n            return '0' + s[1:]\n        else:\n            return '1' + s[1:]\n\n    def double(s):\n        return s[:-1]\n\n    queue = [(S, 0)]\n    visited = set()\n    \n    while queue:\n        current, steps = queue.pop(0)\n        \n        if current == E:\n            return steps\n        \n        if current in visited:\n            continue\n        visited.add(current)\n        \n        # Apply NOT operation\n        not_op = transform(current)\n        if not_op not in visited:\n            queue.append((not_op, steps + 1))\n        \n        # Apply double operation\n        if len(current) > 1 and current[-1] == '0':\n            double_op = double(current)\n            if double_op not in visited:\n                queue.append((double_op, steps + 1))\n\n    return \"IMPOSSIBLE\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    T = int(data[0])\n    results = []\n    \n    for i in range(1, T + 1):\n        S, E = data[i].split()\n        result = min_operations(S, E)\n        results.append(f\"Case #{i}: {result}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:00:32.657868",
    "generation_time": 5.1315624713897705,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\round_1c\\roaring_years",
    "problem_name": "Roaring Years",
    "python_code": "def find_next_roaring_year(y):\n    while True:\n        y += 1\n        str_y = str(y)\n        length = len(str_y)\n        for i in range(1, length):\n            if int(str_y[:i]) + 1 == int(str_y[i:i+1]):\n                continue\n            else:\n                break\n        else:\n            return y\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    results = []\n    \n    for i in range(1, T + 1):\n        Y = int(data[i])\n        next_roaring_year = find_next_roaring_year(Y)\n        results.append(f\"Case #{i}: {next_roaring_year}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:00:35.659448",
    "generation_time": 2.978548049926758,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\round_2\\hidden_pancakes",
    "problem_name": "Hidden Pancakes",
    "python_code": "from math import factorial\n\nMOD = 10**9 + 7\n\ndef count_orders(N, V):\n    dp = [[0] * (N + 1) for _ in range(1 << N)]\n    dp[0][0] = 1\n    \n    for mask in range(1 << N):\n        for i in range(N):\n            if mask & (1 << i):\n                prev_mask = mask ^ (1 << i)\n                for j in range(i + 1):\n                    if V[j] > V[i]:\n                        dp[mask][i] += dp[prev_mask][j]\n                        dp[mask][i] %= MOD\n    \n    result = sum(dp[(1 << N) - 1]) % MOD\n    return result\n\ndef solve():\n    T = int(input())\n    for t in range(1, T + 1):\n        N = int(input())\n        V = list(map(int, input().split()))\n        \n        result = count_orders(N, V)\n        \n        print(f\"Case #{t}: {result}\")\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T17:00:39.531394",
    "generation_time": 3.8466858863830566,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\round_2\\matrygons",
    "problem_name": "Matrygons",
    "python_code": "def max_polygons(N):\n    if N < 3:\n        return 1\n    sides = [i for i in range(3, N + 1) if N % i == 0]\n    return len(sides)\n\nT = int(input())\nfor t in range(1, T + 1):\n    N = int(input())\n    print(f\"Case #{t}: {max_polygons(N)}\")",
    "generated_at": "2025-05-03T17:00:41.725399",
    "generation_time": 1.5723121166229248,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\round_2\\minimum_sort",
    "problem_name": "Minimum Sort",
    "python_code": "import sys\n\ndef query_min(i, j):\n    print(f\"Q {i} {j}\")\n    sys.stdout.flush()\n    response = input().strip()\n    if not response.isdigit():\n        return -1\n    return int(response)\n\ndef swap(i, j):\n    print(f\"S {i} {j}\")\n    sys.stdout.flush()\n\ndef sort_list(N):\n    for i in range(N-1):\n        min_pos = i\n        for j in range(i+1, N):\n            pos = query_min(i, j)\n            if pos == -1:\n                return -1\n            if pos < min_pos:\n                min_pos = pos\n        if min_pos != i:\n            swap(min_pos, i)\n\ndef main():\n    T, N = map(int, input().strip().split())\n    for _ in range(T):\n        if sort_list(N) == -1:\n            return -1\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:00:45.678802",
    "generation_time": 3.4371821880340576,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\round_2\\retiling",
    "problem_name": "Retiling",
    "python_code": "def min_cost_to_retile(R, C, F, S, current_state, target_state):\n    diff = 0\n    for i in range(R):\n        for j in range(C):\n            if current_state[i][j] != target_state[i][j]:\n                diff += 1\n    flips_needed = (diff + 1) // 2\n    swaps_needed = max(0, diff - flips_needed * 2)\n    return F * flips_needed + S * swaps_needed\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        R = int(data[index])\n        C = int(data[index + 1])\n        F = int(data[index + 2])\n        S = int(data[index + 3])\n        index += 4\n        \n        current_state = []\n        target_state = []\n        for i in range(R):\n            current_state.append(data[index])\n            index += 1\n        for i in range(R):\n            target_state.append(data[index])\n            index += 1\n        \n        result = min_cost_to_retile(R, C, F, S, current_state, target_state)\n        results.append(result)\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i + 1}: {result}\")\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T17:00:50.980871",
    "generation_time": 5.015727996826172,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\round_3\\binary_search_game",
    "problem_name": "Binary Search Game",
    "python_code": "MOD = 10**9 + 7\n\ndef binary_search_game(N, M, L, A):\n    from functools import lru_cache\n    \n    @lru_cache(None)\n    def dp(left, right, turn):\n        if left == right:\n            return A[left]\n        \n        mid = (left + right) // 2\n        if turn % 2 == 0:  # Alice's turn\n            return max(dp(left, mid, turn + 1), dp(mid + 1, right, turn + 1))\n        else:  # Bob's turn\n            return min(dp(left, mid, turn + 1), dp(mid + 1, right, turn + 1))\n    \n    total_score = 0\n    for cards in product(range(1, M+1), repeat=N):\n        score = dp(0, len(A) - 1, 0)\n        total_score += cards[score-1]\n    \n    return total_score % MOD\n\nfrom itertools import product\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(T):\n    N = int(data[index])\n    M = int(data[index + 1])\n    L = int(data[index + 2])\n    A = list(map(int, data[index + 3:index + 3 + (1 << L)]))\n    index += 3 + (1 << L)\n    \n    result = binary_search_game(N, M, L, A)\n    results.append(result)\n\nfor i, result in enumerate(results):\n    print(f\"Case #{i+1}: {result}\")",
    "generated_at": "2025-05-03T17:00:57.633168",
    "generation_time": 5.786693811416626,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\round_3\\build-a-pair",
    "problem_name": "Build-A-Pair",
    "python_code": "from itertools import permutations\n\ndef min_abs_difference(digits):\n    digits = list(map(int, digits))\n    n = len(digits)\n    \n    def is_valid(num):\n        return num > 0 and '0' not in str(num)\n    \n    min_diff = float('inf')\n    \n    for perm in permutations(digits):\n        first_num = int(''.join(map(str, perm[:n//2])))\n        second_num = int(''.join(map(str, perm[n//2:])))\n        \n        if is_valid(first_num) and is_valid(second_num):\n            diff = abs(first_num - second_num)\n            min_diff = min(min_diff, diff)\n    \n    return min_diff\n\ndef solve():\n    T = int(input())\n    results = []\n    \n    for i in range(1, T + 1):\n        digits = input().strip()\n        result = min_abs_difference(digits)\n        results.append(f\"Case #{i}: {result}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T17:01:01.219278",
    "generation_time": 3.449723958969116,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\round_3\\fence_design",
    "problem_name": "Fence Design",
    "python_code": "def find_max_fences(poles, existing_fences):\n    n = len(poles)\n    edges = []\n    \n    # Add all possible fences between non-collinear poles\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (poles[j][1] - poles[i][1]) * (poles[j][0] - existing_fences[0][0]) != \\\n               (poles[j][1] - existing_fences[0][1]) * (poles[j][0] - poles[i][0]):\n                edges.append((i, j))\n    \n    # Remove fences that intersect with existing fences\n    valid_edges = []\n    for edge in edges:\n        i, j = edge\n        if not any((poles[i][1] - poles[j][1]) * (existing_fences[k][1] - poles[i][1]) == \\\n                   (existing_fences[k][1] - poles[j][1]) * (existing_fences[k][0] - poles[i][0]) and\n                   (poles[j][0] - poles[i][0]) * (existing_fences[k][0] - poles[i][0]) > 0 for k in range(2)):\n            valid_edges.append(edge)\n    \n    # Find the maximum number of non-intersecting fences\n    max_fences = []\n    visited = set()\n    for i, j in valid_edges:\n        if i not in visited and j not in visited:\n            max_fences.append((i, j))\n            visited.add(i)\n            visited.add(j)\n    \n    return len(max_fences), max_fences\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for t in range(1, T + 1):\n        N = int(data[index])\n        index += 1\n        \n        poles = []\n        for _ in range(N):\n            x = int(data[index])\n            y = int(data[index + 1])\n            index += 2\n            poles.append((x, y))\n        \n        existing_fences = [(int(data[index]), int(data[index + 1])), (int(data[index + 2]), int(data[index + 3]))]\n        index += 4\n        \n        max_fences_count, max_fences = find_max_fences(poles, existing_fences)\n        \n        results.append(f\"Case #{t}: {max_fences_count}\")\n        for i, j in max_fences:\n            results.append(f\"{i} {j}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:01:10.460460",
    "generation_time": 8.901872634887695,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\round_3\\square_free",
    "problem_name": "Square Free",
    "python_code": "def is_square_free(matrix):\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if (i + 1 < len(matrix) and j + 1 < len(matrix[0]) and \n                matrix[i][j] == '/' and matrix[i+1][j+1] == '/' and \n                matrix[i][j+1] == '\\\\' and matrix[i+1][j] == '\\\\'):\n                return False\n    return True\n\ndef solve(R, C, S, D):\n    if sum(S) != sum(D):\n        return \"IMPOSSIBLE\"\n    \n    from itertools import product\n    \n    for diagonals in product(['/', '\\\\'], repeat=R*C):\n        matrix = [list(diagonals[i*C:(i+1)*C]) for i in range(R)]\n        if is_square_free(matrix) and sum(row.count('/') for row in matrix) == sum(S) and sum(col.count('/') for col in zip(*matrix)) == sum(D):\n            return \"POSSIBLE\\n\" + '\\n'.join(''.join(row) for row in matrix)\n    \n    return \"IMPOSSIBLE\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        R, C = map(int, data[index:index+2])\n        S = list(map(int, data[index+2:index+2+R]))\n        D = list(map(int, data[index+2+R:index+2+R+C]))\n        index += 2 + R + C\n        \n        result = solve(R, C, S, D)\n        results.append(result)\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i+1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:01:16.885546",
    "generation_time": 6.41196870803833,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\world_finals\\cutting_cake",
    "problem_name": "Cutting Cake",
    "python_code": "from fractions import Fraction\n\ndef calculate_enjoyment(A, B, P, Q, R, S):\n    return A * (P + R) / 2 + B * (Q + S) / 2\n\ndef min_difference(N, W, H, P, Q, R, S, patches):\n    total_enjoyment = [0, 0]\n    for X_i, Y_i, A_i, B_i in patches:\n        area = calculate_enjoyment(A_i, B_i, P, Q, R, S)\n        x1, y1 = X_i, Y_i\n        x2, y2 = X_i + P, Y_i + Q\n        x3, y3 = X_i + R, Y_i + S\n        if x2 <= W:\n            total_enjoyment[0] += area * (W - x2) / (x3 - x1)\n            total_enjoyment[1] += area * (x2 - x1) / (x3 - x1)\n    min_diff = float('inf')\n    for i in range(W + 1):\n        diff = abs(total_enjoyment[0] - sum(total_enjoyment[1:] - Fraction(i, W) * area for _, _, A_i, B_i, area in patches))\n        if diff < min_diff:\n            min_diff = diff\n    return Fraction(min_diff).limit_denominator()\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        W = int(data[index + 1])\n        H = int(data[index + 2])\n        P = int(data[index + 3])\n        Q = int(data[index + 4])\n        R = int(data[index + 5])\n        S = int(data[index + 6])\n        index += 7\n        \n        patches = []\n        for _ in range(N):\n            X_i = int(data[index])\n            Y_i = int(data[index + 1])\n            A_i = int(data[index + 2])\n            B_i = int(data[index + 3])\n            area = calculate_enjoyment(A_i, B_i, P, Q, R, S)\n            patches.append((X_i, Y_i, A_i, B_i, area))\n            index += 4\n        \n        result = min_difference(N, W, H, P, Q, R, S, patches)\n        results.append(result)\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i + 1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:01:26.371879",
    "generation_time": 9.472366094589233,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\world_finals\\divisible_divisions",
    "problem_name": "Divisible Divisions",
    "python_code": "MOD = 10**9 + 7\n\ndef count_divisible_divisions(S, D):\n    n = len(S)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            if int(S[j:i]) % D == 0:\n                dp[i] += dp[j]\n                dp[i] %= MOD\n                \n    return dp[n]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(T):\n        S = data[index]\n        D = int(data[index + 1])\n        index += 2\n        \n        result = count_divisible_divisions(S, D)\n        results.append(f\"Case #{_+1}: {result}\")\n        \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:01:30.063368",
    "generation_time": 3.6791133880615234,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\world_finals\\infinitree",
    "problem_name": "Infinitree",
    "python_code": "def find_distance(N, A, B, L, R):\n    def get_parent(index):\n        return (index - 1) // 2 + 1\n\n    def get_children(parent):\n        left = parent * 2 - 1\n        right = parent * 2\n        if left > N:\n            left = None\n        if right > N:\n            right = None\n        return left, right\n\n    while A != B:\n        if A < B:\n            A = get_parent(A)\n        else:\n            B = get_parent(B)\n\n    return abs(A - B) + 1\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    T = int(data[0])\n    index = 1\n    results = []\n\n    for _ in range(T):\n        N = int(data[index])\n        A = int(data[index + 1]) - 1\n        B = int(data[index + 2]) - 1\n        L = list(map(int, data[index + 3:index + 3 + N]))\n        R = list(map(int, data[index + 3 + N:index + 6 + N]))\n\n        index += 6 + N\n\n        result = find_distance(N, A, B, L, R)\n        results.append(f\"Case #{_ + 1}: {result}\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:01:35.164835",
    "generation_time": 4.995851278305054,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\world_finals\\ropes",
    "problem_name": "Ropes",
    "python_code": "import sys\n\ndef read_int():\n    return int(sys.stdin.readline())\n\nT = read_int()\nN = read_int()\nW = read_int()\n\nfor _ in range(T):\n    for i in range(N):\n        A_i = read_int()\n        B_i = read_int()\n        print(f\"{A_i} {B_i}\")\n        C_i = read_int()\n        D_i = read_int()\n    \n    result = read_int()\n    if result == 0:\n        sys.exit(-1)",
    "generated_at": "2025-05-03T17:01:37.330920",
    "generation_time": 2.1321516036987305,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2021\\world_finals\\slide_circuits",
    "problem_name": "Slide Circuits",
    "python_code": "from collections import defaultdict\n\ndef find_circuits(slides):\n    n = len(slides)\n    visited = [False] * n\n    stack = []\n    \n    def dfs(node):\n        if not visited[node]:\n            visited[node] = True\n            for neighbor in slides[node]:\n                if not visited[neighbor]:\n                    dfs(neighbor)\n            stack.append(node)\n    \n    for i in range(n):\n        dfs(i)\n    \n    def get_transpose():\n        transpose = defaultdict(list)\n        for u, v in slides.items():\n            for w in v:\n                transpose[w].append(u)\n        return transpose\n    \n    def dfs_util(node, visited, component):\n        if not visited[node]:\n            visited[node] = True\n            component.append(node)\n            for neighbor in transpose[node]:\n                dfs_util(neighbor, visited, component)\n    \n    transpose = get_transpose()\n    components = []\n    visited = [False] * n\n    \n    while stack:\n        node = stack.pop()\n        if not visited[node]:\n            component = []\n            dfs_util(node, visited, component)\n            components.append(component)\n    \n    return components\n\ndef can_make_fun(slides, operations):\n    n = len(slides)\n    fun_states = [set() for _ in range(n)]\n    \n    for i in range(n):\n        if not slides[i]:\n            fun_states[i].add(i)\n    \n    for operation in operations:\n        a, l, r, m = operation\n        affected_slides = set(range(l - 1, r))\n        multiple_of_m = {x for x in affected_slides if (x + 1) % m == 0}\n        \n        if a == 'E':\n            for slide in multiple_of_m:\n                fun_states[slide] -= {i for i in slides[slide]}\n                fun_states[slide].add(slide)\n        else:\n            for slide in multiple_of_m:\n                fun_states[slide] -= {slide}\n                fun_states[slide] |= {i for i in slides[slide]}\n    \n    results = []\n    for state in fun_states:\n        if len(state) == 1:\n            results.append(next(iter(state)) + 1)\n        else:\n            results.append('X')\n    \n    return ' '.join(map(str, results))\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        b = int(data[index])\n        s = int(data[index + 1])\n        n = int(data[index + 2])\n        index += 3\n        \n        slides = defaultdict(list)\n        \n        for _ in range(s):\n            x = int(data[index]) - 1\n            y = int(data[index + 1]) - 1\n            slides[x].append(y)\n            slides[y].append(x)\n            index += 2\n        \n        operations = []\n        \n        for _ in range(n):\n            a = data[index]\n            l = int(data[index + 1])\n            r = int(data[index + 2])\n            m = int(data[index + 3])\n            index += 4\n            operations.append((a, l, r, m))\n        \n        result = can_make_fun(slides, operations)\n        results.append(result)\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i+1}: {result}\")\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T17:01:49.107014",
    "generation_time": 11.742453575134277,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\qualification_round\\3d_printing",
    "problem_name": "3D Printing",
    "python_code": "def find_color(C, M, Y, K):\n    for c in range(10**6 + 1):\n        for m in range(10**6 - c + 1):\n            for y in range(10**6 - c - m + 1):\n                k = 10**6 - c - m - y\n                if all(c <= Ci and m <= Mi and y <= Yi and k <= Ki for Ci, Mi, Yi, Ki in zip(C, M, Y, K)):\n                    return f\"{c} {m} {y} {k}\"\n    return \"IMPOSSIBLE\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        C = list(map(int, data[index:index+4]))\n        M = list(map(int, data[index+4:index+8]))\n        Y = list(map(int, data[index+8:index+12]))\n        K = list(map(int, data[index+12:index+16]))\n        \n        index += 16\n        result = find_color(C, M, Y, K)\n        results.append(result)\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i + 1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:01:54.152386",
    "generation_time": 5.03462290763855,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\qualification_round\\chain_reactions",
    "problem_name": "Chain Reactions",
    "python_code": "def max_fun(N, F, P):\n    from collections import defaultdict\n    \n    graph = defaultdict(list)\n    for i in range(1, N + 1):\n        if P[i - 1] != 0:\n            graph[P[i - 1]].append(i)\n    \n    def dfs(node):\n        visited.add(node)\n        fun = F[node - 1]\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                fun = max(fun, dfs(neighbor))\n        return fun\n    \n    initiators = [i for i in range(1, N + 1) if P[i - 1] == 0]\n    max_total_fun = 0\n    for initiator in sorted(initiators):\n        visited = set()\n        chain_reaction_fun = dfs(initiator)\n        max_total_fun += chain_reaction_fun\n    \n    return max_total_fun\n\ndef solve():\n    T = int(input())\n    results = []\n    for t in range(1, T + 1):\n        N = int(input())\n        F = list(map(int, input().split()))\n        P = list(map(int, input().split()))\n        result = max_fun(N, F, P)\n        results.append(f\"Case #{t}: {result}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T17:01:58.773779",
    "generation_time": 4.610790252685547,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\qualification_round\\d1000000",
    "problem_name": "d1000000",
    "python_code": "def longest_straight(dice):\n    sides = [0] * (max(dice) + 1)\n    for die in dice:\n        sides[die] += 1\n\n    max_length = 0\n    current_length = 0\n    for side in range(1, len(sides)):\n        if sides[side] > 0:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 0\n    return max(max_length, current_length)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    T = int(data[0])\n    index = 1\n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        dice = list(map(int, data[index + 1:index + N + 1]))\n        index += N + 1\n        result = longest_straight(dice)\n        results.append(f\"Case #{_ + 1}: {result}\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:02:02.675217",
    "generation_time": 3.856379270553589,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\qualification_round\\punched_cards",
    "problem_name": "Punched Cards",
    "python_code": "def print_punched_card(R, C):\n    top_border = '-' * (C * 4 - 1)\n    middle_row = '|.' + '.' * (C - 2) + '.|'\n    bottom_border = '+' + '-' * (C * 2 - 2) + '+'\n\n    print(top_border)\n    for _ in range(R):\n        print(middle_row)\n    print(bottom_border)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    T = int(data[0])\n    index = 1\n\n    results = []\n    for t in range(1, T + 1):\n        R = int(data[index])\n        C = int(data[index + 1])\n        index += 2\n        result = f\"Case #{t}:\\n\"\n        print_punched_card(R, C)\n        results.append(result)\n\n    sys.stdout.write('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:02:05.988298",
    "generation_time": 3.299132823944092,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\qualification_round\\twisty_little_passages",
    "problem_name": "Twisty Little Passages",
    "python_code": "import sys\nfrom random import randint\n\ndef estimate_passages(N, K):\n    passages = {}\n    for _ in range(K + 1):\n        R_i, P_i = map(int, input().split())\n        if R_i not in passages:\n            passages[R_i] = []\n        passages[R_i].append(P_i)\n    \n    total_passages = sum(passages.values()) // 2\n    estimate = randint(total_passages * 2 // 3, total_passages * 4 // 3)\n    print(estimate)\n\nT = int(input())\nfor _ in range(T):\n    N, K = map(int, input().split())\n    estimate_passages(N, K)",
    "generated_at": "2025-05-03T17:02:08.554022",
    "generation_time": 2.5549161434173584,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\round_1a\\double_or_one_thing",
    "problem_name": "Double or One Thing",
    "python_code": "def min_lexicographical_string(s):\n    n = len(s)\n    min_str = 'Z' * (2 * n + 1)\n    \n    def dfs(index, current, highlight_count):\n        nonlocal min_str\n        if index == n:\n            if len(current) < len(min_str):\n                min_str = current\n            elif len(current) == len(min_str) and current < min_str:\n                min_str = current\n            return\n        \n        # Option 1: Highlight the current character\n        dfs(index + 1, current + s[index] * 2, highlight_count + 1)\n        \n        # Option 2: Do not highlight the current character\n        dfs(index + 1, current + s[index], highlight_count)\n    \n    dfs(0, '', 0)\n    return min_str\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    results = []\n    \n    for i in range(T):\n        S = data[i + 1]\n        result = min_lexicographical_string(S)\n        results.append(f\"Case #{i + 1}: {result}\")\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:02:12.866031",
    "generation_time": 4.264276742935181,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\round_1a\\equal_sum",
    "problem_name": "Equal Sum",
    "python_code": "import sys\n\ndef read_int():\n    return int(sys.stdin.readline().strip())\n\nT = read_int()\n\nfor _ in range(T):\n    N = read_int()\n    A = [read_int() for _ in range(N)]\n    \n    B = [read_int() for _ in range(N)]\n    \n    # Choose the first N/2 elements from A and the rest from B\n    chosen = A[:N//2] + B[N:]\n    \n    print(len(chosen), *chosen)",
    "generated_at": "2025-05-03T17:02:14.878162",
    "generation_time": 2.0030033588409424,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\round_1a\\weightlifting",
    "problem_name": "Weightlifting",
    "python_code": "def min_operations(exercises, weights):\n    total_operations = 0\n    current_stack = [0] * (weights + 1)\n    \n    for exercise in exercises:\n        required_weights = exercise[:]\n        operations = 0\n        \n        for i in range(1, weights + 1):\n            if required_weights[i - 1] > current_stack[i]:\n                operations += (required_weights[i - 1] - current_stack[i])\n                current_stack[i] = required_weights[i - 1]\n        \n        total_operations += operations\n    \n    return total_operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        E = int(data[index])\n        W = int(data[index + 1])\n        index += 2\n        \n        exercises = []\n        \n        for _ in range(E):\n            exercise = [0] * (W + 1)\n            for j in range(W):\n                Xij = int(data[index])\n                exercise[j + 1] = Xij\n                index += 1\n            exercises.append(exercise)\n        \n        result = min_operations(exercises, W)\n        results.append(result)\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i + 1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:02:19.930509",
    "generation_time": 5.030198097229004,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\round_1b\\asedatab",
    "problem_name": "ASeDatAb",
    "python_code": "import sys\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        while True:\n            V = ''.join(format(i, '08b') for i in range(8))\n            print(V)\n            sys.stdout.flush()\n            N = int(input())\n            if N == 0:\n                break\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:02:21.873976",
    "generation_time": 1.9346566200256348,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\round_1b\\controlled_inflation",
    "problem_name": "Controlled Inflation",
    "python_code": "def min_button_presses(N, P, pressures):\n    current_pressure = 0\n    total_pressures = 0\n    \n    for pressure_list in pressures:\n        pressure_list.sort()\n        for i in range(len(pressure_list)):\n            if pressure_list[i] > current_pressure:\n                total_pressures += (pressure_list[i] - current_pressure)\n                current_pressure = pressure_list[i]\n            elif pressure_list[i] < current_pressure:\n                total_pressures += (current_pressure - pressure_list[i])\n                current_pressure = pressure_list[i]\n    \n    return total_pressures\n\nT = int(input())\nresults = []\n\nfor case in range(1, T + 1):\n    N, P = map(int, input().split())\n    pressures = [list(map(int, input().split())) for _ in range(N)]\n    result = min_button_presses(N, P, pressures)\n    results.append(f\"Case #{case}: {result}\")\n\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T17:02:25.340147",
    "generation_time": 3.4533441066741943,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\round_1b\\pancake_deque",
    "problem_name": "Pancake Deque",
    "python_code": "from collections import deque\n\ndef max_customers_paid(N, D):\n    left = deque(D)\n    right = deque(D[::-1])\n    result = 0\n    \n    while left:\n        if not right or (left and left[0] >= right[0]):\n            if left[0] >= result:\n                result += 1\n            left.popleft()\n        else:\n            if right[0] >= result:\n                result += 1\n            right.popleft()\n    \n    return result\n\nT = int(input())\nresults = []\n\nfor i in range(1, T + 1):\n    N = int(input())\n    D = list(map(int, input().split()))\n    results.append(max_customers_paid(N, D))\n\nfor i, result in enumerate(results, start=1):\n    print(f\"Case #{i}: {result}\")",
    "generated_at": "2025-05-03T17:02:28.472681",
    "generation_time": 3.0829145908355713,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\round_1c\\intranets",
    "problem_name": "Intranets",
    "python_code": "from math import factorial\n\nMOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    return pow(a, m - 2, m)\n\ndef comb(n, k, p):\n    if k > n:\n        return 0\n    num = den = 1\n    for i in range(k):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * mod_inverse(den, p) % p\n\ndef count_ways(M, K):\n    n = M * (M - 1) // 2\n    if K == 1:\n        return 1\n    if K > n or K < 1:\n        return 0\n    ways = 0\n    for i in range(K):\n        ways += comb(n, i, MOD)\n        ways %= MOD\n    return ways * mod_inverse(comb(M - 1, K - 1, MOD), MOD) % MOD\n\ndef solve():\n    T = int(input())\n    results = []\n    for t in range(1, T + 1):\n        M, K = map(int, input().split())\n        result = count_ways(M, K)\n        results.append(f\"Case #{t}: {result}\")\n    return '\\n'.join(results)\n\nprint(solve())",
    "generated_at": "2025-05-03T17:02:33.246434",
    "generation_time": 4.749904155731201,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\round_1c\\letter_blocks",
    "problem_name": "Letter Blocks",
    "python_code": "def can_stack_towers(towers):\n    from collections import Counter\n\n    def is_valid_megatower(megatower):\n        letter_counts = Counter(megatower)\n        for letter in set(megatower):\n            if letter not in letter_counts:\n                continue\n            start_index = megatower.index(letter)\n            end_index = len(megatower) - 1 - megatower[::-1].index(letter)\n            if any(megatower[i] != letter for i in range(start_index + 1, end_index)):\n                return False\n        return True\n\n    def combine_towers(towers):\n        from itertools import permutations\n\n        min_length = float('inf')\n        best_megatower = None\n        for perm in permutations(towers):\n            megatower = ''.join(perm)\n            if is_valid_megatower(megatower) and len(megatower) < min_length:\n                min_length = len(megatower)\n                best_megatower = megatower\n        return best_megatower\n\n    for i, towers in enumerate(towers):\n        result = combine_towers(towers)\n        if result is None:\n            print(f\"Case #{i+1}: IMPOSSIBLE\")\n        else:\n            print(f\"Case #{i+1}: {result}\")\n\n# Example usage:\ntowers = [\n    [\"JAMMICCODEEELZZZZZ\", \"ZZZZZJAMMICCODEEEL\"],\n    [\"H\", \"EEK\", \"HASH\", \"EEK\"],\n    [\"OOY\", \"YYO\"],\n    [\"HH\", \"HS\"],\n    [\"AA\", \"BB\", \"CC\"],\n    [\"A\", \"B\"]\n]\n\ncan_stack_towers(towers)",
    "generated_at": "2025-05-03T17:02:39.170185",
    "generation_time": 5.873431205749512,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\round_1c\\squary",
    "problem_name": "Squary",
    "python_code": "def find_squary_elements(N, K, E):\n    sum_E = sum(E)\n    sum_E_square = sum(x**2 for x in E)\n    target = (sum_E + K)**2 - sum_E_square\n\n    if target == 0:\n        return \"IMPOSSIBLE\"\n    \n    added_elements = []\n    for _ in range(K):\n        if target % (K - len(added_elements)) == 0:\n            added_element = target // (K - len(added_elements))\n            added_elements.append(added_element)\n            sum_E += added_element\n            sum_E_square += added_element**2\n            target = (sum_E + K)**2 - sum_E_square\n    \n    if sum_E_square != (sum_E + K)**2:\n        return \"IMPOSSIBLE\"\n    \n    return ' '.join(map(str, added_elements))\n\nT = int(input())\nresults = []\nfor i in range(1, T+1):\n    N, K = map(int, input().split())\n    E = list(map(int, input().split()))\n    results.append(f\"Case #{i}: {find_squary_elements(N, K, E)}\")\n\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T17:02:43.392035",
    "generation_time": 4.176344871520996,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\round_2\\i_o_bot",
    "problem_name": "I, O Bot",
    "python_code": "def min_power_to_warehouse(N, C, balls):\n    balls.sort()\n    total_power = 0\n    left_index = 0\n    right_index = N - 1\n    \n    while left_index <= right_index:\n        if balls[left_index][1] == '0':\n            left_distance = abs(balls[left_index][0])\n            right_distance = abs(balls[right_index][0])\n            if left_distance < right_distance:\n                total_power += left_distance * C\n                left_index += 1\n            else:\n                total_power += right_distance * C\n                right_index -= 1\n        else:\n            left_distance = abs(balls[left_index][0])\n            right_distance = abs(balls[right_index][0])\n            if left_distance < right_distance:\n                total_power += left_distance\n                left_index += 1\n            else:\n                total_power += right_distance\n                right_index -= 1\n    \n    return total_power\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        C = int(data[index + 1])\n        balls = []\n        index += 2\n        \n        for _ in range(N):\n            X = int(data[index])\n            S = data[index + 1]\n            balls.append((X, S))\n            index += 2\n        \n        result = min_power_to_warehouse(N, C, balls)\n        results.append(f\"Case #{len(results) + 1}: {result}\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:02:49.273557",
    "generation_time": 5.865392208099365,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\round_2\\pixelated_circle",
    "problem_name": "Pixelated Circle",
    "python_code": "def draw_circle_filled(R):\n    pixels = [[0] * (2*R + 1) for _ in range(2*R + 1)]\n    for x in range(-R, R+1):\n        for y in range(-R, R+1):\n            if x*x + y*y <= R*R:\n                pixels[x + R][y + R] = 1\n    return pixels\n\ndef draw_circle_filled_wrong(R):\n    pixels = [[0] * (2*R + 1) for _ in range(2*R + 1)]\n    for x in range(-R, R+1):\n        for y in range(-R, R+1):\n            if abs(x*x - y*y) <= R*R:\n                pixels[x + R][y + R] = 1\n    return pixels\n\ndef count_different_pixels(R):\n    filled = draw_circle_filled(R)\n    wrong = draw_circle_filled_wrong(R)\n    different_count = sum(1 for i in range(2*R+1) for j in range(2*R+1) if filled[i][j] != wrong[i][j])\n    return different_count\n\nT = int(input())\nfor t in range(1, T + 1):\n    R = int(input())\n    result = count_different_pixels(R)\n    print(f\"Case #{t}: {result}\")",
    "generated_at": "2025-05-03T17:02:53.761121",
    "generation_time": 4.454864740371704,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\round_2\\saving_the_jelly",
    "problem_name": "Saving the Jelly",
    "python_code": "import heapq\n\ndef euclidean_distance(x1, y1, x2, y2):\n    return (x1 - x2) ** 2 + (y1 - y2) ** 2\n\ndef find_closest_sweet(child_pos, sweets, taken_sweets):\n    min_heap = []\n    for sweet in sweets:\n        if sweet not in taken_sweets:\n            distance = euclidean_distance(child_pos[0], child_pos[1], sweet[0], sweet[1])\n            heapq.heappush(min_heap, (distance, sweet))\n    return min_heap\n\ndef can_save_blueberry_jelly(N, children, sweets):\n    blueberry_jelly = sweets[0]\n    taken_sweets = set()\n    result = []\n    \n    for i in range(1, N + 2):\n        closest_sweet = None\n        closest_distance = float('inf')\n        \n        for child in children:\n            if child not in taken_sweets:\n                heap = find_closest_sweet(child, sweets, taken_sweets)\n                while heap and heap[0][1] in taken_sweets:\n                    heapq.heappop(heap)\n                \n                if heap and heap[0][0] < closest_distance:\n                    closest_distance = heap[0][0]\n                    closest_sweet = child\n        \n        if closest_sweet is None:\n            return \"IMPOSSIBLE\"\n        \n        result.append((closest_sweet, blueberry_jelly))\n        taken_sweets.add(blueberry_jelly)\n    \n    return \"POSSIBLE\\n\" + \"\\n\".join(f\"{a} {b}\" for a, b in result)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        \n        children = []\n        for _ in range(N):\n            X = int(data[index])\n            Y = int(data[index + 1])\n            children.append((X, Y))\n            index += 2\n        \n        sweets = []\n        for _ in range(N + 1):\n            X = int(data[index])\n            Y = int(data[index + 1])\n            sweets.append((X, Y))\n            index += 2\n        \n        result = can_save_blueberry_jelly(N, children, sweets)\n        results.append(result)\n    \n    for i, result in enumerate(results, start=1):\n        print(f\"Case #{i}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:03:02.533837",
    "generation_time": 8.72766399383545,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\round_2\\spiraling_into_control",
    "problem_name": "Spiraling Into Control",
    "python_code": "def find_shortcuts(N, K):\n    if N * N - 1 <= K:\n        return \"IMPOSSIBLE\"\n    \n    center = N * N // 2 + 1\n    moves = [0] * (N * N)\n    x, y = 0, 0\n    dx, dy = 0, 1\n    \n    for i in range(1, N * N):\n        moves[i] = i\n        if i % 2 == 0:\n            dx, dy = -dy, dx\n        \n        while (x + dx < 0 or x + dx >= N) or (y + dy < 0 or y + dy >= N) or moves[moves[i]] != moves[i] + 1:\n            dx, dy = -dy, dx\n            if (x + dx < 0 or x + dx >= N) or (y + dy < 0 or y + dy >= N):\n                return \"IMPOSSIBLE\"\n        \n        x += dx\n        y += dy\n    \n    shortcuts = []\n    for i in range(1, K + 2):\n        if moves[i] != moves[i - 1] + 1:\n            shortcuts.append((moves[i - 1], moves[i]))\n    \n    return len(shortcuts), shortcuts\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        result = find_shortcuts(N, K)\n        if result == \"IMPOSSIBLE\":\n            results.append(f\"Case #{_+1}: IMPOSSIBLE\")\n        else:\n            num_shortcuts, shortcuts = result\n            results.append(f\"Case #{_+1}: {num_shortcuts}\")\n            for a, b in shortcuts:\n                results.append(f\"{a} {b}\")\n    \n    print(\"\\n\".join(results))\n\nsolve()",
    "generated_at": "2025-05-03T17:03:10.471854",
    "generation_time": 7.914628744125366,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\round_3\\duck_duck_geese",
    "problem_name": "Duck, Duck, Geese",
    "python_code": "def count_geese_choices(N, C, A, B, P):\n    from itertools import combinations\n\n    def is_valid_set(s):\n        color_count = [0] * (C + 1)\n        for i in s:\n            color_count[P[i]] += 1\n        return all(A[c] <= color_count[c] <= B[c] for c in range(1, C + 1))\n\n    total_choices = 0\n    for length in range(2, N):\n        for start in range(N - length + 1):\n            subset = set(range(start, start + length))\n            if is_valid_set(subset):\n                total_choices += 1\n\n    return total_choices\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n\n    for _ in range(T):\n        N = int(data[index])\n        C = int(data[index + 1])\n        A = [0] * (C + 1)\n        B = [0] * (C + 1)\n        P = []\n        index += 2\n\n        for i in range(C):\n            A[i + 1] = int(data[index])\n            B[i + 1] = int(data[index + 1])\n            index += 2\n\n        for _ in range(N):\n            P.append(int(data[index]))\n            index += 1\n\n        result = count_geese_choices(N, C, A, B, P)\n        results.append(f\"Case #{_+1}: {result}\")\n\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    solve()",
    "generated_at": "2025-05-03T17:03:16.245059",
    "generation_time": 5.749879598617554,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\round_3\\mascot_maze",
    "problem_name": "Mascot Maze",
    "python_code": "def solve_mascot_assignment(N, L, R):\n    mascot_count = [0] * N\n    for i in range(N):\n        if L[i] != -1:\n            mascot_count[L[i]] += 1\n        if R[i] != -1:\n            mascot_count[R[i]] += 1\n    \n    max_mascot_needed = max(mascot_count)\n    if max_mascot_needed > 13:\n        return \"IMPOSSIBLE\"\n    \n    mascots = list(\"ACDEHIJKMORST\")\n    assignment = [''] * N\n    used = set()\n    \n    for i in range(N):\n        if L[i] != -1 and R[i] != -1:\n            if assignment[L[i]] == '' and assignment[R[i]] == '':\n                assignment[L[i]] = mascots[0]\n                assignment[R[i]] = mascots[1]\n                used.add(mascots[0])\n                used.add(mascots[1])\n                mascots = mascots[2:]\n    \n    for i in range(N):\n        if L[i] != -1 and assignment[L[i]] == '':\n            assignment[L[i]] = assignment[R[i]]\n        elif R[i] != -1 and assignment[R[i]] == '':\n            assignment[R[i]] = assignment[L[i]]\n    \n    return ''.join(assignment)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        L = [-1] * N\n        R = [-1] * N\n        index += 1\n        \n        for i in range(N):\n            L[i] = int(data[index]) - 1\n            index += 1\n        \n        for i in range(N):\n            R[i] = int(data[index]) - 1\n            index += 1\n        \n        result = solve_mascot_assignment(N, L, R)\n        results.append(result)\n    \n    for i, result in enumerate(results, 1):\n        print(f\"Case #{i}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:03:23.565285",
    "generation_time": 7.294933557510376,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\round_3\\revenge_of_gorosort",
    "problem_name": "Revenge of GoroSort",
    "python_code": "import sys\n\ndef read_input():\n    return [int(x) for x in input().split()]\n\ndef write_output(data):\n    print(*data, flush=True)\n\ndef main():\n    T, N, K = read_input()\n    for _ in range(T):\n        balls = read_input()\n        colors = list(range(1, N + 1))\n        for _ in range(K):\n            write_output(colors)\n            result = read_input()\n            if result == balls:\n                break\n            # Update colors based on the current state of the balls\n            new_colors = [colors[i] for i in range(N) if result[i] != balls[i]]\n            colors = list(range(1, N + 1))\n        else:\n            print(\"Failed to sort\", file=sys.stderr)\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:03:26.708864",
    "generation_time": 3.126837968826294,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\round_3\\win_as_second",
    "problem_name": "Win As Second",
    "python_code": "import sys\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        print(N - 1)\n        for i in range(1, N):\n            print(f\"{i} {i + 1}\")\n        \n        M = int(input())\n        for _ in range(M):\n            K = int(input())\n            vertices = list(map(int, input().split()))\n            if len(vertices) != K or any(v < 1 or v > N for v in vertices):\n                sys.stdout.write(\"-1\\n\")\n                return\n            # Vreni's turn: color the last vertex and its neighbors red\n            last_vertex = vertices[-1]\n            neighbors = [v for v in range(1, N + 1) if v != last_vertex and (v < last_vertex and v % last_vertex == 0 or v > last_vertex and v // last_vertex == last_vertex)]\n            num_neighbors = len(neighbors)\n            if K - 1 != num_neighbors:\n                sys.stdout.write(\"-1\\n\")\n                return\n            for neighbor in neighbors:\n                print(f\"{neighbor} {neighbor + 1}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:03:31.295252",
    "generation_time": 4.576077222824097,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\world_finals\\goose_goose_ducks",
    "problem_name": "Goose, Goose, Ducks?",
    "python_code": "from collections import defaultdict\n\ndef min_ducks(T, test_cases):\n    results = []\n    \n    for i in range(T):\n        N, M, S = map(int, input().split())\n        duck_meetings = [tuple(map(int, input().split())) for _ in range(M)]\n        statements = [tuple(map(int, input().split())) for _ in range(S)]\n        \n        # Create a graph to represent the possible paths\n        graph = defaultdict(list)\n        for A, B, U, V, D in statements:\n            graph[A].append((B, U, V, D))\n            graph[B].append((A, U, V, D))\n        \n        # Perform BFS to find the minimum number of ducks\n        from collections import deque\n        \n        def bfs(start):\n            visited = set()\n            queue = deque([(start, 0)])\n            while queue:\n                current, time = queue.popleft()\n                if time >= D and (current, U, V) not in visited:\n                    visited.add((current, U, V))\n                    continue\n                for neighbor, U2, V2, D2 in graph[current]:\n                    if (neighbor, U2, V2) not in visited:\n                        queue.append((neighbor, time + 1))\n            return len(visited)\n        \n        min_ducks = float('inf')\n        for A in range(1, N+1):\n            min_ducks = min(min_ducks, bfs(A))\n        \n        results.append(f\"Case #{i+1}: {min_ducks}\")\n    \n    return results\n\n# Read input\nT = int(input())\ntest_cases = []\nfor _ in range(T):\n    test_cases.append(int(input()))\n    N, M, S = map(int, input().split())\n    duck_meetings = [tuple(map(int, input().split())) for _ in range(M)]\n    statements = [tuple(map(int, input().split())) for _ in range(S)]\n    test_cases.extend([N, M, S] + duck_meetings + statements)\n\n# Process the input and print results\nresults = min_ducks(T, test_cases)\nfor result in results:\n    print(result)",
    "generated_at": "2025-05-03T17:03:38.742445",
    "generation_time": 7.436368703842163,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\world_finals\\schrdinger_and_pavlov",
    "problem_name": "Schr\u00f6dinger and Pavlov",
    "python_code": "MOD = 10**9 + 7\n\ndef count_configurations(N, S, B):\n    if '?' not in S:\n        return int(S[-1] == 'C')\n    \n    unknown_indices = [i for i in range(N) if S[i] == '?']\n    num_unknowns = len(unknown_indices)\n    \n    if N - 1 in unknown_indices:\n        return (2 ** (num_unknowns - 1)) % MOD\n    \n    last_box_index = unknown_indices[-1]\n    first_box_with_tunnel_to_last = None\n    for i in range(last_box_index):\n        if B[i] == last_box_index + 1:\n            first_box_with_tunnel_to_last = i\n            break\n    \n    if first_box_with_tunnel_to_last is None:\n        return (2 ** num_unknowns) % MOD\n    \n    configurations = 0\n    for i in range(2 ** num_unknowns):\n        config = [False] * N\n        for j in range(num_unknowns):\n            if i & (1 << j):\n                config[unknown_indices[j]] = True\n        \n        current_box = first_box_with_tunnel_to_last\n        while current_box != last_box_index:\n            next_box = B[current_box]\n            if not config[next_box - 1]:\n                break\n            current_box = next_box - 1\n        \n        if current_box == last_box_index and not any(config):\n            configurations += 1\n    \n    return configurations % MOD\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        S = data[index + 1]\n        B = list(map(int, data[index + 2:index + 2 + N]))\n        \n        result = count_configurations(N, S, B)\n        results.append(result)\n        \n        index += 2 + N\n    \n    for i, result in enumerate(results):\n        print(f\"Case #{i+1}: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "generated_at": "2025-05-03T17:03:46.539655",
    "generation_time": 7.745684623718262,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\world_finals\\slide_parade",
    "problem_name": "Slide Parade",
    "python_code": "def find_parade_route(T):\n    results = []\n    \n    for t in range(1, T + 1):\n        B, S = map(int, input().split())\n        graph = [[] for _ in range(B)]\n        \n        for _ in range(S):\n            U_i, V_i = map(int, input().split())\n            graph[U_i - 1].append(V_i - 1)\n        \n        def dfs(node, path):\n            if len(path) > 10**6:\n                return False\n            if node == 0 and len(path) != B * 2 + 1:\n                return False\n            if node == 0 and len(path) == B * 2 + 1:\n                results.append((t, path))\n                return True\n            visited[node] = True\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    dfs(neighbor, path + [neighbor])\n            visited[node] = False\n        \n        visited = [False] * B\n        dfs(0, [0])\n    \n    for case, route in results:\n        print(f\"Case #{case}: {len(route)}\")\n        print(\" \".join(map(str, route)))\n\n# Example usage:\nT = int(input())\nfind_parade_route(T)",
    "generated_at": "2025-05-03T17:03:50.832495",
    "generation_time": 4.269742727279663,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\world_finals\\triangles",
    "problem_name": "Triangles",
    "python_code": "from itertools import combinations\n\ndef max_triangles(points):\n    def is_triangle(p1, p2, p3):\n        return (p1[0] * (p2[1] - p3[1]) +\n                p2[0] * (p3[1] - p1[1]) +\n                p3[0] * (p1[1] - p2[1])) != 0\n\n    max_triangles = []\n    for triplet in combinations(points, 3):\n        if is_triangle(*triplet):\n            max_triangles.append(triplet)\n    return len(max_triangles), max_triangles\n\ndef solve():\n    T = int(input())\n    results = []\n    for i in range(1, T + 1):\n        N = int(input())\n        points = [tuple(map(int, input().split())) for _ in range(N)]\n        count, triangles = max_triangles(points)\n        results.append(f\"Case #{i}: {count}\")\n        for triangle in triangles:\n            p, q, r = sorted(triangle, key=lambda x: (x[0], x[1]))\n            results.append(f\"{p[0]} {p[1]} {q[0]} {q[1]} {r[0]} {r[1]}\")\n    return '\\n'.join(results)\n\nprint(solve())",
    "generated_at": "2025-05-03T17:03:55.222893",
    "generation_time": 4.360480070114136,
    "model": "qwen2.5-coder:7b"
  },
  {
    "source": "2022\\world_finals\\wonderland_chase",
    "problem_name": "Wonderland Chase",
    "python_code": "from collections import defaultdict\n\ndef bfs_shortest_path(graph, start, goal):\n    queue = [(start, [start])]\n    visited = set()\n    while queue:\n        (vertex, path) = queue.pop(0)\n        if vertex not in visited:\n            for next_vertex in graph[vertex]:\n                if next_vertex == goal:\n                    return path + [next_vertex]\n                else:\n                    queue.append((next_vertex, path + [next_vertex]))\n            visited.add(vertex)\n    return None\n\ndef catch_alice(J, C, A, Q, corridors):\n    graph = defaultdict(list)\n    for u, v in corridors:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Alice's optimal first move\n    alice_moves = [None] * J\n    for i in range(1, J + 1):\n        if i != A and i != Q:\n            path = bfs_shortest_path(graph, A, i)\n            if path:\n                alice_moves[i] = len(path)\n\n    min_moves = float('inf')\n    best_move = None\n\n    # Find the move that minimizes the number of moves to catch Alice\n    for u in range(1, J + 1):\n        if u != A and u != Q:\n            path = bfs_shortest_path(graph, Q, u)\n            if path:\n                queen_moves = len(path)\n                if alice_moves[u] is not None:\n                    total_moves = queen_moves + alice_moves[u]\n                    if total_moves < min_moves:\n                        min_moves = total_moves\n                        best_move = u\n\n    # If Alice cannot be caught in 10^9 moves, return \"SAFE\"\n    if min_moves > 10**9:\n        return \"SAFE\"\n\n    return min_moves\n\n# Read input and process each test case\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(T):\n    J = int(data[index])\n    C = int(data[index + 1])\n    A = int(data[index + 2])\n    Q = int(data[index + 3])\n    index += 4\n\n    corridors = []\n    for _ in range(C):\n        u = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        corridors.append((u, v))\n\n    result = catch_alice(J, C, A, Q, corridors)\n    results.append(result)\n\n# Output the results\nfor i, result in enumerate(results):\n    print(f\"Case #{i+1}: {result}\")",
    "generated_at": "2025-05-03T17:04:03.912476",
    "generation_time": 8.671611070632935,
    "model": "qwen2.5-coder:7b"
  }
]